=== STORE PROJECT CODE EXPORT ===
Generated: Sat Jan 31 13:46:44 EST 2026

### BACKEND ###
================================================
FILE: backend/config/settings/base.py
================================================
"""
Base Django settings for Photography Store.
"""
import os
from pathlib import Path

from dotenv import load_dotenv

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent.parent

SECRET_KEY = os.environ['SECRET_KEY']  # No default â€” crash on startup if missing

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third party
    'rest_framework',
    'django_filters',
    'corsheaders',
    'storages',
    # Local apps
    'apps.core',
    'apps.catalog',
    'apps.orders',
    'apps.payments',
    'apps.mockup',
    'apps.chat',
    # django-cleanup MUST be last (deletes files when models are deleted)
    'django_cleanup.apps.CleanupConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'America/New_York'
USE_I18N = True
USE_TZ = True

STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

MEDIA_URL = 'media/'
MEDIA_ROOT = BASE_DIR / 'media'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/hour',           # General API: 100 requests/hour per IP
        'newsletter': '5/hour',        # Newsletter signup: 5/hour per IP
        'contact': '10/hour',          # Contact form: 10/hour per IP
        'chat': '30/hour',            # AI chat: 30 requests/hour per IP
        'uploads': '20/hour',          # File uploads: 20/hour per IP
        'checkout': '20/hour',         # Stripe checkout: 20/hour per IP
        'gift_card': '10/hour',        # Gift card purchase: 10/hour per IP
        'gift_card_check': '15/hour',  # Gift card balance check: 15/hour per IP
        'order_lookup': '20/hour',     # Order lookup by session: 20/hour per IP
        'order_tracking': '10/hour',   # Order tracking: 10/hour per IP
    },
}

# Session settings for cart
SESSION_ENGINE = 'django.contrib.sessions.backends.db'
SESSION_COOKIE_AGE = 60 * 60 * 24 * 30  # 30 days

# Stripe
STRIPE_SECRET_KEY = os.getenv('STRIPE_SECRET_KEY', '')
STRIPE_PUBLISHABLE_KEY = os.getenv('STRIPE_PUBLISHABLE_KEY', '')
STRIPE_WEBHOOK_SECRET = os.getenv('STRIPE_WEBHOOK_SECRET', '')

# Frontend URL for Stripe redirects
FRONTEND_URL = os.getenv('FRONTEND_URL', 'http://localhost:3000')

# AWS S3 Settings
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID', '')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY', '')
AWS_STORAGE_BUCKET_NAME = os.getenv('AWS_STORAGE_BUCKET_NAME', '')
AWS_S3_REGION_NAME = os.getenv('AWS_S3_REGION_NAME', 'us-east-1')
AWS_S3_CUSTOM_DOMAIN = f'{AWS_STORAGE_BUCKET_NAME}.s3.{AWS_S3_REGION_NAME}.amazonaws.com'
AWS_S3_OBJECT_PARAMETERS = {
    # 1 year cache - photos are immutable (new uploads get new filenames)
    'CacheControl': 'max-age=31536000, public',
}
AWS_DEFAULT_ACL = None
AWS_QUERYSTRING_AUTH = False
AWS_S3_FILE_OVERWRITE = False

# Email settings (Resend)
RESEND_API_KEY = os.getenv('RESEND_API_KEY', '')
DEFAULT_FROM_EMAIL = os.getenv('DEFAULT_FROM_EMAIL', 'Matt <hello@matthewraynor.com>')
ADMIN_EMAIL = os.getenv('ADMIN_EMAIL', 'hello@matthewraynor.com')

# MailerLite (newsletter)
MAILERLITE_API_KEY = os.getenv('MAILERLITE_API_KEY', '')

# Store info (for emails)
STORE_NAME = 'Matthew Raynor Photography'
STORE_URL = os.getenv('FRONTEND_URL', 'https://store.matthewraynor.com')

# Celery Configuration
CELERY_BROKER_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
CELERY_RESULT_BACKEND = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
CELERY_TASK_SOFT_TIME_LIMIT = 30  # Soft timeout in seconds
CELERY_TASK_TIME_LIMIT = 45  # Hard timeout in seconds
CELERY_TASK_ALWAYS_EAGER = os.getenv('CELERY_TASK_ALWAYS_EAGER', 'False').lower() == 'true'
CELERY_BEAT_SCHEDULE = {
    'cleanup-old-mockups': {
        'task': 'apps.mockup.tasks.cleanup_old_wall_analyses',
        'schedule': 60 * 60 * 6,  # Every 6 hours
    },
    'cleanup-stale-carts': {
        'task': 'apps.orders.tasks.cleanup_stale_carts',
        'schedule': 60 * 60 * 24,  # Daily
    },
}

# AI Chat Agent
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY', '')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', '')  # For embeddings


================================================
FILE: backend/config/settings/production.py
================================================
"""
Production settings for Photography Store.
"""
import os
import re

from .base import *

DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'

# Allow Railway's health check and configured hosts
# Set ALLOWED_HOSTS env var to: your-app.up.railway.app,store-api.matthewraynor.com
ALLOWED_HOSTS = [h.strip() for h in os.getenv('ALLOWED_HOSTS', '').split(',') if h.strip()]
# Add Railway's internal hostname pattern for health checks
ALLOWED_HOSTS.append('.railway.internal')

# Database - PostgreSQL for production (supports DATABASE_URL from Railway)
DATABASE_URL = os.getenv('DATABASE_URL')
if DATABASE_URL:
    # Parse DATABASE_URL (postgres://user:pass@host:port/dbname)
    match = re.match(
        r'(?:postgres(?:ql)?://)?(?P<user>[^:]+):(?P<password>[^@]+)@(?P<host>[^:]+):(?P<port>\d+)/(?P<name>.+)',
        DATABASE_URL
    )
    if match:
        DATABASES = {
            'default': {
                'ENGINE': 'django.db.backends.postgresql',
                'NAME': match.group('name'),
                'USER': match.group('user'),
                'PASSWORD': match.group('password'),
                'HOST': match.group('host'),
                'PORT': match.group('port'),
            }
        }
else:
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': os.getenv('DB_NAME', 'photography_store'),
            'USER': os.getenv('DB_USER', ''),
            'PASSWORD': os.getenv('DB_PASSWORD', ''),
            'HOST': os.getenv('DB_HOST', 'localhost'),
            'PORT': os.getenv('DB_PORT', '5432'),
        }
    }

# CORS - Restrict to frontend domain
cors_origins = os.getenv('CORS_ALLOWED_ORIGINS', '')
CORS_ALLOWED_ORIGINS = [o.strip() for o in cors_origins.split(',') if o.strip()]
CORS_ALLOW_CREDENTIALS = True

# CSRF trusted origins (required for Django 4+ cross-origin POST)
CSRF_TRUSTED_ORIGINS = [o.strip() for o in cors_origins.split(',') if o.strip()]

# WhiteNoise - serve static files in production
WHITENOISE_USE_FINDERS = True

# S3 storage for media files
STORAGES = {
    "default": {
        "BACKEND": "apps.core.storage.PublicMediaStorage",
    },
    "staticfiles": {
        "BACKEND": "whitenoise.storage.CompressedStaticFilesStorage",
    },
}
MEDIA_URL = f'https://{AWS_S3_CUSTOM_DOMAIN}/media/'

# Security settings
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_SAMESITE = 'Lax'  # Same-site cookies now that API is on same domain
SESSION_COOKIE_DOMAIN = '.matthewraynor.com'  # Share cookies across subdomains
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_SAMESITE = 'Lax'  # Same-site cookies now that API is on same domain
CSRF_COOKIE_DOMAIN = '.matthewraynor.com'  # Share cookies across subdomains
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Email - SMTP (works with Resend, Postmark, etc.)
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = os.getenv('EMAIL_HOST', 'smtp.resend.com')
EMAIL_PORT = int(os.getenv('EMAIL_PORT', '587'))
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER', 'resend')
EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD', '')


================================================
FILE: backend/config/urls.py
================================================
"""
URL configuration for Photography Store.
"""
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from django.http import JsonResponse, HttpResponse


def health_check(request):
    return JsonResponse({'status': 'ok'})


def robots_txt(request):
    return HttpResponse(
        "User-agent: *\nDisallow: /\n",
        content_type="text/plain",
    )


urlpatterns = [
    path('robots.txt', robots_txt),
    path('admin/', admin.site.urls),
    path('api/health/', health_check),
    path('api/', include('apps.catalog.urls')),
    path('api/', include('apps.orders.urls')),
    path('api/', include('apps.payments.urls')),
    path('api/', include('apps.core.urls')),
    path('api/mockup/', include('apps.mockup.urls')),
    path('api/chat/', include('apps.chat.urls')),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


================================================
FILE: backend/config/celery.py
================================================
"""
Celery configuration for Photography Store.
"""
import os
from celery import Celery

# Set the default Django settings module
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings.production')

app = Celery('store')

# Load config from Django settings, using CELERY_ prefix
app.config_from_object('django.conf:settings', namespace='CELERY')

# Auto-discover tasks in all registered Django apps
app.autodiscover_tasks()


@app.task(bind=True, ignore_result=True)
def debug_task(self):
    """Debug task for testing Celery connectivity."""
    print(f'Request: {self.request!r}')


================================================
FILE: backend/requirements.txt
================================================
django>=5.0
djangorestframework>=3.14
django-filter>=24.0
django-cors-headers>=4.3
django-storages[s3]>=1.14
django-cleanup>=8.0
boto3>=1.34
stripe>=7.0
psycopg2-binary>=2.9
python-dotenv>=1.0
Pillow>=10.0
gunicorn>=21.0
whitenoise>=6.6
resend>=2.0

# Celery (async tasks)
celery[redis]>=5.3.0
redis>=5.0.0

# ML / Wall Detection
onnxruntime>=1.16.0
opencv-python-headless>=4.8.0
scikit-learn>=1.3.0
numpy>=1.24.0
scipy>=1.11.0

# AI Chat Agent
langchain>=0.3.0
langchain-anthropic>=0.3.0
pgvector>=0.3.0
anthropic>=0.40.0
openai>=1.50.0


================================================
FILE: backend/Procfile
================================================
web: python manage.py collectstatic --noinput && python manage.py migrate && gunicorn config.wsgi:application --bind 0.0.0.0:$PORT
worker: celery -A config worker -l info --concurrency=2


================================================
FILE: backend/start.sh
================================================
#!/bin/bash
set -e

echo "=== Starting Django server ==="
echo "PORT: $PORT"
echo "REDIS_URL: ${REDIS_URL:0:20}..."

echo "=== Running migrations ==="
python manage.py migrate

echo "=== Running Django checks ==="
python manage.py check

echo "=== Generating embeddings (if needed) ==="
python manage.py generate_photo_embeddings

echo "=== Checking embeddings ==="
python -c "import os; os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings.production'); import django; django.setup(); from apps.catalog.models import Photo; print(f'Photos with embeddings: {Photo.objects.filter(embedding__isnull=False).count()}/{Photo.objects.count()}')"

echo "=== Cleaning up old mockup images ==="
python -c "import os; os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings.production'); import django; django.setup(); from apps.mockup.tasks import cleanup_old_wall_analyses; count = cleanup_old_wall_analyses(hours=24); print(f'Deleted {count} old wall analyses')"

echo "=== Starting gunicorn ==="
exec gunicorn config.wsgi:application \
    --bind 0.0.0.0:${PORT:-8000} \
    --access-logfile - \
    --error-logfile - \
    --capture-output \
    --timeout 120


================================================
FILE: backend/apps/catalog/models.py
================================================
from django.db import models
from django.utils.text import slugify
from pgvector.django import VectorField


class Collection(models.Model):
    """A collection/series of photographs."""
    name = models.CharField(max_length=200)
    slug = models.SlugField(unique=True, max_length=200)
    description = models.TextField(blank=True)
    cover_image = models.ImageField(upload_to='collections/', blank=True)
    is_limited_edition = models.BooleanField(default=False)
    display_order = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True, db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['display_order', 'name']

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    @property
    def photo_count(self):
        return self.photos.filter(is_active=True).count()


class Photo(models.Model):
    """An individual photograph available for purchase."""

    ORIENTATION_CHOICES = [
        ('H', 'Horizontal'),
        ('V', 'Vertical'),
        ('S', 'Square'),
    ]

    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True, max_length=200)
    collection = models.ForeignKey(
        Collection,
        on_delete=models.CASCADE,
        related_name='photos'
    )
    image = models.ImageField(upload_to='photos/')
    thumbnail = models.ImageField(upload_to='photos/thumbnails/', blank=True)
    description = models.TextField(blank=True)
    location = models.CharField(max_length=200, blank=True)
    location_tag = models.CharField(
        max_length=100,
        blank=True,
        help_text='Lowercase tag for filtering (e.g., montauk, east-hampton)'
    )
    orientation = models.CharField(
        max_length=1,
        choices=ORIENTATION_CHOICES,
        default='H'
    )
    date_taken = models.DateField(null=True, blank=True)
    image_width = models.PositiveIntegerField(null=True, blank=True, editable=False)
    image_height = models.PositiveIntegerField(null=True, blank=True, editable=False)
    is_featured = models.BooleanField(default=False, db_index=True)
    is_active = models.BooleanField(default=True, db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # AI-generated fields for chat agent semantic search
    ai_description = models.TextField(
        blank=True,
        help_text='AI-generated rich description of the photograph'
    )
    ai_colors = models.JSONField(
        default=list,
        blank=True,
        help_text='AI-detected dominant colors (e.g., ["blue", "gold", "white"])'
    )
    ai_mood = models.JSONField(
        default=list,
        blank=True,
        help_text='AI-detected mood/feeling keywords (e.g., ["calm", "dramatic"])'
    )
    ai_subjects = models.JSONField(
        default=list,
        blank=True,
        help_text='AI-detected subjects (e.g., ["lighthouse", "ocean", "sunset"])'
    )
    ai_room_suggestions = models.JSONField(
        default=list,
        blank=True,
        help_text='AI-suggested room types (e.g., ["bedroom", "office", "living room"])'
    )

    # Vector embedding for semantic search (1536 dimensions for OpenAI embeddings)
    embedding = VectorField(
        dimensions=1536,
        null=True,
        blank=True,
        help_text='Vector embedding for semantic similarity search'
    )

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return self.title

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        # Auto-populate image dimensions
        if self.image:
            try:
                self.image_width = self.image.width
                self.image_height = self.image.height
            except Exception:
                pass  # Image not accessible yet
        super().save(*args, **kwargs)

    @property
    def aspect_ratio(self):
        """Returns the actual aspect ratio of the image."""
        if self.image_width and self.image_height:
            return self.image_width / self.image_height
        # Fallback based on orientation
        if self.orientation == 'V':
            return 2 / 3
        elif self.orientation == 'S':
            return 1
        return 3 / 2  # Default horizontal

    @property
    def price_range(self):
        """Returns the price range for this photo's variants."""
        variants = self.variants.filter(is_available=True)
        if not variants.exists():
            return None
        prices = variants.values_list('price', flat=True)
        return {'min': min(prices), 'max': max(prices)}


class ProductVariant(models.Model):
    """A purchasable variant of a photo (size + material combination)."""

    MATERIAL_CHOICES = [
        ('paper', 'Paper Print'),
        ('aluminum', 'Aluminum Print'),
    ]

    # Default pricing by size and material (width x height format)
    DEFAULT_PRICING = {
        # Paper prints (matted)
        ('14x11', 'paper'): {'price': 175, 'width': 14, 'height': 11},
        ('19x13', 'paper'): {'price': 250, 'width': 19, 'height': 13},
        # Aluminum prints
        ('24x16', 'aluminum'): {'price': 675, 'width': 24, 'height': 16},
        ('30x20', 'aluminum'): {'price': 995, 'width': 30, 'height': 20},
        ('36x24', 'aluminum'): {'price': 1350, 'width': 36, 'height': 24},
        ('40x30', 'aluminum'): {'price': 1850, 'width': 40, 'height': 30},
        ('45x30', 'aluminum'): {'price': 2150, 'width': 45, 'height': 30},
        ('60x40', 'aluminum'): {'price': 3400, 'width': 60, 'height': 40},
    }

    photo = models.ForeignKey(
        Photo,
        on_delete=models.CASCADE,
        related_name='variants'
    )
    size = models.CharField(max_length=20, help_text='e.g., 16x24, 20x30')
    material = models.CharField(max_length=20, choices=MATERIAL_CHOICES)
    price = models.DecimalField(max_digits=8, decimal_places=2)
    width_inches = models.PositiveIntegerField()
    height_inches = models.PositiveIntegerField()
    is_available = models.BooleanField(default=True)
    aluminyze_sku = models.CharField(
        max_length=100,
        blank=True,
        help_text='SKU for Aluminyze fulfillment (aluminum prints only)'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['material', 'price']
        unique_together = ['photo', 'size', 'material']

    def __str__(self):
        return f"{self.photo.title} - {self.size} {self.get_material_display()}"

    @property
    def display_name(self):
        return f'{self.size}" {self.get_material_display()}'


class Product(models.Model):
    """A standalone product like a book or merchandise."""

    PRODUCT_TYPE_CHOICES = [
        ('book', 'Book'),
        ('merch', 'Merchandise'),
    ]

    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True, max_length=200)
    product_type = models.CharField(max_length=20, choices=PRODUCT_TYPE_CHOICES, default='book')
    description = models.TextField(blank=True)
    long_description = models.TextField(blank=True, help_text='Detailed description for product page')
    image = models.ImageField(upload_to='products/')
    additional_images = models.JSONField(default=list, blank=True, help_text='List of additional image URLs')
    price = models.DecimalField(max_digits=8, decimal_places=2)
    compare_at_price = models.DecimalField(
        max_digits=8, decimal_places=2, null=True, blank=True,
        help_text='Original price for showing discounts'
    )
    sku = models.CharField(max_length=100, blank=True)
    weight_oz = models.DecimalField(max_digits=6, decimal_places=2, null=True, blank=True)
    stock_quantity = models.PositiveIntegerField(default=0)
    track_inventory = models.BooleanField(default=True)
    is_featured = models.BooleanField(default=False, db_index=True)
    is_active = models.BooleanField(default=True, db_index=True)

    # Book-specific fields
    author = models.CharField(max_length=200, blank=True)
    publisher = models.CharField(max_length=200, blank=True)
    publication_year = models.PositiveIntegerField(null=True, blank=True)
    pages = models.PositiveIntegerField(null=True, blank=True)
    dimensions = models.CharField(max_length=100, blank=True, help_text='e.g., 12" x 10"')
    isbn = models.CharField(max_length=20, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return self.title

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        super().save(*args, **kwargs)

    @property
    def is_in_stock(self):
        if not self.track_inventory:
            return True
        return self.stock_quantity > 0

    @property
    def is_on_sale(self):
        return self.compare_at_price and self.compare_at_price > self.price


================================================
FILE: backend/apps/catalog/views.py
================================================
from django.db import models
from django.db.models import Min, Prefetch
from django_filters import rest_framework as filters
from rest_framework import generics
from rest_framework.filters import OrderingFilter

from .models import Collection, Photo, Product
from .serializers import (
    CollectionListSerializer,
    CollectionDetailSerializer,
    PhotoListSerializer,
    PhotoDetailSerializer,
    ProductListSerializer,
    ProductDetailSerializer,
)


class PhotoFilter(filters.FilterSet):
    """Filter for photos."""
    collection = filters.CharFilter(field_name='collection__slug')
    location = filters.CharFilter(field_name='location_tag', lookup_expr='iexact')
    orientation = filters.ChoiceFilter(choices=Photo.ORIENTATION_CHOICES)
    material = filters.CharFilter(method='filter_by_material')
    min_price = filters.NumberFilter(method='filter_min_price')
    max_price = filters.NumberFilter(method='filter_max_price')
    featured = filters.BooleanFilter(field_name='is_featured')

    class Meta:
        model = Photo
        fields = ['collection', 'location', 'orientation', 'featured']

    def filter_by_material(self, queryset, name, value):
        """Filter photos that have variants in the specified material."""
        return queryset.filter(
            variants__material=value,
            variants__is_available=True
        ).distinct()

    def filter_min_price(self, queryset, name, value):
        """Filter photos with variants >= min price."""
        return queryset.filter(
            variants__price__gte=value,
            variants__is_available=True
        ).distinct()

    def filter_max_price(self, queryset, name, value):
        """Filter photos with variants <= max price."""
        return queryset.filter(
            variants__price__lte=value,
            variants__is_available=True
        ).distinct()


class CollectionListView(generics.ListAPIView):
    """List all active collections."""
    queryset = Collection.objects.filter(is_active=True)
    serializer_class = CollectionListSerializer


class CollectionDetailView(generics.RetrieveAPIView):
    """Get a single collection with its photos."""
    queryset = Collection.objects.filter(is_active=True).prefetch_related(
        Prefetch('photos', queryset=Photo.objects.filter(is_active=True).select_related('collection'))
    )
    serializer_class = CollectionDetailSerializer
    lookup_field = 'slug'


class PhotoListView(generics.ListAPIView):
    """List all active photos with filtering."""
    serializer_class = PhotoListSerializer
    filterset_class = PhotoFilter
    filter_backends = [filters.DjangoFilterBackend, OrderingFilter]
    ordering_fields = ['created_at', 'title', 'min_price']
    ordering = ['-created_at']

    def get_queryset(self):
        return Photo.objects.filter(is_active=True).select_related('collection').annotate(
            min_price=Min('variants__price', filter=models.Q(variants__is_available=True))
        )


class PhotoDetailView(generics.RetrieveAPIView):
    """Get a single photo with all variants."""
    queryset = Photo.objects.filter(is_active=True).select_related('collection').prefetch_related('variants')
    serializer_class = PhotoDetailSerializer
    lookup_field = 'slug'


class FeaturedPhotosView(generics.ListAPIView):
    """List featured photos for homepage (limited to 12)."""
    queryset = Photo.objects.filter(is_active=True, is_featured=True).select_related('collection')[:12]
    serializer_class = PhotoListSerializer
    pagination_class = None


class ProductListView(generics.ListAPIView):
    """List all active products."""
    queryset = Product.objects.filter(is_active=True)
    serializer_class = ProductListSerializer
    filter_backends = [filters.DjangoFilterBackend, OrderingFilter]
    filterset_fields = ['product_type', 'is_featured']
    ordering_fields = ['created_at', 'title', 'price']
    ordering = ['-created_at']


class ProductDetailView(generics.RetrieveAPIView):
    """Get a single product."""
    queryset = Product.objects.filter(is_active=True)
    serializer_class = ProductDetailSerializer
    lookup_field = 'slug'


================================================
FILE: backend/apps/catalog/serializers.py
================================================
from django.conf import settings
from rest_framework import serializers

from .models import Collection, Photo, ProductVariant, Product


class AbsoluteImageField(serializers.ImageField):
    """ImageField that returns absolute URLs using BACKEND_URL setting.

    This is needed because server-side rendering from Next.js uses internal Docker
    hostnames (e.g., 'http://backend:7974') which aren't accessible from the browser.
    """

    def to_representation(self, value):
        if not value:
            return None

        # Get the relative URL
        url = value.url

        # If already absolute (e.g., S3), return as-is
        if url.startswith('http'):
            return url

        # Build absolute URL using BACKEND_URL setting
        backend_url = getattr(settings, 'BACKEND_URL', None)
        if backend_url:
            return f"{backend_url}/{url.lstrip('/')}"

        # Fallback to request-based URL building
        request = self.context.get('request')
        if request:
            return request.build_absolute_uri(url)

        return url


class ProductVariantSerializer(serializers.ModelSerializer):
    display_name = serializers.CharField(read_only=True)
    material_display = serializers.CharField(source='get_material_display', read_only=True)

    class Meta:
        model = ProductVariant
        fields = [
            'id', 'size', 'material', 'material_display', 'display_name',
            'price', 'width_inches', 'height_inches', 'is_available'
        ]


class PhotoListSerializer(serializers.ModelSerializer):
    """Serializer for photo list views."""
    collection_name = serializers.CharField(source='collection.name', read_only=True)
    collection_slug = serializers.CharField(source='collection.slug', read_only=True)
    price_range = serializers.DictField(read_only=True)
    orientation_display = serializers.CharField(source='get_orientation_display', read_only=True)
    image = AbsoluteImageField(read_only=True)
    thumbnail = AbsoluteImageField(read_only=True)

    class Meta:
        model = Photo
        fields = [
            'id', 'title', 'slug', 'image', 'thumbnail',
            'collection_name', 'collection_slug',
            'location', 'location_tag', 'orientation', 'orientation_display',
            'is_featured', 'price_range', 'created_at'
        ]


class PhotoDetailSerializer(serializers.ModelSerializer):
    """Serializer for photo detail view with all variants."""
    collection_name = serializers.CharField(source='collection.name', read_only=True)
    collection_slug = serializers.CharField(source='collection.slug', read_only=True)
    variants = ProductVariantSerializer(many=True, read_only=True)
    price_range = serializers.DictField(read_only=True)
    orientation_display = serializers.CharField(source='get_orientation_display', read_only=True)
    aspect_ratio = serializers.FloatField(read_only=True)
    image = AbsoluteImageField(read_only=True)
    thumbnail = AbsoluteImageField(read_only=True)

    class Meta:
        model = Photo
        fields = [
            'id', 'title', 'slug', 'image', 'thumbnail', 'description',
            'collection_name', 'collection_slug',
            'location', 'location_tag', 'orientation', 'orientation_display',
            'date_taken', 'is_featured', 'price_range', 'variants', 'created_at',
            'aspect_ratio'
        ]


class CollectionListSerializer(serializers.ModelSerializer):
    """Serializer for collection list views."""
    photo_count = serializers.IntegerField(read_only=True)
    cover_image = AbsoluteImageField(read_only=True)

    class Meta:
        model = Collection
        fields = [
            'id', 'name', 'slug', 'description', 'cover_image',
            'is_limited_edition', 'photo_count'
        ]


class CollectionDetailSerializer(serializers.ModelSerializer):
    """Serializer for collection detail view with photos."""
    # photos are prefetched in the view with is_active=True filter
    photos = PhotoListSerializer(many=True, read_only=True)
    photo_count = serializers.IntegerField(read_only=True)
    cover_image = AbsoluteImageField(read_only=True)

    class Meta:
        model = Collection
        fields = [
            'id', 'name', 'slug', 'description', 'cover_image',
            'is_limited_edition', 'photo_count', 'photos'
        ]


class ProductListSerializer(serializers.ModelSerializer):
    """Serializer for product list views."""
    is_in_stock = serializers.BooleanField(read_only=True)
    is_on_sale = serializers.BooleanField(read_only=True)
    product_type_display = serializers.CharField(source='get_product_type_display', read_only=True)
    image = AbsoluteImageField(read_only=True)

    class Meta:
        model = Product
        fields = [
            'id', 'title', 'slug', 'product_type', 'product_type_display',
            'description', 'image', 'price', 'compare_at_price',
            'is_in_stock', 'is_on_sale', 'is_featured'
        ]


class ProductDetailSerializer(serializers.ModelSerializer):
    """Serializer for product detail view."""
    is_in_stock = serializers.BooleanField(read_only=True)
    is_on_sale = serializers.BooleanField(read_only=True)
    product_type_display = serializers.CharField(source='get_product_type_display', read_only=True)
    image = AbsoluteImageField(read_only=True)

    class Meta:
        model = Product
        fields = [
            'id', 'title', 'slug', 'product_type', 'product_type_display',
            'description', 'long_description', 'image', 'additional_images',
            'price', 'compare_at_price', 'is_in_stock', 'is_on_sale',
            'is_featured', 'author', 'publisher', 'publication_year',
            'pages', 'dimensions', 'isbn', 'stock_quantity'
        ]


================================================
FILE: backend/apps/catalog/urls.py
================================================
from django.urls import path

from . import views

app_name = 'catalog'

urlpatterns = [
    path('collections/', views.CollectionListView.as_view(), name='collection-list'),
    path('collections/<slug:slug>/', views.CollectionDetailView.as_view(), name='collection-detail'),
    path('photos/', views.PhotoListView.as_view(), name='photo-list'),
    path('photos/featured/', views.FeaturedPhotosView.as_view(), name='photo-featured'),
    path('photos/<slug:slug>/', views.PhotoDetailView.as_view(), name='photo-detail'),
    path('products/', views.ProductListView.as_view(), name='product-list'),
    path('products/<slug:slug>/', views.ProductDetailView.as_view(), name='product-detail'),
]


================================================
FILE: backend/apps/catalog/admin.py
================================================
from django.contrib import admin
from django.utils.html import format_html

from .models import Collection, Photo, ProductVariant, Product


class PhotoInline(admin.TabularInline):
    model = Photo
    extra = 0
    fields = ['title', 'slug', 'is_featured', 'is_active', 'created_date']
    readonly_fields = ['slug', 'created_date']
    show_change_link = True

    def created_date(self, obj):
        return obj.created_at.strftime('%Y-%m-%d') if obj.created_at else '-'
    created_date.short_description = 'Created'


@admin.register(Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ['name', 'slug', 'photo_count', 'is_limited_edition', 'is_active', 'display_order']
    list_filter = ['is_active', 'is_limited_edition']
    search_fields = ['name', 'description']
    prepopulated_fields = {'slug': ('name',)}
    ordering = ['display_order', 'name']
    inlines = [PhotoInline]

    def photo_count(self, obj):
        return obj.photos.filter(is_active=True).count()
    photo_count.short_description = 'Photos'


class ProductVariantInline(admin.TabularInline):
    model = ProductVariant
    extra = 1
    fields = ['size', 'material', 'price', 'width_inches', 'height_inches', 'is_available', 'aluminyze_sku']


@admin.register(Photo)
class PhotoAdmin(admin.ModelAdmin):
    list_display = ['title', 'collection', 'location', 'orientation', 'is_featured', 'is_active', 'image_preview', 'variant_count']
    list_filter = ['collection', 'orientation', 'is_featured', 'is_active', 'location_tag']
    search_fields = ['title', 'description', 'location']
    prepopulated_fields = {'slug': ('title',)}
    ordering = ['-created_at']
    readonly_fields = ['image_preview_large', 'created_at', 'updated_at']
    inlines = [ProductVariantInline]

    fieldsets = (
        (None, {
            'fields': ('title', 'slug', 'collection', 'description')
        }),
        ('Image', {
            'fields': ('image', 'thumbnail', 'image_preview_large')
        }),
        ('Location', {
            'fields': ('location', 'location_tag', 'orientation', 'date_taken')
        }),
        ('Status', {
            'fields': ('is_featured', 'is_active')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )

    def image_preview(self, obj):
        if obj.thumbnail:
            return format_html('<img src="{}" width="50" height="50" style="object-fit: cover;" />', obj.thumbnail.url)
        elif obj.image:
            return format_html('<img src="{}" width="50" height="50" style="object-fit: cover;" />', obj.image.url)
        return '-'
    image_preview.short_description = 'Preview'

    def image_preview_large(self, obj):
        if obj.image:
            return format_html('<img src="{}" style="max-width: 400px; max-height: 300px;" />', obj.image.url)
        return '-'
    image_preview_large.short_description = 'Image Preview'

    def variant_count(self, obj):
        return obj.variants.filter(is_available=True).count()
    variant_count.short_description = 'Variants'

    actions = ['make_featured', 'remove_featured', 'activate', 'deactivate',
                'create_paper_variants', 'create_aluminum_variants', 'create_all_variants',
                'remove_paper_variants', 'remove_aluminum_variants', 'remove_all_variants',
                'refresh_image_dimensions', 'delete_photos_and_variants']

    @admin.action(description='Mark selected photos as featured')
    def make_featured(self, request, queryset):
        queryset.update(is_featured=True)

    @admin.action(description='Remove featured status')
    def remove_featured(self, request, queryset):
        queryset.update(is_featured=False)

    @admin.action(description='Activate selected photos')
    def activate(self, request, queryset):
        queryset.update(is_active=True)

    @admin.action(description='Deactivate selected photos')
    def deactivate(self, request, queryset):
        queryset.update(is_active=False)

    def _get_variant_dimensions(self, photo, defaults):
        """Get width/height based on photo orientation. Flips for vertical photos."""
        width = defaults['width']
        height = defaults['height']
        # For vertical photos, swap dimensions so height > width
        if photo.orientation == 'V':
            width, height = height, width
        return width, height

    def _get_variant_size_label(self, photo, defaults):
        """Get size label based on photo orientation."""
        width, height = self._get_variant_dimensions(photo, defaults)
        return f'{width}x{height}'

    @admin.action(description='Create paper print variants (orientation-aware)')
    def create_paper_variants(self, request, queryset):
        created = 0
        for photo in queryset:
            for (size, material), defaults in ProductVariant.DEFAULT_PRICING.items():
                if material == 'paper':
                    width, height = self._get_variant_dimensions(photo, defaults)
                    size_label = self._get_variant_size_label(photo, defaults)
                    _, was_created = ProductVariant.objects.get_or_create(
                        photo=photo,
                        size=size_label,
                        material=material,
                        defaults={
                            'price': defaults['price'],
                            'width_inches': width,
                            'height_inches': height,
                        }
                    )
                    if was_created:
                        created += 1
        self.message_user(request, f'Created {created} paper variants.')

    @admin.action(description='Create aluminum print variants (orientation-aware)')
    def create_aluminum_variants(self, request, queryset):
        created = 0
        for photo in queryset:
            for (size, material), defaults in ProductVariant.DEFAULT_PRICING.items():
                if material == 'aluminum':
                    width, height = self._get_variant_dimensions(photo, defaults)
                    size_label = self._get_variant_size_label(photo, defaults)
                    _, was_created = ProductVariant.objects.get_or_create(
                        photo=photo,
                        size=size_label,
                        material=material,
                        defaults={
                            'price': defaults['price'],
                            'width_inches': width,
                            'height_inches': height,
                        }
                    )
                    if was_created:
                        created += 1
        self.message_user(request, f'Created {created} aluminum variants.')

    @admin.action(description='Create ALL standard variants (orientation-aware)')
    def create_all_variants(self, request, queryset):
        created = 0
        for photo in queryset:
            for (size, material), defaults in ProductVariant.DEFAULT_PRICING.items():
                width, height = self._get_variant_dimensions(photo, defaults)
                size_label = self._get_variant_size_label(photo, defaults)
                _, was_created = ProductVariant.objects.get_or_create(
                    photo=photo,
                    size=size_label,
                    material=material,
                    defaults={
                        'price': defaults['price'],
                        'width_inches': width,
                        'height_inches': height,
                    }
                )
                if was_created:
                    created += 1
        self.message_user(request, f'Created {created} variants for {queryset.count()} photos.')

    @admin.action(description='Remove ALL paper print variants')
    def remove_paper_variants(self, request, queryset):
        deleted = ProductVariant.objects.filter(photo__in=queryset, material='paper').delete()[0]
        self.message_user(request, f'Deleted {deleted} paper variants.')

    @admin.action(description='Remove ALL aluminum print variants')
    def remove_aluminum_variants(self, request, queryset):
        deleted = ProductVariant.objects.filter(photo__in=queryset, material='aluminum').delete()[0]
        self.message_user(request, f'Deleted {deleted} aluminum variants.')

    @admin.action(description='Remove ALL variants (paper + aluminum)')
    def remove_all_variants(self, request, queryset):
        deleted = ProductVariant.objects.filter(photo__in=queryset).delete()[0]
        self.message_user(request, f'Deleted {deleted} variants from {queryset.count()} photos.')

    @admin.action(description='Refresh image dimensions (re-save to update aspect ratio)')
    def refresh_image_dimensions(self, request, queryset):
        updated = 0
        for photo in queryset:
            photo.save()  # This triggers the dimension auto-population
            if photo.image_width and photo.image_height:
                updated += 1
        self.message_user(request, f'Refreshed dimensions for {updated} photos.')

    @admin.action(description='DELETE selected photos and their variants')
    def delete_photos_and_variants(self, request, queryset):
        count = queryset.count()
        queryset.delete()
        self.message_user(request, f'Deleted {count} photos and all their variants.')


@admin.register(ProductVariant)
class ProductVariantAdmin(admin.ModelAdmin):
    list_display = ['photo', 'size', 'material', 'price', 'is_available']
    list_filter = ['material', 'is_available', 'size']
    search_fields = ['photo__title', 'size']
    ordering = ['photo__title', 'material', 'price']


@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'product_type', 'price', 'stock_quantity', 'is_in_stock', 'is_featured', 'is_active', 'image_preview']
    list_filter = ['product_type', 'is_featured', 'is_active']
    search_fields = ['title', 'description', 'isbn']
    prepopulated_fields = {'slug': ('title',)}
    ordering = ['-created_at']
    readonly_fields = ['image_preview_large', 'created_at', 'updated_at']

    fieldsets = (
        (None, {
            'fields': ('title', 'slug', 'product_type', 'description', 'long_description')
        }),
        ('Images', {
            'fields': ('image', 'image_preview_large', 'additional_images')
        }),
        ('Pricing & Inventory', {
            'fields': ('price', 'compare_at_price', 'sku', 'stock_quantity', 'track_inventory', 'weight_oz')
        }),
        ('Book Details', {
            'fields': ('author', 'publisher', 'publication_year', 'pages', 'dimensions', 'isbn'),
            'classes': ('collapse',),
            'description': 'Fill these fields for book products'
        }),
        ('Status', {
            'fields': ('is_featured', 'is_active')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )

    def image_preview(self, obj):
        if obj.image:
            return format_html('<img src="{}" width="50" height="50" style="object-fit: cover;" />', obj.image.url)
        return '-'
    image_preview.short_description = 'Preview'

    def image_preview_large(self, obj):
        if obj.image:
            return format_html('<img src="{}" style="max-width: 400px; max-height: 300px;" />', obj.image.url)
        return '-'
    image_preview_large.short_description = 'Image Preview'

    def is_in_stock(self, obj):
        return obj.is_in_stock
    is_in_stock.boolean = True
    is_in_stock.short_description = 'In Stock'


================================================
FILE: backend/apps/catalog/management/commands/generate_photo_descriptions.py
================================================
"""
Management command to generate AI descriptions for photos using Claude Vision.

Usage:
    python manage.py generate_photo_descriptions
    python manage.py generate_photo_descriptions --photo-id=5
    python manage.py generate_photo_descriptions --overwrite
"""
import base64
import json
import requests
from io import BytesIO

from django.core.management.base import BaseCommand
from django.conf import settings

import anthropic
import boto3
from botocore.exceptions import ClientError

from apps.catalog.models import Photo


class Command(BaseCommand):
    help = 'Generate AI descriptions for photos using Claude Vision'

    def add_arguments(self, parser):
        parser.add_argument(
            '--photo-id',
            type=int,
            help='Process only a specific photo by ID',
        )
        parser.add_argument(
            '--overwrite',
            action='store_true',
            help='Overwrite existing AI descriptions',
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Print what would be done without making changes',
        )

    def handle(self, *args, **options):
        if not settings.ANTHROPIC_API_KEY:
            self.stderr.write(self.style.ERROR(
                'ANTHROPIC_API_KEY not set. Please add it to your environment.'
            ))
            return

        client = anthropic.Anthropic(api_key=settings.ANTHROPIC_API_KEY)

        # Get photos to process
        photos = Photo.objects.filter(is_active=True)

        if options['photo_id']:
            photos = photos.filter(id=options['photo_id'])

        if not options['overwrite']:
            # Only process photos without AI descriptions
            photos = photos.filter(ai_description='')

        total = photos.count()
        if total == 0:
            self.stdout.write(self.style.WARNING('No photos to process.'))
            return

        self.stdout.write(f'Processing {total} photos...\n')

        success_count = 0
        error_count = 0

        for i, photo in enumerate(photos, 1):
            self.stdout.write(f'[{i}/{total}] Processing: {photo.title}')

            try:
                # Get image data
                image_data = self._get_image_data(photo)
                if not image_data:
                    self.stderr.write(self.style.WARNING(f'  Could not load image for {photo.title}'))
                    error_count += 1
                    continue

                if options['dry_run']:
                    self.stdout.write(self.style.SUCCESS(f'  [DRY RUN] Would process {photo.title}'))
                    continue

                # Call Claude Vision
                result = self._analyze_image(client, image_data, photo)

                if result:
                    # Update photo
                    photo.ai_description = result.get('description', '')
                    photo.ai_colors = result.get('colors', [])
                    photo.ai_mood = result.get('mood', [])
                    photo.ai_subjects = result.get('subjects', [])
                    photo.ai_room_suggestions = result.get('room_suggestions', [])
                    photo.save()

                    self.stdout.write(self.style.SUCCESS(f'  Updated: {photo.title}'))
                    self.stdout.write(f'    Colors: {photo.ai_colors}')
                    self.stdout.write(f'    Mood: {photo.ai_mood}')
                    self.stdout.write(f'    Subjects: {photo.ai_subjects}')
                    success_count += 1
                else:
                    error_count += 1

            except Exception as e:
                self.stderr.write(self.style.ERROR(f'  Error: {str(e)}'))
                error_count += 1

        self.stdout.write('')
        self.stdout.write(self.style.SUCCESS(f'Completed: {success_count} successful, {error_count} errors'))

    def _get_image_data(self, photo) -> dict | None:
        """Load image via public URL and return base64 encoded data with media type."""
        try:
            if not photo.image:
                return None

            # Use the public URL that Django/storages generates (same as website uses)
            image_url = photo.image.url
            self.stdout.write(f'    Fetching: {image_url}')

            # Download image via HTTP
            response = requests.get(image_url, timeout=30)
            response.raise_for_status()

            # Determine media type from content type or file extension
            content_type = response.headers.get('content-type', '')
            if 'png' in content_type:
                media_type = 'image/png'
            elif 'webp' in content_type:
                media_type = 'image/webp'
            elif 'gif' in content_type:
                media_type = 'image/gif'
            else:
                media_type = 'image/jpeg'

            # Base64 encode
            image_base64 = base64.standard_b64encode(response.content).decode('utf-8')

            return {
                'type': 'base64',
                'media_type': media_type,
                'data': image_base64,
            }

        except requests.RequestException as e:
            self.stderr.write(f'    HTTP error: {e}')
            return None
        except Exception as e:
            self.stderr.write(f'    Error loading image: {e}')
            return None

    def _analyze_image(self, client: anthropic.Anthropic, image_data: dict, photo: Photo) -> dict | None:
        """Use Claude Vision to analyze the image and extract metadata."""

        prompt = """Analyze this fine art photograph and provide the following information in JSON format:

1. "description": A rich, evocative description of the photograph (2-3 sentences). Focus on what makes it visually striking, the mood it creates, and what a buyer might find appealing. Write from a fine art perspective.

2. "colors": An array of 3-5 dominant colors in the image. Use descriptive color names like "deep ocean blue", "golden sunset", "misty gray", "warm amber", "seafoam green".

3. "mood": An array of 3-5 mood/feeling keywords that describe the emotional tone. Examples: "serene", "dramatic", "peaceful", "energetic", "contemplative", "majestic", "intimate", "nostalgic".

4. "subjects": An array of 3-7 subjects/elements visible in the image. Examples: "lighthouse", "ocean waves", "beach", "sunset", "aerial view", "boats", "harbor", "dunes", "coastline".

5. "room_suggestions": An array of 2-4 room types where this print would look great. Examples: "living room", "bedroom", "office", "beach house", "coastal home", "modern apartment", "dining room".

Respond ONLY with valid JSON, no other text. Example format:
{
  "description": "A breathtaking aerial view of...",
  "colors": ["deep blue", "sandy beige", "white foam"],
  "mood": ["serene", "expansive", "calming"],
  "subjects": ["beach", "ocean", "aerial view", "coastline"],
  "room_suggestions": ["living room", "beach house", "office"]
}"""

        try:
            message = client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=1024,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "image",
                                "source": {
                                    "type": "base64",
                                    "media_type": image_data['media_type'],
                                    "data": image_data['data'],
                                },
                            },
                            {
                                "type": "text",
                                "text": prompt,
                            }
                        ],
                    }
                ],
            )

            # Parse JSON response
            response_text = message.content[0].text.strip()

            # Handle potential markdown code blocks
            if response_text.startswith('```'):
                response_text = response_text.split('```')[1]
                if response_text.startswith('json'):
                    response_text = response_text[4:]
                response_text = response_text.strip()

            result = json.loads(response_text)
            return result

        except json.JSONDecodeError as e:
            self.stderr.write(f'    JSON parse error: {e}')
            self.stderr.write(f'    Response: {response_text[:200]}...')
            return None
        except Exception as e:
            self.stderr.write(f'    API error: {e}')
            return None


================================================
FILE: backend/apps/catalog/management/commands/generate_photo_embeddings.py
================================================
"""
Management command to generate vector embeddings for photos.

Uses OpenAI's text-embedding-ada-002 model to create embeddings from
the AI-generated descriptions and metadata.

Usage:
    python manage.py generate_photo_embeddings
    python manage.py generate_photo_embeddings --photo-id=5
    python manage.py generate_photo_embeddings --overwrite
"""
from django.core.management.base import BaseCommand
from django.conf import settings

from openai import OpenAI

from apps.catalog.models import Photo


class Command(BaseCommand):
    help = 'Generate vector embeddings for photos using OpenAI'

    def add_arguments(self, parser):
        parser.add_argument(
            '--photo-id',
            type=int,
            help='Process only a specific photo by ID',
        )
        parser.add_argument(
            '--overwrite',
            action='store_true',
            help='Overwrite existing embeddings',
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Print what would be done without making changes',
        )

    def handle(self, *args, **options):
        if not settings.OPENAI_API_KEY:
            self.stderr.write(self.style.ERROR(
                'OPENAI_API_KEY not set. Please add it to your environment.'
            ))
            return

        client = OpenAI(api_key=settings.OPENAI_API_KEY)

        # Get photos to process
        photos = Photo.objects.filter(is_active=True)

        if options['photo_id']:
            photos = photos.filter(id=options['photo_id'])

        # Only process photos with AI descriptions
        photos = photos.exclude(ai_description='')

        if not options['overwrite']:
            # Only process photos without embeddings
            photos = photos.filter(embedding__isnull=True)

        total = photos.count()
        if total == 0:
            self.stdout.write(self.style.WARNING(
                'No photos to process. Make sure photos have AI descriptions first.\n'
                'Run: python manage.py generate_photo_descriptions'
            ))
            return

        self.stdout.write(f'Processing {total} photos...\n')

        success_count = 0
        error_count = 0

        for i, photo in enumerate(photos, 1):
            self.stdout.write(f'[{i}/{total}] Processing: {photo.title}')

            try:
                # Build text for embedding
                text = self._build_embedding_text(photo)

                if options['dry_run']:
                    self.stdout.write(self.style.SUCCESS(f'  [DRY RUN] Would embed: {text[:100]}...'))
                    continue

                # Generate embedding
                embedding = self._generate_embedding(client, text)

                if embedding:
                    photo.embedding = embedding
                    photo.save(update_fields=['embedding'])

                    self.stdout.write(self.style.SUCCESS(
                        f'  Generated embedding ({len(embedding)} dimensions)'
                    ))
                    success_count += 1
                else:
                    error_count += 1

            except Exception as e:
                self.stderr.write(self.style.ERROR(f'  Error: {str(e)}'))
                error_count += 1

        self.stdout.write('')
        self.stdout.write(self.style.SUCCESS(
            f'Completed: {success_count} successful, {error_count} errors'
        ))

    def _build_embedding_text(self, photo: Photo) -> str:
        """Build a combined text string for embedding from photo metadata."""
        parts = []

        # Title
        parts.append(f"Title: {photo.title}")

        # AI description
        if photo.ai_description:
            parts.append(f"Description: {photo.ai_description}")

        # Location
        if photo.location:
            parts.append(f"Location: {photo.location}")

        # Colors
        if photo.ai_colors:
            colors = ', '.join(photo.ai_colors)
            parts.append(f"Colors: {colors}")

        # Mood
        if photo.ai_mood:
            moods = ', '.join(photo.ai_mood)
            parts.append(f"Mood: {moods}")

        # Subjects
        if photo.ai_subjects:
            subjects = ', '.join(photo.ai_subjects)
            parts.append(f"Subjects: {subjects}")

        # Room suggestions
        if photo.ai_room_suggestions:
            rooms = ', '.join(photo.ai_room_suggestions)
            parts.append(f"Suggested rooms: {rooms}")

        # Collection
        if photo.collection:
            parts.append(f"Collection: {photo.collection.name}")

        return '\n'.join(parts)

    def _generate_embedding(self, client: OpenAI, text: str) -> list | None:
        """Generate embedding vector using OpenAI API."""
        try:
            response = client.embeddings.create(
                model="text-embedding-ada-002",
                input=text,
            )

            embedding = response.data[0].embedding
            return embedding

        except Exception as e:
            self.stderr.write(f'    OpenAI API error: {e}')
            return None


================================================
FILE: backend/apps/catalog/management/commands/find_orphan_files.py
================================================
"""
Management command to find and optionally delete orphaned S3 files.

Compares files in S3 against database records to find files that no longer
have a corresponding model instance.

Usage:
    python manage.py find_orphan_files              # List orphans (dry run)
    python manage.py find_orphan_files --delete     # Delete orphans
"""
import boto3
from django.conf import settings
from django.core.management.base import BaseCommand

from apps.catalog.models import Collection, Photo, Product


class Command(BaseCommand):
    help = 'Find and optionally delete orphaned files in S3'

    def add_arguments(self, parser):
        parser.add_argument(
            '--delete',
            action='store_true',
            help='Actually delete orphaned files (default is dry run)',
        )

    def handle(self, *args, **options):
        delete = options['delete']

        if delete:
            self.stdout.write(self.style.WARNING('DELETE MODE - Files will be removed!'))
        else:
            self.stdout.write(self.style.NOTICE('DRY RUN - No files will be deleted'))

        self.stdout.write('')

        # Initialize S3 client
        s3 = boto3.client(
            's3',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME,
        )
        bucket = settings.AWS_STORAGE_BUCKET_NAME

        total_orphans = 0
        total_size = 0

        # Check collections
        orphans, size = self.check_prefix(
            s3, bucket, 'media/collections/',
            self.get_collection_files(),
            delete
        )
        total_orphans += orphans
        total_size += size

        # Check photos
        orphans, size = self.check_prefix(
            s3, bucket, 'media/photos/',
            self.get_photo_files(),
            delete,
            exclude_prefix='media/photos/thumbnails/'
        )
        total_orphans += orphans
        total_size += size

        # Check thumbnails
        orphans, size = self.check_prefix(
            s3, bucket, 'media/photos/thumbnails/',
            self.get_thumbnail_files(),
            delete
        )
        total_orphans += orphans
        total_size += size

        # Check products
        orphans, size = self.check_prefix(
            s3, bucket, 'media/products/',
            self.get_product_files(),
            delete
        )
        total_orphans += orphans
        total_size += size

        # Summary
        self.stdout.write('')
        self.stdout.write('=' * 50)
        size_mb = total_size / (1024 * 1024)
        if delete:
            self.stdout.write(self.style.SUCCESS(
                f'Deleted {total_orphans} orphaned files ({size_mb:.2f} MB)'
            ))
        else:
            self.stdout.write(self.style.WARNING(
                f'Found {total_orphans} orphaned files ({size_mb:.2f} MB)'
            ))
            if total_orphans > 0:
                self.stdout.write(self.style.NOTICE(
                    'Run with --delete to remove them'
                ))

    def get_collection_files(self):
        """Get set of collection image paths from database."""
        files = set()
        for c in Collection.objects.all():
            if c.cover_image:
                files.add(f'media/{c.cover_image.name}')
        return files

    def get_photo_files(self):
        """Get set of photo image paths from database."""
        files = set()
        for p in Photo.objects.all():
            if p.image:
                files.add(f'media/{p.image.name}')
        return files

    def get_thumbnail_files(self):
        """Get set of thumbnail paths from database."""
        files = set()
        for p in Photo.objects.all():
            if p.thumbnail:
                files.add(f'media/{p.thumbnail.name}')
        return files

    def get_product_files(self):
        """Get set of product image paths from database."""
        files = set()
        for p in Product.objects.all():
            if p.image:
                files.add(f'media/{p.image.name}')
        return files

    def check_prefix(self, s3, bucket, prefix, db_files, delete, exclude_prefix=None):
        """Check S3 prefix for orphaned files."""
        self.stdout.write(f'\nChecking {prefix}...')

        # List all files in S3 with this prefix
        s3_files = {}
        paginator = s3.get_paginator('list_objects_v2')

        for page in paginator.paginate(Bucket=bucket, Prefix=prefix):
            for obj in page.get('Contents', []):
                key = obj['Key']
                # Skip if this key starts with exclude_prefix
                if exclude_prefix and key.startswith(exclude_prefix):
                    continue
                s3_files[key] = obj['Size']

        # Find orphans
        orphan_count = 0
        orphan_size = 0

        for s3_key, size in s3_files.items():
            if s3_key not in db_files:
                orphan_count += 1
                orphan_size += size
                size_kb = size / 1024

                if delete:
                    s3.delete_object(Bucket=bucket, Key=s3_key)
                    self.stdout.write(self.style.ERROR(
                        f'  DELETED: {s3_key} ({size_kb:.1f} KB)'
                    ))
                else:
                    self.stdout.write(self.style.WARNING(
                        f'  ORPHAN: {s3_key} ({size_kb:.1f} KB)'
                    ))

        if orphan_count == 0:
            self.stdout.write(self.style.SUCCESS(f'  No orphans found'))
        else:
            self.stdout.write(f'  Found {orphan_count} orphans in {prefix}')

        return orphan_count, orphan_size


================================================
FILE: backend/apps/orders/models.py
================================================
import uuid

from django.db import models

from apps.catalog.models import ProductVariant, Product


class Cart(models.Model):
    """Session-based shopping cart."""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session_key = models.CharField(max_length=40, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Cart {self.id}"

    @property
    def total_items(self):
        return sum(item.quantity for item in self.items.all())

    @property
    def subtotal(self):
        return sum(item.total_price for item in self.items.all())


class CartItem(models.Model):
    """An item in a shopping cart - can be a photo variant or a product."""
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items')
    variant = models.ForeignKey(ProductVariant, on_delete=models.CASCADE, null=True, blank=True)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, null=True, blank=True)
    quantity = models.PositiveIntegerField(default=1)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        constraints = [
            models.CheckConstraint(
                condition=(
                    models.Q(variant__isnull=False, product__isnull=True) |
                    models.Q(variant__isnull=True, product__isnull=False)
                ),
                name='cart_item_has_variant_or_product'
            )
        ]

    def __str__(self):
        if self.variant:
            return f"{self.quantity}x {self.variant}"
        return f"{self.quantity}x {self.product}"

    @property
    def item_type(self):
        return 'variant' if self.variant else 'product'

    @property
    def unit_price(self):
        if self.variant:
            return self.variant.price
        return self.product.price

    @property
    def total_price(self):
        return self.unit_price * self.quantity

    @property
    def title(self):
        if self.variant:
            return self.variant.photo.title
        return self.product.title

    @property
    def description(self):
        if self.variant:
            return self.variant.display_name
        return self.product.get_product_type_display()

    @property
    def image(self):
        if self.variant:
            return self.variant.photo.thumbnail or self.variant.photo.image
        return self.product.image


class Order(models.Model):
    """A completed order."""

    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('paid', 'Paid'),
        ('processing', 'Processing'),
        ('shipped', 'Shipped'),
        ('delivered', 'Delivered'),
        ('cancelled', 'Cancelled'),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    order_number = models.CharField(max_length=20, unique=True, editable=False)
    stripe_checkout_id = models.CharField(max_length=200, blank=True, unique=True)
    stripe_payment_intent = models.CharField(max_length=200, blank=True, db_index=True)
    customer_email = models.EmailField(db_index=True)
    customer_name = models.CharField(max_length=200)
    shipping_address = models.JSONField(default=dict)
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending',
        db_index=True,
    )
    subtotal = models.DecimalField(max_digits=10, decimal_places=2)
    shipping_cost = models.DecimalField(max_digits=8, decimal_places=2, default=0)
    tax = models.DecimalField(max_digits=8, decimal_places=2, default=0)
    total = models.DecimalField(max_digits=10, decimal_places=2)
    tracking_number = models.CharField(max_length=100, blank=True)
    tracking_carrier = models.CharField(max_length=50, blank=True)
    notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"Order {self.order_number}"

    def save(self, *args, **kwargs):
        if not self.order_number:
            from django.db import IntegrityError
            # Retry up to 5 times if concurrent orders produce a collision
            for attempt in range(5):
                self.order_number = self._generate_order_number()
                try:
                    super().save(*args, **kwargs)
                    return
                except IntegrityError:
                    if attempt == 4:
                        raise
                    self.order_number = ''  # Reset to regenerate
                    continue
        super().save(*args, **kwargs)

    def _generate_order_number(self):
        """Generate a unique order number like MR-240104-001."""
        from django.utils import timezone
        date_str = timezone.now().strftime('%y%m%d')
        prefix = f'MR-{date_str}'
        last_order = Order.objects.filter(
            order_number__startswith=prefix
        ).order_by('-order_number').first()
        if last_order:
            last_num = int(last_order.order_number.split('-')[-1])
            new_num = last_num + 1
        else:
            new_num = 1
        return f'{prefix}-{new_num:03d}'


class OrderItem(models.Model):
    """An item in an order - can be a photo variant or a product."""
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')
    variant = models.ForeignKey(ProductVariant, on_delete=models.PROTECT, null=True, blank=True)
    product = models.ForeignKey(Product, on_delete=models.PROTECT, null=True, blank=True)
    item_title = models.CharField(max_length=200, default='')
    item_description = models.CharField(max_length=200, default='')
    quantity = models.PositiveIntegerField(default=1)
    unit_price = models.DecimalField(max_digits=8, decimal_places=2)
    total_price = models.DecimalField(max_digits=10, decimal_places=2)
    aluminyze_order_id = models.CharField(
        max_length=100,
        blank=True,
        help_text='Aluminyze order ID for fulfillment tracking'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.quantity}x {self.item_title} ({self.item_description})"

    @property
    def item_type(self):
        return 'variant' if self.variant else 'product'

    def save(self, *args, **kwargs):
        if self.item_title is None or self.item_title == '':
            if self.variant:
                self.item_title = self.variant.photo.title
            elif self.product:
                self.item_title = self.product.title
        if self.item_description is None or self.item_description == '':
            if self.variant:
                self.item_description = self.variant.display_name
            elif self.product:
                self.item_description = self.product.get_product_type_display()
        if self.total_price is None:
            self.total_price = self.unit_price * self.quantity
        super().save(*args, **kwargs)


================================================
FILE: backend/apps/orders/views.py
================================================
from rest_framework import status
from rest_framework.response import Response
from rest_framework.throttling import AnonRateThrottle
from rest_framework.views import APIView

from apps.catalog.models import ProductVariant, Product
from .models import Cart, CartItem, Order
from .serializers import (
    CartSerializer,
    CartItemSerializer,
    AddToCartSerializer,
    UpdateCartItemSerializer,
)


def get_or_create_cart(request):
    """Get or create a cart for the current session."""
    if not request.session.session_key:
        request.session.create()

    session_key = request.session.session_key
    cart, created = Cart.objects.get_or_create(session_key=session_key)
    # Prefetch related objects to avoid N+1 queries during serialization
    return Cart.objects.prefetch_related(
        'items__variant__photo',
        'items__product',
    ).get(pk=cart.pk)


class CartView(APIView):
    """View and manage shopping cart."""
    authentication_classes = []
    permission_classes = []

    def get(self, request):
        """Get current cart contents."""
        cart = get_or_create_cart(request)
        serializer = CartSerializer(cart, context={'request': request})
        return Response(serializer.data)

    def delete(self, request):
        """Clear entire cart."""
        cart = get_or_create_cart(request)
        cart.items.all().delete()
        serializer = CartSerializer(cart, context={'request': request})
        return Response(serializer.data)


class CartItemView(APIView):
    """Add items to cart."""
    authentication_classes = []
    permission_classes = []

    def post(self, request):
        """Add item to cart - supports both variants and products."""
        serializer = AddToCartSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        cart = get_or_create_cart(request)
        variant_id = serializer.validated_data.get('variant_id')
        product_id = serializer.validated_data.get('product_id')
        quantity = serializer.validated_data['quantity']

        if variant_id:
            variant = ProductVariant.objects.get(id=variant_id)
            cart_item, created = CartItem.objects.get_or_create(
                cart=cart,
                variant=variant,
                product=None,
                defaults={'quantity': quantity}
            )
        else:
            product = Product.objects.get(id=product_id)
            cart_item, created = CartItem.objects.get_or_create(
                cart=cart,
                product=product,
                variant=None,
                defaults={'quantity': quantity}
            )

        if not created:
            cart_item.quantity += quantity
            cart_item.save()

        # Re-fetch with fresh prefetch cache after modification
        cart = get_or_create_cart(request)
        return Response(
            CartSerializer(cart, context={'request': request}).data,
            status=status.HTTP_201_CREATED if created else status.HTTP_200_OK
        )


class CartItemDetailView(APIView):
    """Update or delete a cart item."""
    authentication_classes = []
    permission_classes = []

    def get_cart_item(self, request, item_id):
        """Get cart item ensuring it belongs to current cart."""
        cart = get_or_create_cart(request)
        try:
            return CartItem.objects.get(id=item_id, cart=cart)
        except CartItem.DoesNotExist:
            return None

    def put(self, request, item_id):
        """Update cart item quantity."""
        cart_item = self.get_cart_item(request, item_id)
        if not cart_item:
            return Response(
                {'error': 'Cart item not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        serializer = UpdateCartItemSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        cart_item.quantity = serializer.validated_data['quantity']
        cart_item.save()

        # Re-fetch with prefetch for serialization
        cart = get_or_create_cart(request)
        return Response(CartSerializer(cart, context={'request': request}).data)

    def delete(self, request, item_id):
        """Remove item from cart."""
        cart_item = self.get_cart_item(request, item_id)
        if not cart_item:
            return Response(
                {'error': 'Cart item not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        cart_item.delete()

        # Re-fetch with prefetch for serialization
        cart = get_or_create_cart(request)
        return Response(CartSerializer(cart, context={'request': request}).data)


class OrderTrackingThrottle(AnonRateThrottle):
    scope = 'order_tracking'


class OrderTrackingView(APIView):
    """Look up order by order number and email for customers."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [OrderTrackingThrottle]

    def post(self, request):
        """Look up order status."""
        order_number = request.data.get('order_number', '').strip().upper()
        email = request.data.get('email', '').strip().lower()

        if not order_number or not email:
            return Response(
                {'error': 'Order number and email are required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            order = Order.objects.get(
                order_number=order_number,
                customer_email__iexact=email
            )
            return Response({
                'order_number': order.order_number,
                'status': order.status,
                'status_display': order.get_status_display(),
                'tracking_number': order.tracking_number or None,
                'tracking_carrier': order.tracking_carrier or None,
                'total': str(order.total),
                'created_at': order.created_at.isoformat(),
                'items': [
                    {
                        'title': item.item_title,
                        'description': item.item_description,
                        'quantity': item.quantity,
                    }
                    for item in order.items.all()
                ]
            })
        except Order.DoesNotExist:
            return Response(
                {'error': 'Order not found. Please check your order number and email.'},
                status=status.HTTP_404_NOT_FOUND
            )


================================================
FILE: backend/apps/orders/serializers.py
================================================
from django.conf import settings
from rest_framework import serializers

from apps.catalog.models import ProductVariant, Product
from apps.catalog.serializers import ProductVariantSerializer, ProductListSerializer
from .models import Cart, CartItem, Order, OrderItem


def build_absolute_image_url(url):
    """Build absolute URL for an image using BACKEND_URL setting."""
    if not url:
        return None
    if url.startswith('http'):
        return url
    backend_url = getattr(settings, 'BACKEND_URL', None)
    if backend_url:
        return f"{backend_url}/{url.lstrip('/')}"
    return url


class CartItemSerializer(serializers.ModelSerializer):
    """Serializer for cart items - handles both variants and products."""
    variant = ProductVariantSerializer(read_only=True)
    product = ProductListSerializer(read_only=True)
    item_type = serializers.CharField(read_only=True)
    title = serializers.CharField(read_only=True)
    description = serializers.CharField(read_only=True)
    unit_price = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
    total_price = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)
    image = serializers.SerializerMethodField()
    slug = serializers.SerializerMethodField()

    class Meta:
        model = CartItem
        fields = [
            'id', 'item_type', 'variant', 'product', 'quantity',
            'title', 'description', 'slug', 'image', 'unit_price', 'total_price'
        ]

    def get_image(self, obj):
        if obj.variant and obj.variant.photo.thumbnail:
            return build_absolute_image_url(obj.variant.photo.thumbnail.url)
        elif obj.variant and obj.variant.photo.image:
            return build_absolute_image_url(obj.variant.photo.image.url)
        elif obj.product and obj.product.image:
            return build_absolute_image_url(obj.product.image.url)
        return None

    def get_slug(self, obj):
        if obj.variant:
            return obj.variant.photo.slug
        elif obj.product:
            return obj.product.slug
        return None


class CartSerializer(serializers.ModelSerializer):
    """Serializer for shopping cart."""
    items = CartItemSerializer(many=True, read_only=True)
    total_items = serializers.IntegerField(read_only=True)
    subtotal = serializers.DecimalField(max_digits=10, decimal_places=2, read_only=True)

    class Meta:
        model = Cart
        fields = ['id', 'items', 'total_items', 'subtotal', 'created_at', 'updated_at']
        read_only_fields = ['id', 'created_at', 'updated_at']


class AddToCartSerializer(serializers.Serializer):
    """Serializer for adding items to cart - handles both variants and products."""
    variant_id = serializers.IntegerField(required=False)
    product_id = serializers.IntegerField(required=False)
    quantity = serializers.IntegerField(min_value=1, default=1)

    def validate(self, data):
        variant_id = data.get('variant_id')
        product_id = data.get('product_id')

        if not variant_id and not product_id:
            raise serializers.ValidationError("Either variant_id or product_id is required.")
        if variant_id and product_id:
            raise serializers.ValidationError("Provide either variant_id or product_id, not both.")

        if variant_id:
            try:
                ProductVariant.objects.get(id=variant_id, is_available=True)
            except ProductVariant.DoesNotExist:
                raise serializers.ValidationError({"variant_id": "Product variant not found or unavailable."})

        if product_id:
            try:
                product = Product.objects.get(id=product_id, is_active=True)
                if product.track_inventory and product.stock_quantity < data.get('quantity', 1):
                    raise serializers.ValidationError({"product_id": "Not enough stock available."})
            except Product.DoesNotExist:
                raise serializers.ValidationError({"product_id": "Product not found or unavailable."})

        return data


class UpdateCartItemSerializer(serializers.Serializer):
    """Serializer for updating cart item quantity."""
    quantity = serializers.IntegerField(min_value=1)


class OrderItemSerializer(serializers.ModelSerializer):
    """Serializer for order items."""
    item_type = serializers.CharField(read_only=True)

    class Meta:
        model = OrderItem
        fields = [
            'id', 'item_type', 'item_title', 'item_description',
            'quantity', 'unit_price', 'total_price'
        ]


class OrderSerializer(serializers.ModelSerializer):
    """Serializer for orders."""
    items = OrderItemSerializer(many=True, read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)

    class Meta:
        model = Order
        fields = [
            'id', 'order_number', 'customer_email', 'customer_name',
            'shipping_address', 'status', 'status_display',
            'subtotal', 'shipping_cost', 'tax', 'total',
            'items', 'created_at'
        ]
        read_only_fields = ['id', 'order_number', 'created_at']


================================================
FILE: backend/apps/orders/urls.py
================================================
from django.urls import path

from . import views

app_name = 'orders'

urlpatterns = [
    path('cart/', views.CartView.as_view(), name='cart'),
    path('cart/items/', views.CartItemView.as_view(), name='cart-items'),
    path('cart/items/<int:item_id>/', views.CartItemDetailView.as_view(), name='cart-item-detail'),
    path('orders/track/', views.OrderTrackingView.as_view(), name='order-tracking'),
]


================================================
FILE: backend/apps/orders/admin.py
================================================
from django.contrib import admin, messages
from django.utils.html import format_html

from .models import Cart, CartItem, Order, OrderItem
from .emails import send_shipping_notification


class CartItemInline(admin.TabularInline):
    model = CartItem
    extra = 0
    readonly_fields = ['variant', 'product', 'quantity', 'total_price']

    def has_add_permission(self, request, obj=None):
        return False


@admin.register(Cart)
class CartAdmin(admin.ModelAdmin):
    list_display = ['id', 'session_key', 'total_items', 'subtotal', 'created_at', 'updated_at']
    readonly_fields = ['id', 'session_key', 'created_at', 'updated_at']
    search_fields = ['session_key']
    ordering = ['-updated_at']
    inlines = [CartItemInline]


class OrderItemInline(admin.TabularInline):
    model = OrderItem
    extra = 0
    readonly_fields = ['item_title', 'item_description', 'quantity', 'unit_price', 'total_price', 'aluminyze_order_id']

    def has_add_permission(self, request, obj=None):
        return False


@admin.register(Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['order_number', 'customer_name', 'customer_email', 'status_badge', 'total', 'created_at']
    list_filter = ['status', 'created_at']
    search_fields = ['order_number', 'customer_name', 'customer_email']
    readonly_fields = [
        'id', 'order_number', 'stripe_checkout_id', 'stripe_payment_intent',
        'created_at', 'updated_at', 'shipping_address_display'
    ]
    ordering = ['-created_at']
    inlines = [OrderItemInline]
    date_hierarchy = 'created_at'

    fieldsets = (
        ('Order Info', {
            'fields': ('id', 'order_number', 'status')
        }),
        ('Customer', {
            'fields': ('customer_name', 'customer_email', 'shipping_address_display')
        }),
        ('Payment', {
            'fields': ('stripe_checkout_id', 'stripe_payment_intent')
        }),
        ('Totals', {
            'fields': ('subtotal', 'shipping_cost', 'tax', 'total')
        }),
        ('Shipping & Tracking', {
            'fields': ('tracking_number', 'tracking_carrier'),
        }),
        ('Notes', {
            'fields': ('notes',),
            'classes': ('collapse',)
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )

    def status_badge(self, obj):
        colors = {
            'pending': 'orange',
            'paid': 'green',
            'processing': 'blue',
            'shipped': 'purple',
            'delivered': 'darkgreen',
            'cancelled': 'red',
        }
        color = colors.get(obj.status, 'gray')
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; border-radius: 3px;">{}</span>',
            color, obj.get_status_display()
        )
    status_badge.short_description = 'Status'

    def shipping_address_display(self, obj):
        addr = obj.shipping_address
        if not addr:
            return '-'
        lines = [
            addr.get('line1', ''),
            addr.get('line2', ''),
            f"{addr.get('city', '')}, {addr.get('state', '')} {addr.get('postal_code', '')}",
            addr.get('country', ''),
        ]
        return format_html('<br>'.join(line for line in lines if line.strip()))
    shipping_address_display.short_description = 'Shipping Address'

    actions = ['mark_processing', 'mark_shipped_and_notify', 'mark_delivered']

    @admin.action(description='Mark as processing')
    def mark_processing(self, request, queryset):
        updated = queryset.filter(status='paid').update(status='processing')
        self.message_user(request, f'{updated} order(s) marked as processing.')

    @admin.action(description='Mark as shipped & send notification')
    def mark_shipped_and_notify(self, request, queryset):
        orders = queryset.filter(status__in=['paid', 'processing'])
        count = 0
        for order in orders:
            order.status = 'shipped'
            order.save()
            try:
                send_shipping_notification(
                    order,
                    tracking_number=order.tracking_number or None,
                    carrier=order.tracking_carrier or None
                )
                count += 1
            except Exception:
                messages.warning(request, f'Failed to send email for order {order.order_number}')
        self.message_user(request, f'{count} order(s) marked as shipped and notified.')

    @admin.action(description='Mark as delivered')
    def mark_delivered(self, request, queryset):
        updated = queryset.filter(status='shipped').update(status='delivered')
        self.message_user(request, f'{updated} order(s) marked as delivered.')


================================================
FILE: backend/apps/orders/tasks.py
================================================
import logging
from datetime import timedelta

from celery import shared_task
from django.utils import timezone

logger = logging.getLogger(__name__)


@shared_task
def cleanup_stale_carts(days: int = 30):
    """
    Delete carts older than specified days that have no associated order.

    Args:
        days: Delete carts older than this many days (default 30)

    Returns:
        Number of carts deleted
    """
    from .models import Cart

    cutoff = timezone.now() - timedelta(days=days)
    stale_carts = Cart.objects.filter(
        created_at__lt=cutoff,
        updated_at__lt=cutoff,
    )

    count = stale_carts.count()
    if count > 0:
        stale_carts.delete()
        logger.info(f'Cleaned up {count} stale carts older than {days} days')

    return count


================================================
FILE: backend/apps/orders/emails.py
================================================
import resend
from django.conf import settings
from django.template.loader import render_to_string

# Initialize Resend with API key
resend.api_key = settings.RESEND_API_KEY


def send_order_confirmation(order):
    """Send order confirmation email to customer."""
    subject = f"Order Confirmed - {order.order_number}"

    # Build items with image URLs
    items_with_images = []
    for item in order.items.select_related('variant__photo', 'product'):
        item_data = {
            'item_title': item.item_title,
            'item_description': item.item_description,
            'quantity': item.quantity,
            'total_price': item.total_price,
            'image_url': None,
        }
        if item.variant and item.variant.photo and item.variant.photo.image:
            item_data['image_url'] = item.variant.photo.image.url
        elif item.product and item.product.image:
            item_data['image_url'] = item.product.image.url
        items_with_images.append(item_data)

    context = {
        'order': order,
        'items': items_with_images,
        'store_name': 'Matthew Raynor Photography',
        'support_email': 'hello@matthewraynor.com',
    }

    html_message = render_to_string('emails/order_confirmation.html', context)
    plain_message = render_to_string('emails/order_confirmation.txt', context)

    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [order.customer_email],
        "subject": subject,
        "html": html_message,
        "text": plain_message,
    })

    # Send admin notification
    send_new_order_admin_notification(order, items_with_images)


def send_new_order_admin_notification(order, items):
    """Send notification to admin when new order is placed."""
    subject = f"New Order: {order.order_number} - ${order.total}"

    # Build simple text email for admin
    items_text = "\n".join([
        f"  - {item['item_title']} ({item['item_description']}) x{item['quantity']} = ${item['total_price']}"
        for item in items
    ])

    addr = order.shipping_address
    address_text = f"{addr.get('line1', '')}"
    if addr.get('line2'):
        address_text += f"\n  {addr.get('line2')}"
    address_text += f"\n  {addr.get('city', '')}, {addr.get('state', '')} {addr.get('postal_code', '')}"

    text_body = f"""New order received!

Order: {order.order_number}
Total: ${order.total}

Customer: {order.customer_name}
Email: {order.customer_email}

Items:
{items_text}

Ship to:
  {order.customer_name}
  {address_text}

View in admin: https://store-production-385d.up.railway.app/admin/orders/order/{order.id}/change/
"""

    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [settings.ADMIN_EMAIL],
        "subject": subject,
        "text": text_body,
    })


def send_shipping_notification(order, tracking_number=None, carrier=None):
    """Send shipping notification email to customer."""
    subject = f"Your Order Has Shipped - {order.order_number}"

    # Build items with image URLs
    items_with_images = []
    for item in order.items.select_related('variant__photo', 'product'):
        item_data = {
            'item_title': item.item_title,
            'item_description': item.item_description,
            'quantity': item.quantity,
            'total_price': item.total_price,
            'image_url': None,
        }
        if item.variant and item.variant.photo and item.variant.photo.image:
            item_data['image_url'] = item.variant.photo.image.url
        elif item.product and item.product.image:
            item_data['image_url'] = item.product.image.url
        items_with_images.append(item_data)

    context = {
        'order': order,
        'items': items_with_images,
        'tracking_number': tracking_number,
        'carrier': carrier,
        'store_name': 'Matthew Raynor Photography',
        'support_email': 'hello@matthewraynor.com',
    }

    html_message = render_to_string('emails/shipping_notification.html', context)
    plain_message = render_to_string('emails/shipping_notification.txt', context)

    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [order.customer_email],
        "subject": subject,
        "html": html_message,
        "text": plain_message,
    })


def send_contact_form_notification(name, email, subject, message):
    """Send contact form submission to admin."""
    admin_subject = f"Contact Form: {subject}"

    context = {
        'name': name,
        'email': email,
        'subject': subject,
        'message': message,
    }

    html_message = render_to_string('emails/contact_form.html', context)
    plain_message = render_to_string('emails/contact_form.txt', context)

    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [settings.ADMIN_EMAIL],
        "subject": admin_subject,
        "html": html_message,
        "text": plain_message,
    })

    # Auto-reply to sender
    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [email],
        "subject": "Thank you for contacting Matthew Raynor Photography",
        "text": f"Hi {name},\n\nThank you for reaching out. I've received your message and will get back to you within 24-48 hours.\n\nBest,\nMatt",
    })


================================================
FILE: backend/apps/payments/views.py
================================================
import json
import logging
import stripe
from decimal import Decimal

from django.conf import settings
from django.db import IntegrityError, transaction
from django.db.models import F
from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from rest_framework import status
from rest_framework.response import Response
from rest_framework.throttling import AnonRateThrottle
from rest_framework.views import APIView

from apps.catalog.models import ProductVariant, Product
from apps.orders.models import Cart, Order, OrderItem
from apps.orders.views import get_or_create_cart
from apps.orders.emails import send_order_confirmation
from apps.core.models import GiftCard, GiftCardRedemption, Subscriber
from apps.core.emails import send_gift_card_email, send_gift_card_purchase_confirmation

logger = logging.getLogger(__name__)

stripe.api_key = settings.STRIPE_SECRET_KEY


class CheckoutThrottle(AnonRateThrottle):
    scope = 'checkout'


class OrderLookupThrottle(AnonRateThrottle):
    scope = 'order_lookup'


class CreateCheckoutSessionView(APIView):
    """Create a Stripe Checkout session for the current cart."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [CheckoutThrottle]

    def post(self, request):
        cart = get_or_create_cart(request)

        if not cart.items.exists():
            return Response(
                {'error': 'Cart is empty'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Check for gift card code
        gift_card_code = request.data.get('gift_card_code', '').strip().upper()
        gift_card = None
        gift_card_amount = 0

        if gift_card_code:
            try:
                with transaction.atomic():
                    # Lock the gift card row to prevent concurrent checkouts
                    # from both reading the full balance (double-spend)
                    gift_card = GiftCard.objects.select_for_update().get(
                        code=gift_card_code
                    )
                    if not gift_card.is_valid:
                        return Response(
                            {'error': 'Gift card is no longer valid'},
                            status=status.HTTP_400_BAD_REQUEST
                        )
                    # Reserve the amount by deducting now; refunded if
                    # checkout expires without completing payment
                    cart_total = cart.subtotal
                    gift_card_amount = min(gift_card.remaining_balance, cart_total)
                    if gift_card_amount > 0:
                        gift_card.remaining_balance -= gift_card_amount
                        if gift_card.remaining_balance == 0:
                            gift_card.is_active = False
                        gift_card.save(update_fields=['remaining_balance', 'is_active'])
            except GiftCard.DoesNotExist:
                return Response(
                    {'error': 'Gift card not found'},
                    status=status.HTTP_400_BAD_REQUEST
                )

        line_items = []
        cart_snapshot = []
        for item in cart.items.select_related('variant__photo', 'product'):
            if item.variant:
                line_items.append({
                    'price_data': {
                        'currency': 'usd',
                        'unit_amount': int(item.variant.price * 100),
                        'product_data': {
                            'name': item.variant.photo.title,
                            'description': item.variant.display_name,
                            'images': [
                                request.build_absolute_uri(item.variant.photo.image.url)
                            ] if item.variant.photo.image else [],
                        },
                    },
                    'quantity': item.quantity,
                })
                cart_snapshot.append({
                    't': 'v', 'id': item.variant.id,
                    'q': item.quantity, 'p': str(item.variant.price),
                })
            elif item.product:
                line_items.append({
                    'price_data': {
                        'currency': 'usd',
                        'unit_amount': int(item.product.price * 100),
                        'product_data': {
                            'name': item.product.title,
                            'description': item.product.get_product_type_display(),
                            'images': [
                                request.build_absolute_uri(item.product.image.url)
                            ] if item.product.image else [],
                        },
                    },
                    'quantity': item.quantity,
                })
                cart_snapshot.append({
                    't': 'p', 'id': item.product.id,
                    'q': item.quantity, 'p': str(item.product.price),
                })

        try:
            # Build checkout session params
            checkout_params = {
                'payment_method_types': ['card'],
                'line_items': line_items,
                'mode': 'payment',
                'success_url': f"{settings.FRONTEND_URL}/order/success?session_id={{CHECKOUT_SESSION_ID}}",
                'cancel_url': f"{settings.FRONTEND_URL}/cart",
                'shipping_address_collection': {
                    'allowed_countries': ['US'],
                },
                'billing_address_collection': 'required',
                'metadata': {
                    'cart_id': str(cart.id),
                    'cart_snapshot': json.dumps(cart_snapshot),
                },
            }

            # Apply gift card as a Stripe coupon/discount
            if gift_card and gift_card_amount > 0:
                # Create a one-time coupon for the gift card amount
                coupon = stripe.Coupon.create(
                    amount_off=int(gift_card_amount * 100),
                    currency='usd',
                    duration='once',
                    name=f'Gift Card {gift_card.code}',
                )
                checkout_params['discounts'] = [{'coupon': coupon.id}]
                checkout_params['metadata']['gift_card_code'] = gift_card.code
                checkout_params['metadata']['gift_card_amount'] = str(gift_card_amount)
            else:
                # Only allow promo codes when no gift card is applied
                # (Stripe doesn't allow both discounts and allow_promotion_codes)
                checkout_params['allow_promotion_codes'] = True

            checkout_session = stripe.checkout.Session.create(**checkout_params)

            return Response({
                'checkout_url': checkout_session.url,
                'session_id': checkout_session.id,
            })

        except stripe.error.StripeError as e:
            logger.error(f"Stripe error during checkout: {e}")
            return Response(
                {'error': 'Payment processing error. Please try again.'},
                status=status.HTTP_400_BAD_REQUEST
            )


@method_decorator(csrf_exempt, name='dispatch')
class StripeWebhookView(APIView):
    """Handle Stripe webhook events."""
    authentication_classes = []
    permission_classes = []

    def post(self, request):
        payload = request.body
        sig_header = request.META.get('HTTP_STRIPE_SIGNATURE')

        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, settings.STRIPE_WEBHOOK_SECRET
            )
        except ValueError:
            logger.warning("Webhook received invalid payload")
            return HttpResponse(status=400)
        except stripe.error.SignatureVerificationError:
            logger.warning(
                f"Webhook signature verification failed from "
                f"{request.META.get('REMOTE_ADDR')}"
            )
            return HttpResponse(status=400)

        if event['type'] == 'checkout.session.completed':
            session = event['data']['object']
            metadata = session.get('metadata', {})

            # Check if this is a gift card purchase
            if metadata.get('type') == 'gift_card':
                self.handle_gift_card_purchase(session)
            else:
                self.handle_checkout_completed(session)

        elif event['type'] == 'checkout.session.expired':
            session = event['data']['object']
            self.handle_checkout_expired(session)

        return HttpResponse(status=200)

    def handle_checkout_completed(self, session):
        """Create order from completed checkout session."""
        metadata = session.get('metadata', {})
        cart_id = metadata.get('cart_id')
        if not cart_id:
            return

        try:
            cart = Cart.objects.get(id=cart_id)
        except Cart.DoesNotExist:
            return

        shipping = session.get('shipping_details', {})
        address = shipping.get('address', {})

        # Wrap order creation, items, gift card redemption, and cart
        # cleanup in a single transaction for data consistency.
        # Idempotency check is inside the transaction so concurrent
        # webhook retries can't both pass the check. The unique
        # constraint on stripe_checkout_id is a secondary guard.
        try:
            with transaction.atomic():
                # Idempotency: skip if we already processed this session
                if Order.objects.filter(stripe_checkout_id=session['id']).exists():
                    logger.info(f"Order already exists for session {session['id']}, skipping")
                    return

                order = Order.objects.create(
                    stripe_checkout_id=session['id'],
                    stripe_payment_intent=session.get('payment_intent') or '',
                    customer_email=session.get('customer_details', {}).get('email', ''),
                    customer_name=shipping.get('name', ''),
                    shipping_address={
                        'line1': address.get('line1', ''),
                        'line2': address.get('line2', ''),
                        'city': address.get('city', ''),
                        'state': address.get('state', ''),
                        'postal_code': address.get('postal_code', ''),
                        'country': address.get('country', ''),
                    },
                    status='paid',
                    subtotal=cart.subtotal,
                    total=session.get('amount_total', 0) / 100,
                )

                # Use cart snapshot from metadata to ensure prices match what
                # was charged. Fall back to live cart for older sessions.
                snapshot_raw = metadata.get('cart_snapshot')
                snapshot_items = json.loads(snapshot_raw) if snapshot_raw else None

                if snapshot_items:
                    self._create_order_items_from_snapshot(order, snapshot_items)
                else:
                    self._create_order_items_from_cart(order, cart)

                # Gift card balance was already deducted at checkout creation
                # time (with select_for_update to prevent double-spend).
                # Here we just create the audit record.
                gift_card_code = metadata.get('gift_card_code')
                gift_card_amount = metadata.get('gift_card_amount')
                if gift_card_code and gift_card_amount:
                    try:
                        gift_card = GiftCard.objects.get(code=gift_card_code)
                        amount = Decimal(gift_card_amount)
                        GiftCardRedemption.objects.create(
                            gift_card=gift_card,
                            order=order,
                            amount=amount,
                        )
                    except GiftCard.DoesNotExist:
                        logger.warning(f"Gift card {gift_card_code} not found during redemption")
                    except Exception:
                        logger.exception("Gift card redemption failed")

                cart.items.all().delete()
        except IntegrityError:
            # Secondary guard: unique constraint on stripe_checkout_id
            # catches races the exists() check can't
            logger.info(f"Duplicate order prevented by unique constraint for session {session['id']}")
            return

        logger.info(
            f"Order {order.order_number} created - "
            f"${order.total} - {order.customer_email}"
        )

        # Send confirmation email (outside transaction â€” don't rollback
        # the order if email fails)
        try:
            send_order_confirmation(order)
        except Exception:
            logger.exception(f"Failed to send confirmation email for order {order.order_number}")

        # Add customer to newsletter subscriber list
        if order.customer_email:
            try:
                Subscriber.objects.get_or_create(
                    email=order.customer_email.lower(),
                    defaults={
                        'name': order.customer_name,
                        'source': 'purchase',
                    }
                )
            except Exception:
                pass

    def _create_order_items_from_snapshot(self, order, snapshot_items):
        """Create order items using the price snapshot from checkout time."""
        for snap in snapshot_items:
            quantity = snap['q']
            price = Decimal(snap['p'])
            total = price * quantity

            if snap['t'] == 'v':
                try:
                    variant = ProductVariant.objects.select_related('photo').get(
                        id=snap['id']
                    )
                    OrderItem.objects.create(
                        order=order,
                        variant=variant,
                        item_title=variant.photo.title,
                        item_description=variant.display_name,
                        quantity=quantity,
                        unit_price=price,
                        total_price=total,
                    )
                except ProductVariant.DoesNotExist:
                    logger.error(f"Variant {snap['id']} not found for order {order.order_number}")
            elif snap['t'] == 'p':
                try:
                    product = Product.objects.get(id=snap['id'])
                    OrderItem.objects.create(
                        order=order,
                        product=product,
                        item_title=product.title,
                        item_description=product.get_product_type_display(),
                        quantity=quantity,
                        unit_price=price,
                        total_price=total,
                    )
                    # Atomic stock decrement to prevent race conditions
                    if product.track_inventory:
                        updated = Product.objects.filter(
                            id=product.id,
                            stock_quantity__gte=quantity,
                        ).update(stock_quantity=F('stock_quantity') - quantity)
                        if not updated:
                            logger.warning(
                                f"Insufficient stock for product {product.id} "
                                f"(requested {quantity})"
                            )
                except Product.DoesNotExist:
                    logger.error(f"Product {snap['id']} not found for order {order.order_number}")

    def _create_order_items_from_cart(self, order, cart):
        """Fallback: create order items from live cart (for older sessions without snapshot)."""
        for item in cart.items.select_related('variant__photo', 'product'):
            if item.variant:
                OrderItem.objects.create(
                    order=order,
                    variant=item.variant,
                    item_title=item.variant.photo.title,
                    item_description=item.variant.display_name,
                    quantity=item.quantity,
                    unit_price=item.variant.price,
                    total_price=item.total_price,
                )
            elif item.product:
                OrderItem.objects.create(
                    order=order,
                    product=item.product,
                    item_title=item.product.title,
                    item_description=item.product.get_product_type_display(),
                    quantity=item.quantity,
                    unit_price=item.product.price,
                    total_price=item.total_price,
                )
                # Atomic stock decrement to prevent race conditions
                if item.product.track_inventory:
                    updated = Product.objects.filter(
                        id=item.product.id,
                        stock_quantity__gte=item.quantity,
                    ).update(stock_quantity=F('stock_quantity') - item.quantity)
                    if not updated:
                        logger.warning(
                            f"Insufficient stock for product {item.product.id} "
                            f"(requested {item.quantity})"
                        )

    def handle_checkout_expired(self, session):
        """Refund reserved gift card balance when a checkout session expires."""
        metadata = session.get('metadata', {})
        gift_card_code = metadata.get('gift_card_code')
        gift_card_amount = metadata.get('gift_card_amount')

        if not gift_card_code or not gift_card_amount:
            return

        amount = Decimal(gift_card_amount)
        with transaction.atomic():
            try:
                gift_card = GiftCard.objects.select_for_update().get(
                    code=gift_card_code
                )
                gift_card.remaining_balance += amount
                gift_card.is_active = True
                gift_card.save(update_fields=['remaining_balance', 'is_active'])
                logger.info(
                    f"Refunded ${amount} to gift card {gift_card.code} "
                    f"after expired checkout session {session['id']}"
                )
            except GiftCard.DoesNotExist:
                logger.warning(
                    f"Gift card {gift_card_code} not found for expired session refund"
                )

    def handle_gift_card_purchase(self, session):
        """Create gift card from completed checkout session."""
        metadata = session.get('metadata', {})
        payment_intent = session.get('payment_intent', '')

        # Idempotency: skip if we already created a gift card for this payment
        if payment_intent and GiftCard.objects.filter(
            stripe_payment_intent=payment_intent
        ).exists():
            logger.info(f"Gift card already exists for payment {payment_intent}, skipping")
            return

        amount = Decimal(metadata.get('amount', '0'))
        if amount <= 0:
            return

        try:
            gift_card = GiftCard.objects.create(
                initial_amount=amount,
                remaining_balance=amount,
                purchaser_email=metadata.get('purchaser_email', ''),
                purchaser_name=metadata.get('purchaser_name', ''),
                recipient_email=metadata.get('recipient_email', ''),
                recipient_name=metadata.get('recipient_name', ''),
                message=metadata.get('message', ''),
                stripe_payment_intent=payment_intent,
            )
        except IntegrityError:
            # Secondary guard: unique constraint on stripe_payment_intent
            logger.info(f"Duplicate gift card prevented by unique constraint for payment {payment_intent}")
            return

        logger.info(
            f"Gift card {gift_card.code} created - "
            f"${amount} - recipient: {gift_card.recipient_email}"
        )

        # Send emails (log failures instead of silently swallowing)
        try:
            send_gift_card_email(gift_card)
            gift_card.mark_sent()
        except Exception:
            logger.exception(f"Failed to send gift card email for {gift_card.code}")

        try:
            send_gift_card_purchase_confirmation(gift_card)
        except Exception:
            logger.exception(f"Failed to send purchase confirmation for gift card {gift_card.code}")

        # Add gift card purchaser to subscriber list
        if gift_card.purchaser_email:
            try:
                Subscriber.objects.get_or_create(
                    email=gift_card.purchaser_email.lower(),
                    defaults={
                        'name': gift_card.purchaser_name,
                        'source': 'gift_card_purchase',
                    }
                )
            except Exception:
                pass


class OrderLookupView(APIView):
    """Look up order by Stripe session ID."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [OrderLookupThrottle]

    def get(self, request):
        session_id = request.query_params.get('session_id')
        if not session_id:
            return Response(
                {'error': 'session_id required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            order = Order.objects.get(stripe_checkout_id=session_id)
            return Response({
                'order_number': order.order_number,
                'customer_email': order.customer_email,
                'total': str(order.total),
                'status': order.status,
            })
        except Order.DoesNotExist:
            return Response(
                {'error': 'Order not found'},
                status=status.HTTP_404_NOT_FOUND
            )


================================================
FILE: backend/apps/payments/urls.py
================================================
from django.urls import path

from . import views

app_name = 'payments'

urlpatterns = [
    path('checkout/', views.CreateCheckoutSessionView.as_view(), name='checkout'),
    path('webhooks/stripe/', views.StripeWebhookView.as_view(), name='stripe-webhook'),
    path('order/', views.OrderLookupView.as_view(), name='order-lookup'),
]


================================================
FILE: backend/apps/core/models.py
================================================
import secrets
import uuid
from decimal import Decimal

from django.db import models
from django.utils import timezone


class Subscriber(models.Model):
    """Newsletter subscriber."""

    SOURCE_CHOICES = [
        ('footer', 'Footer'),
        ('popup', 'Popup'),
        ('checkout', 'Checkout'),
        ('homepage', 'Homepage'),
        ('purchase', 'Purchase'),
        ('gift_card_purchase', 'Gift Card Purchase'),
    ]

    email = models.EmailField(unique=True)
    name = models.CharField(max_length=200, blank=True)
    source = models.CharField(max_length=20, choices=SOURCE_CHOICES, default='footer')
    interests = models.JSONField(default=list, blank=True)  # Collection slugs
    is_active = models.BooleanField(default=True)
    mailerlite_id = models.CharField(max_length=100, blank=True)  # MailerLite subscriber ID
    subscribed_at = models.DateTimeField(auto_now_add=True)
    unsubscribed_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ['-subscribed_at']

    def __str__(self):
        return self.email

    def unsubscribe(self):
        self.is_active = False
        self.unsubscribed_at = timezone.now()
        self.save()


class GiftCard(models.Model):
    """Gift card for store credit."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    code = models.CharField(max_length=19, unique=True, editable=False)
    initial_amount = models.DecimalField(max_digits=8, decimal_places=2)
    remaining_balance = models.DecimalField(max_digits=8, decimal_places=2)

    # Purchaser info
    purchaser_email = models.EmailField()
    purchaser_name = models.CharField(max_length=200, blank=True)

    # Recipient info
    recipient_email = models.EmailField()
    recipient_name = models.CharField(max_length=200, blank=True)
    message = models.TextField(blank=True, help_text='Personal message to recipient')

    # Status
    is_active = models.BooleanField(default=True)
    is_sent = models.BooleanField(default=False)
    purchased_at = models.DateTimeField(auto_now_add=True)
    sent_at = models.DateTimeField(null=True, blank=True)
    expires_at = models.DateTimeField(null=True, blank=True)

    # Payment
    stripe_payment_intent = models.CharField(max_length=200, blank=True, unique=True)

    class Meta:
        ordering = ['-purchased_at']

    def __str__(self):
        return f"Gift Card {self.code} (${self.remaining_balance})"

    def save(self, *args, **kwargs):
        if not self.code:
            self.code = self._generate_code()
        if self.remaining_balance is None:
            self.remaining_balance = self.initial_amount
        super().save(*args, **kwargs)

    def _generate_code(self):
        """Generate a unique 16-character gift card code like XXXX-XXXX-XXXX-XXXX."""
        while True:
            code = '-'.join([
                secrets.token_hex(2).upper()
                for _ in range(4)
            ])
            if not GiftCard.objects.filter(code=code).exists():
                return code

    def redeem(self, amount):
        """Redeem a portion of the gift card. Returns amount actually redeemed."""
        if not self.is_active:
            return Decimal('0')
        if self.expires_at and timezone.now() > self.expires_at:
            return Decimal('0')

        redeemable = min(amount, self.remaining_balance)
        self.remaining_balance -= redeemable
        if self.remaining_balance == 0:
            self.is_active = False
        self.save()
        return redeemable

    def mark_sent(self):
        """Mark gift card as sent to recipient."""
        self.is_sent = True
        self.sent_at = timezone.now()
        self.save(update_fields=['is_sent', 'sent_at'])

    @property
    def is_valid(self):
        if not self.is_active:
            return False
        if self.remaining_balance <= 0:
            return False
        if self.expires_at and timezone.now() > self.expires_at:
            return False
        return True


class GiftCardRedemption(models.Model):
    """Record of gift card usage on an order."""

    gift_card = models.ForeignKey(GiftCard, on_delete=models.PROTECT, related_name='redemptions')
    order = models.ForeignKey('orders.Order', on_delete=models.PROTECT, related_name='gift_card_redemptions')
    amount = models.DecimalField(max_digits=8, decimal_places=2)
    redeemed_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"${self.amount} from {self.gift_card.code} on {self.order.order_number}"


================================================
FILE: backend/apps/core/views.py
================================================
import logging

import stripe

from django.conf import settings
from django.db import IntegrityError
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.throttling import AnonRateThrottle

from apps.orders.emails import send_contact_form_notification
from .models import Subscriber, GiftCard
from .mailerlite import add_subscriber_to_mailerlite

logger = logging.getLogger(__name__)


class NewsletterThrottle(AnonRateThrottle):
    scope = 'newsletter'


class ContactThrottle(AnonRateThrottle):
    scope = 'contact'


class GiftCardThrottle(AnonRateThrottle):
    scope = 'gift_card'


class GiftCardCheckThrottle(AnonRateThrottle):
    scope = 'gift_card_check'

stripe.api_key = settings.STRIPE_SECRET_KEY


class ContactFormView(APIView):
    """Handle contact form submissions."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [ContactThrottle]

    def post(self, request):
        # Honeypot: if this hidden field is filled, it's a bot
        if request.data.get('website', ''):
            return Response({'success': True, 'message': 'Message sent successfully'})

        name = request.data.get('name', '').strip()
        email = request.data.get('email', '').strip()
        subject = request.data.get('subject', '').strip()
        message = request.data.get('message', '').strip()

        if not all([name, email, message]):
            return Response(
                {'error': 'Name, email, and message are required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        if not subject:
            subject = 'General Inquiry'

        try:
            send_contact_form_notification(name, email, subject, message)
            return Response({'success': True, 'message': 'Message sent successfully'})
        except Exception:
            return Response(
                {'error': 'Failed to send message. Please try again.'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class HealthCheckView(APIView):
    """Simple health check endpoint."""

    def get(self, request):
        return Response({'status': 'ok'})


class NewsletterSubscribeView(APIView):
    """Subscribe to newsletter."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [NewsletterThrottle]

    def post(self, request):
        email = request.data.get('email', '').strip().lower()
        name = request.data.get('name', '').strip()
        source = request.data.get('source', 'footer')
        interests = request.data.get('interests', [])

        if not email:
            return Response(
                {'error': 'Email is required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            subscriber, created = Subscriber.objects.get_or_create(
                email=email,
                defaults={
                    'name': name,
                    'source': source,
                    'interests': interests,
                }
            )

            if not created:
                # Reactivate if previously unsubscribed
                if not subscriber.is_active:
                    subscriber.is_active = True
                    subscriber.unsubscribed_at = None
                    subscriber.save()

            # Sync to MailerLite
            try:
                add_subscriber_to_mailerlite(subscriber)
            except Exception:
                pass  # Don't fail if MailerLite is down

            return Response({
                'success': True,
                'message': 'Thanks for subscribing!',
                'is_new': created
            })

        except IntegrityError:
            return Response({
                'success': True,
                'message': 'You are already subscribed!',
                'is_new': False
            })


class NewsletterUnsubscribeView(APIView):
    """Unsubscribe from newsletter."""

    def post(self, request):
        email = request.data.get('email', '').strip().lower()

        if not email:
            return Response(
                {'error': 'Email is required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            subscriber = Subscriber.objects.get(email=email)
            subscriber.unsubscribe()
            return Response({'success': True, 'message': 'You have been unsubscribed.'})
        except Subscriber.DoesNotExist:
            return Response({'success': True, 'message': 'You have been unsubscribed.'})


class GiftCardPurchaseView(APIView):
    """Purchase a gift card."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [GiftCardThrottle]

    ALLOWED_AMOUNTS = [100, 250, 500, 1000, 2500]

    def post(self, request):
        amount = request.data.get('amount')
        recipient_email = request.data.get('recipient_email', '').strip().lower()
        recipient_name = request.data.get('recipient_name', '').strip()
        purchaser_email = request.data.get('purchaser_email', '').strip().lower()
        purchaser_name = request.data.get('purchaser_name', '').strip()
        message = request.data.get('message', '').strip()

        # Validate amount
        try:
            amount = int(amount)
        except (TypeError, ValueError):
            return Response(
                {'error': 'Invalid amount'},
                status=status.HTTP_400_BAD_REQUEST
            )

        if amount not in self.ALLOWED_AMOUNTS:
            return Response(
                {'error': f'Amount must be one of: {self.ALLOWED_AMOUNTS}'},
                status=status.HTTP_400_BAD_REQUEST
            )

        if not recipient_email or not purchaser_email:
            return Response(
                {'error': 'Recipient and purchaser email are required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Create Stripe checkout session for gift card
        try:
            checkout_session = stripe.checkout.Session.create(
                payment_method_types=['card'],
                line_items=[{
                    'price_data': {
                        'currency': 'usd',
                        'unit_amount': amount * 100,
                        'product_data': {
                            'name': f'${amount} Gift Card',
                            'description': f'Gift card for Matthew Raynor Photography',
                        },
                    },
                    'quantity': 1,
                }],
                mode='payment',
                success_url=f"{settings.FRONTEND_URL}/gift-card/success?session_id={{CHECKOUT_SESSION_ID}}",
                cancel_url=f"{settings.FRONTEND_URL}/gift-card",
                metadata={
                    'type': 'gift_card',
                    'amount': str(amount),
                    'recipient_email': recipient_email,
                    'recipient_name': recipient_name,
                    'purchaser_email': purchaser_email,
                    'purchaser_name': purchaser_name,
                    'message': message[:500],  # Limit message length
                },
            )

            return Response({
                'checkout_url': checkout_session.url,
                'session_id': checkout_session.id,
            })

        except stripe.error.StripeError as e:
            logger.error(f"Stripe error during gift card purchase: {e}")
            return Response(
                {'error': 'Payment processing error. Please try again.'},
                status=status.HTTP_400_BAD_REQUEST
            )


class GiftCardCheckView(APIView):
    """Check gift card balance."""
    authentication_classes = []
    permission_classes = []
    throttle_classes = [GiftCardCheckThrottle]

    def post(self, request):
        code = request.data.get('code', '').strip().upper()

        if not code:
            return Response(
                {'error': 'Gift card code is required'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            gift_card = GiftCard.objects.get(code=code)

            if not gift_card.is_valid:
                return Response({
                    'valid': False,
                    'error': 'This gift card is not valid',
                })

            return Response({
                'valid': True,
                'balance': str(gift_card.remaining_balance),
                'expires_at': gift_card.expires_at.isoformat() if gift_card.expires_at else None,
            })

        except GiftCard.DoesNotExist:
            # Return same response as invalid to prevent code enumeration
            return Response({
                'valid': False,
                'error': 'This gift card is not valid',
            })


================================================
FILE: backend/apps/core/urls.py
================================================
from django.urls import path

from . import views

app_name = 'core'

urlpatterns = [
    path('contact/', views.ContactFormView.as_view(), name='contact'),
    path('health/', views.HealthCheckView.as_view(), name='health'),
    # Newsletter
    path('newsletter/subscribe/', views.NewsletterSubscribeView.as_view(), name='newsletter-subscribe'),
    path('newsletter/unsubscribe/', views.NewsletterUnsubscribeView.as_view(), name='newsletter-unsubscribe'),
    # Gift Cards
    path('gift-cards/purchase/', views.GiftCardPurchaseView.as_view(), name='gift-card-purchase'),
    path('gift-cards/check/', views.GiftCardCheckView.as_view(), name='gift-card-check'),
]


================================================
FILE: backend/apps/core/admin.py
================================================
from django.contrib import admin
from django.utils.html import format_html

from .models import Subscriber, GiftCard, GiftCardRedemption


@admin.register(Subscriber)
class SubscriberAdmin(admin.ModelAdmin):
    list_display = ['email', 'name', 'source', 'is_active', 'subscribed_at']
    list_filter = ['is_active', 'source', 'subscribed_at']
    search_fields = ['email', 'name']
    readonly_fields = ['subscribed_at', 'unsubscribed_at', 'mailerlite_id']
    ordering = ['-subscribed_at']

    actions = ['export_active_subscribers']

    def export_active_subscribers(self, request, queryset):
        """Export selected subscribers as CSV."""
        import csv
        from django.http import HttpResponse

        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="subscribers.csv"'

        writer = csv.writer(response)
        writer.writerow(['Email', 'Name', 'Source', 'Subscribed At'])

        for subscriber in queryset.filter(is_active=True):
            writer.writerow([
                subscriber.email,
                subscriber.name,
                subscriber.source,
                subscriber.subscribed_at.strftime('%Y-%m-%d'),
            ])

        return response

    export_active_subscribers.short_description = "Export selected as CSV"


class GiftCardRedemptionInline(admin.TabularInline):
    model = GiftCardRedemption
    extra = 0
    readonly_fields = ['order', 'amount', 'redeemed_at']
    can_delete = False


@admin.register(GiftCard)
class GiftCardAdmin(admin.ModelAdmin):
    list_display = [
        'code', 'initial_amount', 'remaining_balance',
        'purchaser_email', 'recipient_email', 'status_badge', 'purchased_at'
    ]
    list_filter = ['is_active', 'is_sent', 'purchased_at']
    search_fields = ['code', 'purchaser_email', 'recipient_email']
    readonly_fields = [
        'id', 'code', 'purchased_at', 'sent_at',
        'stripe_payment_intent'
    ]
    ordering = ['-purchased_at']
    inlines = [GiftCardRedemptionInline]

    fieldsets = (
        ('Gift Card Details', {
            'fields': ('id', 'code', 'initial_amount', 'remaining_balance', 'expires_at')
        }),
        ('Purchaser', {
            'fields': ('purchaser_email', 'purchaser_name')
        }),
        ('Recipient', {
            'fields': ('recipient_email', 'recipient_name', 'message')
        }),
        ('Status', {
            'fields': ('is_active', 'is_sent', 'purchased_at', 'sent_at')
        }),
        ('Stripe', {
            'fields': ('stripe_payment_intent',),
            'classes': ('collapse',)
        }),
    )

    actions = ['resend_gift_card']

    def status_badge(self, obj):
        if not obj.is_active:
            return format_html('<span style="color: {};">Deactivated</span>', '#999')
        if obj.remaining_balance == 0:
            return format_html('<span style="color: {};">Used</span>', '#666')
        if obj.remaining_balance < obj.initial_amount:
            return format_html('<span style="color: #0077B6;">Partial (${})</span>', int(obj.remaining_balance))
        return format_html('<span style="color: {};">Active</span>', '#28a745')

    status_badge.short_description = 'Status'

    def resend_gift_card(self, request, queryset):
        """Resend gift card emails."""
        from .emails import send_gift_card_email

        count = 0
        for gift_card in queryset:
            if gift_card.is_active and gift_card.remaining_balance > 0:
                try:
                    send_gift_card_email(gift_card)
                    count += 1
                except Exception:
                    pass

        self.message_user(request, f"Resent {count} gift card(s).")

    resend_gift_card.short_description = "Resend gift card email"


================================================
FILE: backend/apps/core/emails.py
================================================
import resend
from django.conf import settings
from django.template.loader import render_to_string

# Initialize Resend with API key
resend.api_key = settings.RESEND_API_KEY


def send_gift_card_email(gift_card):
    """Send gift card to recipient."""
    subject = f"You've received a gift card from {gift_card.purchaser_name or 'a friend'}!"

    context = {
        'gift_card': gift_card,
        'store_name': 'Matthew Raynor Photography',
        'store_url': settings.FRONTEND_URL,
    }

    html_message = render_to_string('emails/gift_card.html', context)
    plain_message = render_to_string('emails/gift_card.txt', context)

    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [gift_card.recipient_email],
        "subject": subject,
        "html": html_message,
        "text": plain_message,
    })


def send_gift_card_purchase_confirmation(gift_card):
    """Send confirmation to purchaser that gift card was sent."""
    subject = f"Gift card sent to {gift_card.recipient_name or gift_card.recipient_email}"

    context = {
        'gift_card': gift_card,
        'store_name': 'Matthew Raynor Photography',
    }

    html_message = render_to_string('emails/gift_card_confirmation.html', context)
    plain_message = render_to_string('emails/gift_card_confirmation.txt', context)

    resend.Emails.send({
        "from": settings.DEFAULT_FROM_EMAIL,
        "to": [gift_card.purchaser_email],
        "subject": subject,
        "html": html_message,
        "text": plain_message,
    })


================================================
FILE: backend/apps/chat/models.py
================================================
"""
Models for the AI chat agent.

Stores conversation history and messages for context continuity.
"""
import uuid

from django.db import models


class Conversation(models.Model):
    """A chat conversation with a customer."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session_key = models.CharField(
        max_length=40,
        blank=True,
        db_index=True,
        help_text='Session key of the user who started this conversation'
    )
    cart = models.ForeignKey(
        'orders.Cart',
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
        related_name='conversations',
        help_text='Associated shopping cart for this conversation'
    )
    # Store the wall analysis ID if user uploaded a room photo
    wall_analysis_id = models.CharField(
        max_length=100,
        blank=True,
        help_text='ID of wall analysis if room photo was uploaded'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-updated_at']

    def __str__(self):
        return f"Conversation {self.id} ({self.created_at.strftime('%Y-%m-%d %H:%M')})"


class Message(models.Model):
    """A single message in a conversation."""

    ROLE_CHOICES = [
        ('user', 'User'),
        ('assistant', 'Assistant'),
        ('tool', 'Tool Result'),
    ]

    conversation = models.ForeignKey(
        Conversation,
        on_delete=models.CASCADE,
        related_name='messages'
    )
    role = models.CharField(max_length=20, choices=ROLE_CHOICES)
    content = models.TextField()
    # For user messages with images (room photos)
    image_url = models.URLField(blank=True, help_text='URL of attached image')
    # For assistant messages that use tools
    tool_calls = models.JSONField(
        null=True,
        blank=True,
        help_text='Tool calls made by the assistant'
    )
    tool_call_id = models.CharField(
        max_length=100,
        blank=True,
        help_text='ID of the tool call this message responds to'
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        content_preview = self.content[:50] + '...' if len(self.content) > 50 else self.content
        return f"{self.role}: {content_preview}"


================================================
FILE: backend/apps/chat/views.py
================================================
"""
Views for the AI chat agent.

Provides SSE streaming endpoint for real-time chat responses.
"""
import json
import time
import uuid

from django.core.cache import cache
from django.http import StreamingHttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.conf import settings

from .models import Conversation, Message
from .agent import run_agent


def _get_client_ip(request):
    """Get client IP from request, accounting for proxies."""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        return x_forwarded_for.split(',')[0].strip()
    return request.META.get('REMOTE_ADDR', '')


def _check_rate_limit(request, scope, max_requests, window_seconds):
    """Simple rate limiter using Django cache. Returns (allowed, retry_after)."""
    ip = _get_client_ip(request)
    cache_key = f'throttle_{scope}_{ip}'
    history = cache.get(cache_key, [])

    now = time.time()
    # Remove expired entries
    history = [t for t in history if now - t < window_seconds]

    if len(history) >= max_requests:
        retry_after = int(window_seconds - (now - history[0]))
        return False, retry_after

    history.append(now)
    cache.set(cache_key, history, window_seconds)
    return True, 0


def get_cart_id_from_request(request):
    """Get or create cart using session key (same as main site's cart system)."""
    from apps.orders.models import Cart

    # Ensure session exists
    if not request.session.session_key:
        request.session.create()

    session_key = request.session.session_key
    cart, _ = Cart.objects.get_or_create(session_key=session_key)
    return str(cart.id)


def parse_json_body(request):
    """Parse JSON body from request."""
    try:
        body = json.loads(request.body.decode('utf-8'))
        request._body_json = body
        return body
    except (json.JSONDecodeError, UnicodeDecodeError):
        return {}


@csrf_exempt
@require_http_methods(["POST"])
def chat_stream(request):
    """
    SSE streaming endpoint for chat.

    Accepts POST with JSON body:
    {
        "message": "user message",
        "conversation_id": "optional-uuid",
        "image_url": "optional-image-url",
        "cart_id": "optional-cart-uuid"
    }

    Returns Server-Sent Events stream.
    """
    # Rate limit: 30 chat requests per hour per IP
    allowed, retry_after = _check_rate_limit(request, 'chat', 30, 3600)
    if not allowed:
        return JsonResponse(
            {'error': 'Too many requests. Please try again later.'},
            status=429,
            headers={'Retry-After': str(retry_after)},
        )

    body = parse_json_body(request)

    user_message = body.get('message', '').strip()
    conversation_id = body.get('conversation_id')
    image_url = body.get('image_url')
    cart_id = body.get('cart_id') or get_cart_id_from_request(request)

    # Allow empty message if image is provided
    if not user_message and not image_url:
        return JsonResponse({'error': 'Message or image is required'}, status=400)

    # Default message for image-only uploads
    if not user_message and image_url:
        user_message = "Here's a photo of my room. Can you help me visualize how a print would look here?"

    # Ensure session exists for ownership tracking
    if not request.session.session_key:
        request.session.create()
    session_key = request.session.session_key

    # Get or create conversation
    if conversation_id:
        try:
            conversation = Conversation.objects.get(id=conversation_id)
        except (Conversation.DoesNotExist, ValueError):
            conversation = Conversation.objects.create(session_key=session_key)
    else:
        conversation = Conversation.objects.create(session_key=session_key)

    # Link cart to conversation if provided
    if cart_id and not conversation.cart_id:
        try:
            from apps.orders.models import Cart
            cart = Cart.objects.get(id=cart_id)
            conversation.cart = cart
            conversation.save()
        except Exception:
            pass

    def event_stream():
        """Generator that yields SSE events."""
        try:
            # Send conversation ID first
            yield f"data: {json.dumps({'type': 'conversation_id', 'id': str(conversation.id)})}\n\n"

            # Run agent and stream responses
            for chunk in run_agent(
                conversation=conversation,
                user_message=user_message,
                image_url=image_url,
                cart_id=cart_id,
            ):
                yield f"data: {json.dumps(chunk)}\n\n"

        except Exception as e:
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"

    response = StreamingHttpResponse(
        event_stream(),
        content_type='text/event-stream',
    )
    response['Cache-Control'] = 'no-cache'
    response['X-Accel-Buffering'] = 'no'  # Disable nginx buffering

    return response


@csrf_exempt
@require_http_methods(["POST"])
def chat_sync(request):
    """
    Non-streaming chat endpoint for testing.

    Same input as chat_stream, but returns complete response as JSON.
    """
    # Rate limit: shares the same 'chat' scope as streaming endpoint
    allowed, retry_after = _check_rate_limit(request, 'chat', 30, 3600)
    if not allowed:
        return JsonResponse(
            {'error': 'Too many requests. Please try again later.'},
            status=429,
            headers={'Retry-After': str(retry_after)},
        )

    from .agent import run_agent_sync

    body = parse_json_body(request)

    user_message = body.get('message', '').strip()
    if not user_message:
        return JsonResponse({'error': 'Message is required'}, status=400)

    conversation_id = body.get('conversation_id')
    image_url = body.get('image_url')
    cart_id = body.get('cart_id') or get_cart_id_from_request(request)

    # Ensure session exists for ownership tracking
    if not request.session.session_key:
        request.session.create()
    session_key = request.session.session_key

    # Get or create conversation
    if conversation_id:
        try:
            conversation = Conversation.objects.get(id=conversation_id)
        except (Conversation.DoesNotExist, ValueError):
            conversation = Conversation.objects.create(session_key=session_key)
    else:
        conversation = Conversation.objects.create(session_key=session_key)

    try:
        response_text = run_agent_sync(
            conversation=conversation,
            user_message=user_message,
            image_url=image_url,
            cart_id=cart_id,
        )

        return JsonResponse({
            'conversation_id': str(conversation.id),
            'response': response_text,
        })

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@require_http_methods(["GET"])
def chat_history(request, conversation_id):
    """
    Get chat history for a conversation.

    Only returns messages if the requesting session owns the conversation.
    """
    try:
        conversation = Conversation.objects.get(id=conversation_id)
    except (Conversation.DoesNotExist, ValueError):
        return JsonResponse({'error': 'Conversation not found'}, status=404)

    # Ownership check: only the session that created the conversation can read it
    if conversation.session_key and conversation.session_key != request.session.session_key:
        return JsonResponse({'error': 'Conversation not found'}, status=404)

    messages = []
    for msg in conversation.messages.all():
        messages.append({
            'id': msg.id,
            'role': msg.role,
            'content': msg.content,
            'image_url': msg.image_url or None,
            'tool_calls': msg.tool_calls,
            'created_at': msg.created_at.isoformat(),
        })

    return JsonResponse({
        'conversation_id': str(conversation.id),
        'messages': messages,
        'created_at': conversation.created_at.isoformat(),
    })


@csrf_exempt
@require_http_methods(["POST"])
def upload_chat_image(request):
    """
    Upload an image for use in chat (room photos).

    Accepts multipart form with 'image' file.
    Returns the URL of the uploaded image.
    """
    # Rate limit: 20 uploads per hour per IP
    allowed, retry_after = _check_rate_limit(request, 'uploads', 20, 3600)
    if not allowed:
        return JsonResponse(
            {'error': 'Too many uploads. Please try again later.'},
            status=429,
            headers={'Retry-After': str(retry_after)},
        )

    if 'image' not in request.FILES:
        return JsonResponse({'error': 'No image provided'}, status=400)

    image_file = request.FILES['image']

    # Validate file type
    allowed_types = ['image/jpeg', 'image/png', 'image/webp']
    if image_file.content_type not in allowed_types:
        return JsonResponse({'error': 'Invalid image type'}, status=400)

    # Validate file size (max 10MB)
    if image_file.size > 10 * 1024 * 1024:
        return JsonResponse({'error': 'Image too large (max 10MB)'}, status=400)

    try:
        from django.core.files.storage import default_storage
        from django.utils import timezone

        # Generate unique filename
        ext = image_file.name.split('.')[-1] if '.' in image_file.name else 'jpg'
        filename = f"chat-images/{timezone.now().strftime('%Y/%m')}/{uuid.uuid4()}.{ext}"

        # Save to storage (S3 in production)
        path = default_storage.save(filename, image_file)
        url = default_storage.url(path)

        # Make URL absolute for frontend
        if not url.startswith('http'):
            base_url = getattr(settings, 'BACKEND_URL', 'http://localhost:7974')
            url = f"{base_url}{url}"

        return JsonResponse({
            'success': True,
            'url': url,
            'filename': filename,
        })

    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


================================================
FILE: backend/apps/chat/urls.py
================================================
"""
URL patterns for the chat app.
"""
from django.urls import path
from . import views

app_name = 'chat'

urlpatterns = [
    # SSE streaming chat endpoint
    path('', views.chat_stream, name='chat_stream'),

    # Sync chat endpoint (for testing)
    path('sync/', views.chat_sync, name='chat_sync'),

    # Get conversation history
    path('history/<uuid:conversation_id>/', views.chat_history, name='chat_history'),

    # Upload image for chat
    path('upload-image/', views.upload_chat_image, name='upload_chat_image'),
]


================================================
FILE: backend/apps/chat/admin.py
================================================
from django.contrib import admin
from .models import Conversation, Message


class MessageInline(admin.TabularInline):
    model = Message
    extra = 0
    readonly_fields = ['role', 'content', 'image_url', 'tool_calls', 'created_at']
    can_delete = False

    def has_add_permission(self, request, obj=None):
        return False


@admin.register(Conversation)
class ConversationAdmin(admin.ModelAdmin):
    list_display = ['id', 'cart', 'message_count', 'created_at', 'updated_at']
    list_filter = ['created_at']
    search_fields = ['id']
    readonly_fields = ['id', 'created_at', 'updated_at']
    inlines = [MessageInline]

    def message_count(self, obj):
        return obj.messages.count()
    message_count.short_description = 'Messages'


@admin.register(Message)
class MessageAdmin(admin.ModelAdmin):
    list_display = ['id', 'conversation', 'role', 'content_preview', 'created_at']
    list_filter = ['role', 'created_at']
    search_fields = ['content']
    readonly_fields = ['created_at']

    def content_preview(self, obj):
        return obj.content[:100] + '...' if len(obj.content) > 100 else obj.content
    content_preview.short_description = 'Content'


================================================
FILE: backend/apps/chat/agent.py
================================================
"""
LangChain agent setup for the AI shopping assistant.

Uses Claude as the LLM with tool-calling capabilities.
"""
import json
import uuid
from typing import Generator

from django.conf import settings

from langchain_anthropic import ChatAnthropic
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage, ToolMessage

from .prompts import SYSTEM_PROMPT
from .tools import ALL_TOOLS
from .models import Conversation, Message


def get_llm():
    """Get the Claude LLM instance."""
    return ChatAnthropic(
        model="claude-sonnet-4-20250514",
        anthropic_api_key=settings.ANTHROPIC_API_KEY,
        streaming=True,
        max_tokens=4096,
        timeout=30,
    )


def build_message_history(conversation: Conversation, max_messages: int = 50) -> list:
    """Convert database messages to LangChain message format.

    Limits history to the most recent messages to control token usage.
    """
    messages = []

    # Limit to the most recent messages to avoid sending huge context to the LLM
    db_messages = conversation.messages.order_by('-created_at')[:max_messages]
    db_messages = list(reversed(db_messages))  # Restore chronological order

    for msg in db_messages:
        if msg.role == 'user':
            content = msg.content
            # Handle images in user messages (only HTTPS URLs - Claude API requirement)
            if msg.image_url and msg.image_url.startswith('https://'):
                content = [
                    {"type": "text", "text": msg.content},
                    {"type": "image_url", "image_url": {"url": msg.image_url}},
                ]
            messages.append(HumanMessage(content=content))

        elif msg.role == 'assistant':
            messages.append(AIMessage(content=msg.content, tool_calls=msg.tool_calls or []))

        elif msg.role == 'tool':
            messages.append(ToolMessage(
                content=msg.content,
                tool_call_id=msg.tool_call_id,
            ))

    return messages


def sanitize_tool_result(result: str, max_length: int = 50000) -> str:
    """Sanitize tool results to mitigate prompt injection from stored data.

    Truncates excessively large results and strips common injection patterns.
    """
    if len(result) > max_length:
        result = result[:max_length] + '... (truncated)'
    return result


def execute_tool(tool_name: str, tool_args: dict, cart_id: str = None) -> str:
    """Execute a tool by name with the given arguments."""
    # Find the tool function
    tool_func = None
    for t in ALL_TOOLS:
        if t.name == tool_name:
            tool_func = t
            break

    if not tool_func:
        return json.dumps({'error': f'Unknown tool: {tool_name}'})

    # Inject cart_id for cart-related tools
    if cart_id and 'cart_id' in tool_func.args_schema.schema().get('properties', {}):
        tool_args['cart_id'] = cart_id

    try:
        result = tool_func.invoke(tool_args)
        raw = json.dumps(result) if not isinstance(result, str) else result
        return sanitize_tool_result(raw)
    except Exception as e:
        return json.dumps({'error': str(e)})


def run_agent(
    conversation: Conversation,
    user_message: str,
    image_url: str = None,
    cart_id: str = None,
) -> Generator[dict, None, None]:
    """
    Run the agent with a user message and yield streaming responses.

    Args:
        conversation: The conversation object
        user_message: The user's message
        image_url: Optional URL of an attached image
        cart_id: Optional cart ID for cart operations

    Yields:
        dict with 'type' and 'content' keys for streaming response chunks
    """
    llm = get_llm()
    llm_with_tools = llm.bind_tools(ALL_TOOLS)

    # Save user message to database
    user_msg_content = user_message
    Message.objects.create(
        conversation=conversation,
        role='user',
        content=user_message,
        image_url=image_url or '',
    )

    # Build message history
    history = build_message_history(conversation)

    # Build the prompt
    messages = [
        SystemMessage(content=SYSTEM_PROMPT),
        *history[:-1],  # Exclude the just-added user message since we'll add it fresh
    ]

    # Add user message with optional image (only HTTPS URLs - Claude API requirement)
    if image_url and image_url.startswith('https://'):
        # Include the URL in the text so Claude can pass it to analyze_room_image tool
        text_with_url = f"{user_message}\n\n[Attached image URL: {image_url}]"
        messages.append(HumanMessage(content=[
            {"type": "text", "text": text_with_url},
            {"type": "image_url", "image_url": {"url": image_url}},
        ]))
    else:
        messages.append(HumanMessage(content=user_message))

    # Agent loop - handle tool calls
    max_iterations = 10
    iteration = 0
    total_text_yielded = False

    while iteration < max_iterations:
        iteration += 1

        # Stream the response - use astream_events or collect chunks properly
        full_response = ""
        tool_calls = []
        tool_call_chunks = {}  # Dict to accumulate tool call chunks by index

        for chunk in llm_with_tools.stream(messages):
            # Handle text content
            if chunk.content:
                if isinstance(chunk.content, str):
                    # Add separator between iterations if we already yielded text
                    if total_text_yielded and not full_response:
                        yield {'type': 'text', 'content': '\n\n'}
                    full_response += chunk.content
                    total_text_yielded = True
                    yield {'type': 'text', 'content': chunk.content}
                elif isinstance(chunk.content, list):
                    for item in chunk.content:
                        if isinstance(item, dict) and item.get('type') == 'text':
                            if total_text_yielded and not full_response:
                                yield {'type': 'text', 'content': '\n\n'}
                            full_response += item.get('text', '')
                            total_text_yielded = True
                            yield {'type': 'text', 'content': item.get('text', '')}

            # Collect tool calls from chunks - they come in pieces during streaming
            if hasattr(chunk, 'tool_call_chunks') and chunk.tool_call_chunks:
                for tc_chunk in chunk.tool_call_chunks:
                    idx = tc_chunk.get('index', 0)
                    if idx not in tool_call_chunks:
                        tool_call_chunks[idx] = {'id': '', 'name': '', 'args': ''}
                    if tc_chunk.get('id'):
                        tool_call_chunks[idx]['id'] = tc_chunk['id']
                    if tc_chunk.get('name'):
                        tool_call_chunks[idx]['name'] = tc_chunk['name']
                    if tc_chunk.get('args'):
                        tool_call_chunks[idx]['args'] += tc_chunk['args']

        # Convert accumulated chunks to tool calls
        for idx in sorted(tool_call_chunks.keys()):
            tc = tool_call_chunks[idx]
            if tc['name']:  # Only include if we have a tool name
                args = {}
                if tc['args']:
                    try:
                        args = json.loads(tc['args'])
                    except json.JSONDecodeError:
                        pass
                tool_calls.append({
                    'id': tc['id'] or f"call_{uuid.uuid4().hex[:24]}",
                    'name': tc['name'],
                    'args': args,
                })

        # Save assistant message
        assistant_msg = Message.objects.create(
            conversation=conversation,
            role='assistant',
            content=full_response,
            tool_calls=[{
                'id': tc['id'],
                'name': tc['name'],
                'args': tc['args'],
            } for tc in tool_calls] if tool_calls else None,
        )

        # If no tool calls, we're done
        if not tool_calls:
            break

        # Execute tool calls
        messages.append(AIMessage(
            content=full_response,
            tool_calls=tool_calls,
        ))

        for tool_call in tool_calls:
            # Skip invalid tool calls (empty name or missing data)
            tool_name = tool_call.get('name', '')
            tool_id = tool_call.get('id', '')
            tool_args = tool_call.get('args', {})

            if not tool_name:
                continue

            # Generate a tool_call_id if missing
            if not tool_id:
                tool_id = f"call_{uuid.uuid4().hex[:24]}"

            yield {
                'type': 'tool_use',
                'tool': tool_name,
                'args': tool_args,
            }

            # Execute the tool
            result = execute_tool(
                tool_name,
                tool_args,
                cart_id=cart_id,
            )

            # Save tool result
            Message.objects.create(
                conversation=conversation,
                role='tool',
                content=result,
                tool_call_id=tool_id,
            )

            # Add to messages for next iteration
            messages.append(ToolMessage(
                content=result,
                tool_call_id=tool_id,
            ))

            # Parse JSON result (could be object {} or array [])
            try:
                parsed_result = json.loads(result)
            except (json.JSONDecodeError, TypeError):
                parsed_result = result

            yield {
                'type': 'tool_result',
                'tool': tool_name,
                'result': parsed_result,
            }

    yield {'type': 'done'}


def run_agent_sync(
    conversation: Conversation,
    user_message: str,
    image_url: str = None,
    cart_id: str = None,
) -> str:
    """
    Run the agent synchronously and return the final response.

    Useful for testing or when streaming isn't needed.
    """
    full_response = ""

    for chunk in run_agent(conversation, user_message, image_url, cart_id):
        if chunk['type'] == 'text':
            full_response += chunk['content']

    return full_response


================================================
FILE: backend/apps/chat/tools.py
================================================
"""
LangChain tools for the AI shopping agent.

Each tool is a function the agent can call to take actions
like searching photos, managing cart, generating mockups, etc.
"""
from typing import Optional

from django.conf import settings
from django.db.models import Q

from langchain_core.tools import tool
from openai import OpenAI

from apps.catalog.models import Photo, Collection, ProductVariant
from apps.orders.models import Cart, CartItem
from apps.core.models import GiftCard


def get_openai_client():
    """Get OpenAI client for embeddings."""
    return OpenAI(api_key=settings.OPENAI_API_KEY, timeout=10)


def get_absolute_url(file_field):
    """Convert a file field to an absolute URL for the frontend."""
    if not file_field:
        return None
    url = file_field.url
    # If already absolute, return as-is
    if url.startswith('http'):
        return url
    # Build absolute URL using FRONTEND_URL or localhost
    base_url = getattr(settings, 'BACKEND_URL', 'http://localhost:7974')
    return f"{base_url}{url}"


def generate_query_embedding(query: str) -> list:
    """Generate embedding for a search query."""
    client = get_openai_client()
    response = client.embeddings.create(
        model="text-embedding-ada-002",
        input=query,
    )
    return response.data[0].embedding


# ============================================================================
# SEARCH & BROWSE TOOLS
# ============================================================================

@tool
def search_photos_semantic(query: str, limit: int = 5) -> list:
    """
    Search for photos by meaning/vibe using semantic similarity.

    Use this when the customer describes what they're looking for in natural language,
    like "something calm and blue for my bedroom" or "dramatic sunset over the ocean".

    Args:
        query: Natural language description of what the customer wants
        limit: Maximum number of results to return (default 5)

    Returns:
        List of matching photos with details
    """
    try:
        photos = None

        # Try vector search first if OpenAI is configured and photos have embeddings
        try:
            from pgvector.django import CosineDistance

            has_embeddings = Photo.objects.filter(is_active=True, embedding__isnull=False).exists()
            if has_embeddings:
                query_embedding = generate_query_embedding(query)
                # Use pgvector cosine distance - lower is more similar
                photos = Photo.objects.filter(
                    is_active=True,
                    embedding__isnull=False
                ).select_related('collection').prefetch_related('variants').order_by(
                    CosineDistance('embedding', query_embedding)
                )[:limit]
        except Exception:
            # OpenAI unavailable or quota exceeded - fall back to text search
            pass

        # Fall back to text-based search with stricter matching
        if not photos or not photos.exists():
            # Common stop words to ignore
            stop_words = {
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
                'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',
                'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',
                'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need',
                'dare', 'ought', 'used', 'it', 'its', 'this', 'that', 'these', 'those',
                'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you',
                'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself',
                'she', 'her', 'hers', 'herself', 'they', 'them', 'their', 'theirs',
                'what', 'which', 'who', 'whom', 'when', 'where', 'why', 'how',
                'all', 'each', 'every', 'both', 'few', 'more', 'most', 'other', 'some',
                'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too',
                'very', 'just', 'also', 'now', 'here', 'there', 'then', 'once',
                'photo', 'photos', 'picture', 'pictures', 'image', 'images', 'print',
                'prints', 'art', 'artwork', 'looking', 'want', 'like', 'something',
                'show', 'find', 'get', 'see', 'need', 'any', 'please', 'thanks',
            }

            # Common synonyms to expand search
            synonyms = {
                'relaxing': ['relaxing', 'calming', 'peaceful', 'serene', 'tranquil'],
                'calm': ['calm', 'calming', 'peaceful', 'serene', 'tranquil'],
                'peaceful': ['peaceful', 'calming', 'serene', 'tranquil'],
                'ocean': ['ocean', 'sea', 'water', 'waves', 'coastal'],
                'sea': ['sea', 'ocean', 'water', 'waves', 'coastal'],
                'beach': ['beach', 'sand', 'shore', 'coastal', 'shoreline'],
                'sunset': ['sunset', 'golden', 'dusk', 'evening'],
                'sunrise': ['sunrise', 'dawn', 'morning'],
                'dramatic': ['dramatic', 'striking', 'bold', 'intense'],
                'blue': ['blue', 'azure', 'navy', 'cobalt', 'ocean blue', 'deep blue'],
                'green': ['green', 'emerald', 'seafoam', 'verdant'],
                'aerial': ['aerial', 'overhead', 'bird', 'drone', 'above'],
                'asian': ['asian', 'asia', 'vietnam', 'cambodia', 'thai', 'pagoda', 'temple'],
                'greek': ['greek', 'greece', 'santorini', 'mediterranean'],
                'hamptons': ['hamptons', 'hampton', 'montauk', 'long island'],
            }

            # Extract meaningful search terms
            words = query.lower().split()
            search_terms = [w for w in words if len(w) >= 3 and w not in stop_words]

            if search_terms:
                # Use AND logic - all terms must match somewhere
                # This prevents "asian photos" from matching everything with "photos"
                q_combined = Q()
                for word in search_terms:
                    # Expand word to include synonyms
                    words_to_search = synonyms.get(word, [word])

                    # Build OR query for this term and its synonyms
                    word_match = Q()
                    for search_word in words_to_search:
                        word_match |= (
                            Q(ai_description__icontains=search_word) |
                            Q(title__icontains=search_word) |
                            Q(ai_mood__icontains=search_word) |
                            Q(ai_subjects__icontains=search_word) |
                            Q(description__icontains=search_word) |
                            Q(location__icontains=search_word) |
                            Q(slug__icontains=search_word) |
                            Q(collection__name__icontains=search_word) |
                            Q(ai_colors__icontains=search_word)
                        )
                    q_combined &= word_match  # AND logic between different search terms

                photos = Photo.objects.filter(q_combined).filter(
                    is_active=True
                ).select_related('collection').prefetch_related('variants').distinct()[:limit]

        # Don't return random photos if nothing matches - let the agent know
        # This is better UX than showing unrelated results
        if not photos or not photos.exists():
            return []

        results = []
        for photo in photos[:limit]:
            price_range = photo.price_range
            results.append({
                'id': photo.id,
                'slug': photo.slug,
                'title': photo.title,
                'description': photo.ai_description or photo.description or f"Beautiful {photo.title} photography print",
                'colors': photo.ai_colors,
                'mood': photo.ai_mood,
                'subjects': photo.ai_subjects,
                'collection': photo.collection.name if photo.collection else None,
                'price_range': {
                    'min': float(price_range['min']) if price_range else None,
                    'max': float(price_range['max']) if price_range else None,
                } if price_range else None,
                'image_url': get_absolute_url(photo.image),
                'thumbnail_url': get_absolute_url(photo.thumbnail) or get_absolute_url(photo.image),
                'url': f'/photos/{photo.slug}',
            })

        return results

    except Exception as e:
        return {'error': str(e)}


@tool
def search_photos_filter(
    collection: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    material: Optional[str] = None,
    limit: int = 10
) -> list:
    """
    Filter photos by specific criteria like collection, price, or material.

    Use this when the customer has specific requirements like "photos under $1000"
    or "prints from the Montauk collection".

    Args:
        collection: Filter by collection slug (e.g., "aerial-photography", "shots-from-the-sea")
        min_price: Minimum price filter
        max_price: Maximum price filter
        material: Filter by material type ("paper" or "aluminum")
        limit: Maximum results to return

    Returns:
        List of matching photos with details
    """
    try:
        photos = Photo.objects.filter(is_active=True).select_related(
            'collection'
        ).prefetch_related('variants')

        if collection:
            photos = photos.filter(collection__slug__iexact=collection)

        # Price filtering requires joining with variants
        if min_price is not None or max_price is not None or material:
            variant_filters = Q(variants__is_available=True)

            if min_price is not None:
                variant_filters &= Q(variants__price__gte=min_price)
            if max_price is not None:
                variant_filters &= Q(variants__price__lte=max_price)
            if material:
                variant_filters &= Q(variants__material__iexact=material)

            photos = photos.filter(variant_filters).distinct()

        results = []
        for photo in photos[:limit]:
            price_range = photo.price_range
            results.append({
                'id': photo.id,
                'slug': photo.slug,
                'title': photo.title,
                'description': photo.ai_description or photo.description,
                'collection': photo.collection.name if photo.collection else None,
                'price_range': {
                    'min': float(price_range['min']) if price_range else None,
                    'max': float(price_range['max']) if price_range else None,
                } if price_range else None,
                'image_url': get_absolute_url(photo.image),
                'thumbnail_url': get_absolute_url(photo.thumbnail) or get_absolute_url(photo.image),
                'url': f'/photos/{photo.slug}',
            })

        return results

    except Exception as e:
        return {'error': str(e)}


@tool
def get_photo_details(photo_slug: str) -> dict:
    """
    Get full details for a specific photo including all available variants.

    Use this when you need to show a customer complete information about a photo,
    including all size and material options with prices.

    Args:
        photo_slug: The slug identifier for the photo

    Returns:
        Complete photo details with all variants
    """
    try:
        photo = Photo.objects.get(slug=photo_slug, is_active=True)

        variants = []
        for v in photo.variants.filter(is_available=True).order_by('price'):
            variants.append({
                'id': v.id,
                'size': v.size,
                'material': v.material,
                'material_display': v.get_material_display(),
                'price': float(v.price),
                'width_inches': v.width_inches,
                'height_inches': v.height_inches,
            })

        return {
            'id': photo.id,
            'slug': photo.slug,
            'title': photo.title,
            'description': photo.ai_description or photo.description,
            'location': photo.location,
            'colors': photo.ai_colors,
            'mood': photo.ai_mood,
            'subjects': photo.ai_subjects,
            'room_suggestions': photo.ai_room_suggestions,
            'collection': photo.collection.name if photo.collection else None,
            'image_url': get_absolute_url(photo.image),
            'thumbnail_url': get_absolute_url(photo.thumbnail) or get_absolute_url(photo.image),
            'url': f'/photos/{photo.slug}',
            'variants': variants,
        }

    except Photo.DoesNotExist:
        return {'error': f'Photo not found: {photo_slug}'}
    except Exception as e:
        return {'error': str(e)}


@tool
def get_collections() -> list:
    """
    List all available photo collections.

    Use this to show customers what collections are available or when they
    ask about different series/themes of photographs.

    Returns:
        List of all active collections with descriptions
    """
    try:
        from django.db.models import Count, Q

        collections = Collection.objects.filter(is_active=True).annotate(
            active_photo_count=Count('photos', filter=Q(photos__is_active=True))
        ).order_by('display_order')

        results = []
        for c in collections:
            results.append({
                'slug': c.slug,
                'name': c.name,
                'description': c.description,
                'photo_count': c.active_photo_count,
            })

        return results

    except Exception as e:
        return {'error': str(e)}


# ============================================================================
# CART TOOLS
# ============================================================================

@tool
def add_to_cart(photo_slug: str, variant_id: int, quantity: int = 1, cart_id: str = None) -> dict:
    """
    Add a print to the customer's shopping cart.

    Use this when a customer wants to add an item to their cart.
    Always confirm with the customer which size/material they want before adding.

    Args:
        photo_slug: The photo slug to add
        variant_id: The specific variant (size/material) ID
        quantity: Number to add (default 1)
        cart_id: Cart ID (will be provided by context)

    Returns:
        Updated cart summary
    """
    try:
        variant = ProductVariant.objects.get(id=variant_id, is_available=True)

        if not cart_id:
            return {'error': 'No cart available. Please refresh the page and try again.'}

        try:
            cart = Cart.objects.prefetch_related(
                'items__variant__photo', 'items__product'
            ).get(id=cart_id)
        except Cart.DoesNotExist:
            return {'error': 'Cart not found. Please refresh the page and try again.'}

        # Check if item already in cart
        cart_item, created = CartItem.objects.get_or_create(
            cart=cart,
            variant=variant,
            defaults={'quantity': quantity}
        )

        if not created:
            cart_item.quantity += quantity
            cart_item.save()

        return {
            'success': True,
            'message': f'Added {variant.photo.title} ({variant.display_name}) to cart',
            'cart_id': str(cart.id),
            'cart_total': float(cart.subtotal),
            'cart_item_count': cart.total_items,
        }

    except ProductVariant.DoesNotExist:
        return {'error': 'Variant not found or not available'}
    except Exception as e:
        return {'error': str(e)}


@tool
def get_cart(cart_id: str = None) -> dict:
    """
    Get the current cart contents.

    Use this to show customers what's in their cart or before checkout.

    Args:
        cart_id: Cart ID (will be provided by context)

    Returns:
        Cart contents with items and totals
    """
    try:
        if not cart_id:
            return {'items': [], 'total': 0, 'item_count': 0}

        try:
            cart = Cart.objects.prefetch_related(
                'items__variant__photo', 'items__product'
            ).get(id=cart_id)
        except Cart.DoesNotExist:
            return {'items': [], 'total': 0, 'item_count': 0}

        items = []
        for item in cart.items.all():
            if item.variant:
                items.append({
                    'id': item.id,
                    'photo_title': item.variant.photo.title,
                    'variant': item.variant.display_name,
                    'price': float(item.variant.price),
                    'quantity': item.quantity,
                    'subtotal': float(item.total_price),
                })
            elif item.product:
                items.append({
                    'id': item.id,
                    'product_title': item.product.title,
                    'price': float(item.product.price),
                    'quantity': item.quantity,
                    'subtotal': float(item.total_price),
                })

        return {
            'cart_id': str(cart.id),
            'items': items,
            'total': float(cart.subtotal),
            'item_count': cart.total_items,
            'free_shipping': cart.subtotal >= 500,
        }

    except Exception as e:
        return {'error': str(e)}


@tool
def remove_from_cart(item_id: int, cart_id: str = None) -> dict:
    """
    Remove an item from the cart.

    Args:
        item_id: The cart item ID to remove
        cart_id: Cart ID (will be provided by context)

    Returns:
        Updated cart summary
    """
    try:
        if not cart_id:
            return {'error': 'No cart found'}

        cart = Cart.objects.prefetch_related(
            'items__variant__photo', 'items__product'
        ).get(id=cart_id)
        item = CartItem.objects.get(id=item_id, cart=cart)
        item_name = str(item)
        item.delete()

        return {
            'success': True,
            'message': f'Removed {item_name} from cart',
            'cart_total': float(cart.subtotal),
            'cart_item_count': cart.total_items,
        }

    except (Cart.DoesNotExist, CartItem.DoesNotExist):
        return {'error': 'Item not found in cart'}
    except Exception as e:
        return {'error': str(e)}


@tool
def update_cart_item(item_id: int, quantity: int, cart_id: str = None) -> dict:
    """
    Update the quantity of a cart item.

    Args:
        item_id: The cart item ID to update
        quantity: New quantity (0 to remove)
        cart_id: Cart ID (will be provided by context)

    Returns:
        Updated cart summary
    """
    try:
        if not cart_id:
            return {'error': 'No cart found'}

        cart = Cart.objects.prefetch_related(
            'items__variant__photo', 'items__product'
        ).get(id=cart_id)
        item = CartItem.objects.get(id=item_id, cart=cart)

        if quantity <= 0:
            item.delete()
            message = 'Item removed from cart'
        else:
            item.quantity = quantity
            item.save()
            message = f'Updated quantity to {quantity}'

        return {
            'success': True,
            'message': message,
            'cart_total': float(cart.subtotal),
            'cart_item_count': cart.total_items,
        }

    except (Cart.DoesNotExist, CartItem.DoesNotExist):
        return {'error': 'Item not found in cart'}
    except Exception as e:
        return {'error': str(e)}


# ============================================================================
# CHECKOUT TOOLS
# ============================================================================

@tool
def start_checkout(cart_id: str = None) -> dict:
    """
    Help the customer proceed to checkout.

    Use this when the customer is ready to purchase. Directs them to the cart
    page where they can click "Proceed to Checkout" to complete payment.

    Args:
        cart_id: Cart ID (will be provided by context)

    Returns:
        Cart URL and instructions
    """
    try:
        if not cart_id:
            return {'error': 'No cart found'}

        cart = Cart.objects.prefetch_related(
            'items__variant__photo', 'items__product'
        ).get(id=cart_id)

        if cart.total_items == 0:
            return {'error': 'Cart is empty'}

        # Get cart items for summary
        items = []
        for item in cart.items.all():
            if item.variant:
                items.append(f"{item.variant.photo.title} ({item.variant.display_name})")
            elif item.product:
                items.append(item.product.title)

        return {
            'success': True,
            'cart_url': f"{settings.FRONTEND_URL}/cart",
            'cart_total': float(cart.subtotal),
            'item_count': cart.total_items,
            'items': items,
            'free_shipping': cart.subtotal >= 500,
            'message': 'Your cart is ready! Click the cart link or use the "Proceed to Checkout" button on the cart page to complete your purchase with Stripe.',
        }

    except Cart.DoesNotExist:
        return {'error': 'Cart not found'}
    except Exception as e:
        return {'error': str(e)}


# ============================================================================
# ORDER TOOLS
# ============================================================================

@tool
def track_order(order_number: str = None, email: str = None) -> dict:
    """
    Look up an order status.

    Use this when a customer wants to check on their order.
    They need to provide either an order number or their email.

    Args:
        order_number: The order number (e.g., "ORD-12345")
        email: Customer's email address

    Returns:
        Order status and details
    """
    try:
        from apps.orders.models import Order

        if not order_number or not email:
            return {'error': 'Please provide both an order number and email address to look up an order'}

        orders = Order.objects.filter(
            order_number__iexact=order_number,
            customer_email__iexact=email,
        )

        if not orders.exists():
            return {'error': 'No orders found with that information'}

        results = []
        for order in orders[:5]:  # Limit to 5 most recent
            results.append({
                'order_number': order.order_number,
                'status': order.status,
                'status_display': order.get_status_display(),
                'total': float(order.total),
                'created_at': order.created_at.isoformat(),
                'item_count': order.items.count(),
            })

        return {'orders': results}

    except Exception as e:
        return {'error': str(e)}


# ============================================================================
# GIFT CARD TOOLS
# ============================================================================

@tool
def check_gift_card(code: str) -> dict:
    """
    Check the balance of a gift card.

    Use this when a customer wants to check their gift card balance.

    Args:
        code: The gift card code

    Returns:
        Gift card balance and status
    """
    try:
        gift_card = GiftCard.objects.get(code__iexact=code.strip())

        if not gift_card.is_valid:
            # Return same generic message as web endpoint to prevent
            # enumeration of valid vs invalid/expired codes
            return {'valid': False, 'error': 'This gift card is not valid'}

        return {
            'valid': True,
            'balance': float(gift_card.remaining_balance),
            'message': f'Gift card has a balance of ${gift_card.remaining_balance:.2f}',
        }

    except GiftCard.DoesNotExist:
        # Same message as valid-but-expired to prevent code enumeration
        return {'valid': False, 'error': 'This gift card is not valid'}
    except Exception:
        return {'valid': False, 'error': 'This gift card is not valid'}


# ============================================================================
# MOCKUP TOOLS
# ============================================================================

@tool
def analyze_room_image(image_url: str) -> dict:
    """
    Analyze an uploaded room photo to detect walls for mockup placement.

    Use this when a customer uploads a photo of their room and wants to
    see how a print would look. This initiates the wall detection process.

    Args:
        image_url: URL of the uploaded room image

    Returns:
        Analysis ID and status, or helpful message if analysis unavailable
    """
    # Check if URL is HTTPS (required for Claude Vision API)
    if image_url.startswith('http://'):
        return {
            'status': 'unavailable',
            'message': 'Room visualization is available in production. For now, I can help you choose the right size based on your wall dimensions! What are the approximate dimensions of the wall where you want to hang the print?',
            'suggestion': 'Tell me your wall width and I can recommend the perfect print size.',
        }

    # SSRF protection: only fetch images from our own S3 bucket
    allowed_domain = settings.AWS_S3_CUSTOM_DOMAIN
    if allowed_domain and not image_url.startswith(f'https://{allowed_domain}/'):
        return {'error': 'Invalid image URL. Please upload your room photo using the upload button.'}

    try:
        import requests
        from django.core.files.base import ContentFile
        from apps.mockup.models import WallAnalysis
        from apps.mockup.tasks import analyze_wall_image

        # Download image from our S3 bucket
        response = requests.get(image_url, timeout=30)
        response.raise_for_status()

        # Determine file extension from content type
        content_type = response.headers.get('content-type', 'image/jpeg')
        ext = 'jpg'
        if 'png' in content_type:
            ext = 'png'
        elif 'webp' in content_type:
            ext = 'webp'

        # Create analysis record with downloaded image
        analysis = WallAnalysis.objects.create(status='pending')
        analysis.original_image.save(
            f'room_{analysis.id}.{ext}',
            ContentFile(response.content),
            save=True
        )

        # Trigger async analysis
        analyze_wall_image.delay(str(analysis.id))

        return {
            'analysis_id': str(analysis.id),
            'status': 'processing',
            'message': 'Analyzing your room photo. This may take a moment...',
        }

    except ImportError:
        # Mockup app not installed
        return {
            'status': 'unavailable',
            'message': 'I can see your room photo! While the automatic mockup feature is being set up, I can help you choose the right size. What are the approximate dimensions of that wall?',
        }
    except Exception as e:
        return {'error': str(e)}


@tool
def generate_mockup(
    analysis_id: str,
    photo_slug: str,
    size: str,
    material: str = "aluminum",
    variant_id: Optional[int] = None
) -> dict:
    """
    Generate a mockup showing a print on the analyzed wall.

    Use this after analyze_room_image to show how a specific print
    would look in the customer's space. This tool will wait for the
    wall analysis to complete if it's still processing.

    IMPORTANT: Use the `size` and `material` parameters to specify the variant.
    The size should match exactly what the customer requested (e.g., "20x30", "24x36", "40x60").
    The material should be "aluminum" or "paper" based on what the customer wants.

    Args:
        analysis_id: The wall analysis ID from analyze_room_image
        photo_slug: The photo to place on the wall
        size: The print size (e.g., "20x30", "24x36", "40x60" for aluminum, "11x14", "13x19" for paper)
        material: The material type - "aluminum" (default) or "paper"
        variant_id: (DEPRECATED) Optional variant ID - prefer using size and material instead

    Returns:
        Mockup data with wall image and placement info, or error
    """
    try:
        from apps.mockup.models import WallAnalysis

        analysis = WallAnalysis.objects.get(id=analysis_id)
        photo = Photo.objects.get(slug=photo_slug)

        # Find variant by size and material (preferred), or by variant_id (fallback)
        variant = None
        if size and material:
            # Normalize size format - handle both "20x30" and "30x20" formats
            size_normalized = size.strip().lower()
            # Try exact match first
            variant = ProductVariant.objects.filter(
                photo=photo,
                material__iexact=material.strip(),
                is_available=True
            ).filter(
                Q(size__icontains=size_normalized) |
                Q(size__icontains='x'.join(size_normalized.split('x')[::-1]))  # Try reversed dimensions
            ).first()

            # If no match, try matching just the dimensions in either order
            if not variant:
                size_parts = size_normalized.replace('"', '').replace("'", '').split('x')
                if len(size_parts) == 2:
                    try:
                        w, h = int(size_parts[0].strip()), int(size_parts[1].strip())
                        # Find variant where dimensions match in either order
                        for v in ProductVariant.objects.filter(photo=photo, material__iexact=material.strip(), is_available=True):
                            if (v.width_inches == w and v.height_inches == h) or (v.width_inches == h and v.height_inches == w):
                                variant = v
                                break
                    except ValueError:
                        pass

        # Fallback to variant_id if provided and size/material didn't find anything
        if not variant and variant_id:
            variant = ProductVariant.objects.get(id=variant_id)

        if not variant:
            # List available variants to help the agent
            available = ProductVariant.objects.filter(photo=photo, is_available=True)
            available_list = [f"{v.size} ({v.material})" for v in available]
            return {
                'error': f'Could not find a {material} variant in size {size} for "{photo.title}". Available options: {", ".join(available_list)}',
            }

        # Refresh to check current status without blocking
        analysis.refresh_from_db()

        if analysis.status == 'failed':
            return {
                'error': 'Wall detection failed. Please try uploading a different room photo.',
                'status': 'failed',
            }

        if analysis.status in ('pending', 'processing'):
            return {
                'status': 'processing',
                'analysis_id': str(analysis.id),
                'message': 'Wall analysis is still processing. The mockup tool on the page will show the result when ready. Please let the customer know to check the "See In Your Room" tool.',
            }

        # Return mockup data for frontend rendering
        return {
            'success': True,
            'type': 'mockup',  # Helps frontend identify this as mockup data
            'analysis': {
                'id': str(analysis.id),
                'wall_image_url': get_absolute_url(analysis.original_image),
                'wall_bounds': analysis.wall_bounds,
                'pixels_per_inch': analysis.pixels_per_inch,
                'confidence': analysis.confidence,
            },
            'photo': {
                'slug': photo.slug,
                'title': photo.title,
                'image_url': get_absolute_url(photo.image),
                'thumbnail_url': get_absolute_url(photo.thumbnail) or get_absolute_url(photo.image),
            },
            'variant': {
                'id': variant.id,
                'size': variant.size,
                'material': variant.material,
                'width_inches': variant.width_inches,
                'height_inches': variant.height_inches,
                'price': float(variant.price),
            },
            'message': f'Here\'s how "{photo.title}" ({variant.size}) would look in your space!',
        }

    except WallAnalysis.DoesNotExist:
        return {'error': 'Wall analysis not found. Please upload a room photo first.'}
    except Photo.DoesNotExist:
        return {'error': f'Photo not found: {photo_slug}'}
    except ProductVariant.DoesNotExist:
        return {'error': f'Size/variant not found: {variant_id}'}
    except Exception as e:
        return {'error': str(e)}


# ============================================================================
# INFO TOOLS
# ============================================================================

@tool
def get_sizing_info() -> str:
    """
    Get sizing guide and recommendations.

    Use this when customers ask about what size to get or how to choose.

    Returns:
        Sizing guide text
    """
    return """## Print Sizing Guide

### Size Recommendations by Space

**Above a Sofa or Couch:**
- Art should be 2/3 to 3/4 the width of the sofa
- 6ft sofa â†’ 30x40" or 40x60" print
- 8ft sectional â†’ 40x60" print

**Above a Bed:**
- Similar to sofa rule - roughly 2/3 the headboard width
- Queen bed â†’ 30x40" or 24x36"
- King bed â†’ 40x60"

**By Wall Size:**
- Small wall (under 5ft wide): 16x24" or 20x30"
- Medium wall (5-8ft wide): 24x36" or 30x40"
- Large wall (8ft+ wide): 40x60" makes a statement

### Available Sizes

**Paper Prints (Matted):**
- 11x14" in 16x20" mat - $175
- 13x19" in 18x24" mat - $250

**Aluminum Prints:**
- 16x24" - $675
- 20x30" - $995
- 24x36" - $1,350
- 30x40" - $1,850
- 30x45" - $2,150
- 40x60" - $3,400

### Tips
- When in doubt, go bigger - undersized art is a common mistake
- Gallery walls can use multiple smaller pieces
- Consider the viewing distance - larger prints for open spaces"""


# ============================================================================
# ALL TOOLS LIST
# ============================================================================

ALL_TOOLS = [
    search_photos_semantic,
    search_photos_filter,
    get_photo_details,
    get_collections,
    add_to_cart,
    get_cart,
    remove_from_cart,
    update_cart_item,
    start_checkout,
    track_order,
    check_gift_card,
    analyze_room_image,
    generate_mockup,
    get_sizing_info,
]


================================================
FILE: backend/apps/chat/prompts.py
================================================
"""
System prompts for the AI shopping agent.
"""

SYSTEM_PROMPT = """You are a helpful and warm shopping assistant for Matthew Raynor Photography, a fine art photography store specializing in stunning Hamptons aerial and coastal photography.

## Your Role
You help customers discover and purchase beautiful fine art prints. You're knowledgeable, friendly, and action-oriented. When a customer shows interest, you proactively offer to help them take the next step - adding to cart, showing a mockup, or answering questions.

## About the Store
Matthew Raynor is a photographer based in Hampton Bays, NY. His work captures the beauty of the East End of Long Island - aerial views of beaches, lighthouses, harbors, and coastal landscapes. Each photograph is available as a museum-quality print.

## Available Products

### Paper Prints (Matted, Open Edition)
Printed in-house on archival paper with acid-free matting:
- 11x14" (in 16x20" mat): $175
- 13x19" (in 18x24" mat): $250

### Aluminum Prints (Open Edition)
Dye-sublimated on premium aluminum. Scratch-resistant, UV-resistant, ready to hang:
- 16x24": $675
- 20x30": $995
- 24x36": $1,350
- 30x40": $1,850
- 30x45": $2,150
- 40x60": $3,400

## Shipping & Production
- Production time: 14-21 days (each print is made to order)
- Free shipping on orders over $500
- Ships from Hampton Bays, NY

## Gift Cards
- Gift cards are available for purchase: $100, $250, $500, $1000, $2500
- When a customer wants to check their gift card balance, use the `check_gift_card` tool with their code
- Gift cards can be applied at checkout

## How to Help Customers

### When they're browsing:
- Ask about their space (room type, wall size, existing decor)
- Suggest pieces based on mood, colors, or subjects they mention
- Use the semantic search to find photos matching their description

### When they find something they like:
- Offer to show it in their room (if they upload a photo)
- Explain size options and help them choose
- Add items to cart when they're ready

### When they have questions:
- Answer honestly about materials, sizes, and quality
- Help them understand what size works for their space
- Explain the difference between paper and aluminum prints

## Sizing Guidance
- Above a sofa: Art should be 2/3 to 3/4 the width of the sofa
- Above a bed: Similar rule - roughly 2/3 the headboard width
- Small wall (under 5ft wide): 16x24" or 20x30"
- Medium wall (5-8ft wide): 24x36" or 30x40"
- Large wall (8ft+ wide): 40x60" makes a statement

## Your Personality
- Warm and helpful, but not pushy
- Knowledgeable about art and interior design
- Excited to help people find the perfect piece
- Action-oriented - always offer concrete next steps
- Conversational and natural

## Important Guidelines
- CRITICAL: When a customer asks to SEE photos, SHOW photos, or describes what they're looking for - you MUST use the search_photos_semantic tool IMMEDIATELY. Do NOT ask clarifying questions first. Search first, then ask follow-ups if needed.
- ALWAYS use tools to take actions. Don't just talk about doing things - actually do them.
- When showing photos, include relevant details (title, sizes, prices)
- If a customer seems interested, offer to add to cart
- If they upload a room photo, immediately analyze it and offer to show mockups
- Keep responses concise but helpful
- Don't overwhelm with too many options at once (3-5 is good)
- CRITICAL: Make exactly ONE tool call per response. NEVER chain multiple searches or tool calls together. After using a tool, respond to the customer and wait for their next message.
- The collection includes TRAVEL photography too (Sedona, Greece, Cambodia, etc.), not just Hamptons coastal shots.

## Displaying Photos
IMPORTANT: The UI automatically shows clickable photo thumbnails from your tool results. Do NOT list every photo by name in your text response - that's redundant since thumbnails will appear below your message.

Write a SINGLE brief sentence like:
- "Here's what I found!"
- "Take a look at these options."

Keep your text response to 1-2 SHORT sentences maximum. The thumbnails will appear automatically below your message - let them do the work.

## When Search Returns No Results
If search_photos_semantic returns an empty list, it means no photos matched the query. Be honest:
- Don't pretend to show results that don't exist
- Suggest browsing collections instead: "I don't have photos matching that description, but you can browse all collections using get_collections"
- Offer to help them find something similar that IS in the collection
- The collection focuses on: Hamptons beaches, lighthouses, aerial views, and travel photography (Greece, Cambodia, Sedona)

## When Customer Uploads a Room Photo
When a customer uploads an image, you will see both the image AND the image URL in brackets like [Attached image URL: https://...].
IMMEDIATELY call `analyze_room_image` with that URL to detect walls. Do NOT ask for the URL - you already have it.
After analysis, offer to generate mockups with specific photos they're interested in.

## Generating Mockups
CRITICAL RULES - FOLLOW EXACTLY:
1. When a customer asks to "add [photo] to my wall", "show [photo] on my wall", "put [photo] in my room", or similar requests - you MUST call `generate_mockup` IMMEDIATELY in that same response. Do NOT just confirm you will do it - actually call the tool.
2. After `analyze_room_image` returns with a detected wall (analysis_id), if the customer mentioned a specific photo they want to see, call `generate_mockup` IMMEDIATELY in the same response - don't wait for them to ask again.
3. NEVER say "I'll generate a mockup" or "Let me show you" without actually calling the generate_mockup tool in the same response.

When using generate_mockup:
- You MUST specify both `size` and `material` parameters
- For aluminum prints, use sizes like: "16x24", "20x30", "24x36", "30x40", "30x45", "40x60"
- For paper prints, use sizes like: "11x14", "13x19"
- The `material` parameter should be exactly "aluminum" or "paper"
- If no material specified, default to "aluminum"
- Example: generate_mockup(analysis_id="...", photo_slug="viking-pride", size="20x30", material="aluminum")
- DO NOT guess variant IDs - always use the size and material parameters instead
- IMPORTANT: If a room photo has already been analyzed (you have an analysis_id), use generate_mockup directly - don't analyze the room again

Remember: You're not just answering questions - you're helping people find art they'll love for years to come. Be the helpful art consultant every customer deserves."""


================================================
FILE: backend/apps/mockup/models.py
================================================
import uuid
from django.db import models
from PIL import Image


class WallAnalysis(models.Model):
    """Stores wall analysis results for a user-uploaded image."""

    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('manual', 'Manual Selection'),
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # Original image
    original_image = models.ImageField(upload_to='mockups/walls/')
    original_width = models.PositiveIntegerField(null=True, blank=True)
    original_height = models.PositiveIntegerField(null=True, blank=True)

    # Processing status
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', db_index=True)
    error_message = models.TextField(blank=True)

    # ML Results (populated after processing)
    depth_map = models.ImageField(upload_to='mockups/depth/', blank=True, null=True)
    wall_mask = models.ImageField(upload_to='mockups/masks/', blank=True, null=True)
    wall_bounds = models.JSONField(null=True, blank=True)  # {top, bottom, left, right}
    confidence = models.FloatField(null=True, blank=True)

    # Scale information
    pixels_per_inch = models.FloatField(null=True, blank=True)
    wall_height_feet = models.FloatField(default=8.0)

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)

    # Session tracking (for anonymous users)
    session_key = models.CharField(max_length=40, blank=True, db_index=True)

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Wall Analysis'
        verbose_name_plural = 'Wall Analyses'

    def __str__(self):
        return f"WallAnalysis {self.id} ({self.status})"

    def save(self, *args, **kwargs):
        # Auto-populate image dimensions
        if self.original_image and not self.original_width:
            try:
                img = Image.open(self.original_image)
                self.original_width = img.width
                self.original_height = img.height
            except Exception:
                pass

        # Calculate pixels_per_inch based on wall bounds and height
        if self.wall_bounds and self.wall_height_feet:
            wall_height_px = self.wall_bounds.get('bottom', 0) - self.wall_bounds.get('top', 0)
            if wall_height_px > 0:
                wall_height_inches = self.wall_height_feet * 12
                self.pixels_per_inch = wall_height_px / wall_height_inches

        super().save(*args, **kwargs)


class SavedMockup(models.Model):
    """Stores a user-generated mockup image for sharing."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    wall_analysis = models.ForeignKey(
        WallAnalysis,
        on_delete=models.CASCADE,
        related_name='saved_mockups'
    )

    # Generated mockup image
    mockup_image = models.ImageField(upload_to='mockups/saved/')

    # Configuration that created this mockup
    config = models.JSONField(default=dict)
    # Expected structure:
    # {
    #     "prints": [
    #         {
    #             "photo_id": 123,
    #             "variant_id": 456,
    #             "position": {"x": 100, "y": 200},
    #             "scale": 1.0
    #         }
    #     ],
    #     "wall_height_feet": 8.0
    # }

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Saved Mockup'
        verbose_name_plural = 'Saved Mockups'

    def __str__(self):
        return f"SavedMockup {self.id}"

    @property
    def share_url(self):
        """Returns the shareable URL for this mockup."""
        from django.conf import settings
        return f"{settings.STORE_URL}/mockup/{self.id}"


================================================
FILE: backend/apps/mockup/views.py
================================================
import base64
import logging
import uuid

from django.core.files.base import ContentFile
from rest_framework import status
from rest_framework.parsers import MultiPartParser, JSONParser
from rest_framework.response import Response
from rest_framework.throttling import AnonRateThrottle
from rest_framework.views import APIView


class UploadRateThrottle(AnonRateThrottle):
    scope = 'uploads'

logger = logging.getLogger(__name__)

from .models import WallAnalysis, SavedMockup
from .serializers import (
    WallAnalysisSerializer,
    WallAnalysisUpdateSerializer,
    SavedMockupSerializer,
    SaveMockupRequestSerializer,
)


class UploadWallImageView(APIView):
    """Upload a wall image for analysis."""
    parser_classes = [MultiPartParser]
    authentication_classes = []
    permission_classes = []
    throttle_classes = [UploadRateThrottle]

    def post(self, request):
        image = request.FILES.get('image')
        if not image:
            return Response(
                {'error': 'No image provided'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Validate image size (10MB limit)
        if image.size > 10 * 1024 * 1024:
            return Response(
                {'error': 'Image too large (max 10MB)'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Validate content type
        allowed_types = ['image/jpeg', 'image/png', 'image/webp']
        if image.content_type not in allowed_types:
            return Response(
                {'error': 'Invalid image type. Allowed: JPEG, PNG, WebP'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Get session key for anonymous tracking
        if not request.session.session_key:
            request.session.create()
        session_key = request.session.session_key or ''

        # Create analysis record
        analysis = WallAnalysis.objects.create(
            original_image=image,
            session_key=session_key,
            status='pending'
        )

        # Queue Celery task for ML processing
        try:
            from .tasks import analyze_wall_image
            logger.info(f'Queuing wall analysis task for {analysis.id}')
            analyze_wall_image.delay(str(analysis.id))
            logger.info(f'Task queued successfully for {analysis.id}')
        except Exception as e:
            # If Celery isn't available, fall back to manual mode
            logger.error(f'Failed to queue Celery task: {type(e).__name__}: {e}')
            analysis.status = 'manual'
            analysis.error_message = f'ML processing not available: {type(e).__name__}. Please select wall manually.'
            # Set default bounds (full image)
            if analysis.original_width and analysis.original_height:
                analysis.wall_bounds = {
                    'top': 0,
                    'bottom': analysis.original_height,
                    'left': 0,
                    'right': analysis.original_width,
                }
            analysis.save()

        return Response(
            WallAnalysisSerializer(analysis, context={'request': request}).data,
            status=status.HTTP_201_CREATED
        )


class WallAnalysisDetailView(APIView):
    """Get or update wall analysis."""
    parser_classes = [JSONParser]
    authentication_classes = []
    permission_classes = []

    def get(self, request, analysis_id):
        """Get analysis status and results."""
        try:
            analysis = WallAnalysis.objects.get(id=analysis_id)
        except WallAnalysis.DoesNotExist:
            return Response(
                {'error': 'Analysis not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        return Response(WallAnalysisSerializer(analysis, context={'request': request}).data)

    def patch(self, request, analysis_id):
        """Update analysis (manual bounds, height adjustment)."""
        try:
            analysis = WallAnalysis.objects.get(id=analysis_id)
        except WallAnalysis.DoesNotExist:
            return Response(
                {'error': 'Analysis not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        serializer = WallAnalysisUpdateSerializer(
            analysis,
            data=request.data,
            partial=True
        )

        if serializer.is_valid():
            serializer.save()
            return Response(WallAnalysisSerializer(analysis, context={'request': request}).data)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class SaveMockupView(APIView):
    """Save a generated mockup image."""
    parser_classes = [JSONParser]
    authentication_classes = []
    permission_classes = []

    def post(self, request):
        serializer = SaveMockupRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        analysis_id = serializer.validated_data['analysis_id']
        mockup_image_data = serializer.validated_data['mockup_image']
        config = serializer.validated_data.get('config', {})

        # Get the analysis
        try:
            analysis = WallAnalysis.objects.get(id=analysis_id)
        except WallAnalysis.DoesNotExist:
            return Response(
                {'error': 'Analysis not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        # Decode base64 image
        try:
            # Remove data URL prefix (e.g., "data:image/jpeg;base64,")
            if ',' in mockup_image_data:
                header, encoded = mockup_image_data.split(',', 1)
            else:
                encoded = mockup_image_data

            # Determine format from header
            if 'png' in header.lower():
                ext = 'png'
            else:
                ext = 'jpg'

            image_data = base64.b64decode(encoded)
            image_file = ContentFile(image_data, name=f'mockup_{uuid.uuid4()}.{ext}')
        except Exception as e:
            return Response(
                {'error': f'Invalid image data: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Create saved mockup
        mockup = SavedMockup.objects.create(
            wall_analysis=analysis,
            mockup_image=image_file,
            config=config,
        )

        return Response(
            SavedMockupSerializer(mockup, context={'request': request}).data,
            status=status.HTTP_201_CREATED
        )


class MockupDetailView(APIView):
    """Get a saved mockup for viewing/sharing."""
    authentication_classes = []
    permission_classes = []

    def get(self, request, mockup_id):
        try:
            mockup = SavedMockup.objects.select_related('wall_analysis').get(id=mockup_id)
        except SavedMockup.DoesNotExist:
            return Response(
                {'error': 'Mockup not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        return Response(SavedMockupSerializer(mockup, context={'request': request}).data)


================================================
FILE: backend/apps/mockup/serializers.py
================================================
from rest_framework import serializers
from .models import WallAnalysis, SavedMockup


class WallAnalysisSerializer(serializers.ModelSerializer):
    """Serializer for WallAnalysis model."""

    class Meta:
        model = WallAnalysis
        fields = [
            'id',
            'status',
            'original_image',
            'original_width',
            'original_height',
            'depth_map',
            'wall_mask',
            'wall_bounds',
            'confidence',
            'pixels_per_inch',
            'wall_height_feet',
            'error_message',
            'created_at',
            'completed_at',
        ]
        read_only_fields = [
            'id',
            'status',
            'original_image',
            'original_width',
            'original_height',
            'depth_map',
            'wall_mask',
            'confidence',
            'pixels_per_inch',
            'error_message',
            'created_at',
            'completed_at',
        ]


class WallAnalysisUpdateSerializer(serializers.ModelSerializer):
    """Serializer for updating WallAnalysis (manual bounds, height adjustment)."""

    class Meta:
        model = WallAnalysis
        fields = ['wall_bounds', 'wall_height_feet']

    def update(self, instance, validated_data):
        # Update wall_bounds if provided
        if 'wall_bounds' in validated_data:
            instance.wall_bounds = validated_data['wall_bounds']
            instance.status = 'manual'

        # Update wall_height_feet if provided
        if 'wall_height_feet' in validated_data:
            instance.wall_height_feet = validated_data['wall_height_feet']

        instance.save()
        return instance


class SavedMockupSerializer(serializers.ModelSerializer):
    """Serializer for SavedMockup model."""
    share_url = serializers.CharField(read_only=True)
    wall_analysis_id = serializers.UUIDField(write_only=True, required=False)

    class Meta:
        model = SavedMockup
        fields = [
            'id',
            'wall_analysis',
            'wall_analysis_id',
            'mockup_image',
            'config',
            'share_url',
            'created_at',
        ]
        read_only_fields = ['id', 'wall_analysis', 'share_url', 'created_at']


class SaveMockupRequestSerializer(serializers.Serializer):
    """Serializer for saving a new mockup."""
    analysis_id = serializers.UUIDField()
    mockup_image = serializers.CharField()  # Base64 encoded image
    config = serializers.JSONField(required=False, default=dict)

    def validate_mockup_image(self, value):
        # Check if it's a valid base64 data URL
        if not value.startswith('data:image/'):
            raise serializers.ValidationError('Invalid image format. Expected base64 data URL.')
        return value


================================================
FILE: backend/apps/mockup/urls.py
================================================
from django.urls import path
from . import views

app_name = 'mockup'

urlpatterns = [
    # Wall analysis
    path('analyze/', views.UploadWallImageView.as_view(), name='upload'),
    path('analyze/<uuid:analysis_id>/', views.WallAnalysisDetailView.as_view(), name='analysis-detail'),

    # Save/retrieve mockups
    path('save/', views.SaveMockupView.as_view(), name='save'),
    path('<uuid:mockup_id>/', views.MockupDetailView.as_view(), name='mockup-detail'),
]


================================================
FILE: backend/apps/mockup/admin.py
================================================
from datetime import timedelta

from django.contrib import admin, messages
from django.utils import timezone
from django.utils.html import format_html

from .models import WallAnalysis, SavedMockup


@admin.action(description='Delete analyses older than 24 hours')
def cleanup_old_analyses_24h(modeladmin, request, queryset):
    cutoff = timezone.now() - timedelta(hours=24)
    old_analyses = WallAnalysis.objects.filter(created_at__lt=cutoff)
    count = old_analyses.count()
    for analysis in old_analyses:
        analysis.delete()  # Triggers django-cleanup to delete S3 files
    messages.success(request, f'Deleted {count} analyses older than 24 hours.')


@admin.action(description='Delete analyses older than 1 hour')
def cleanup_old_analyses_1h(modeladmin, request, queryset):
    cutoff = timezone.now() - timedelta(hours=1)
    old_analyses = WallAnalysis.objects.filter(created_at__lt=cutoff)
    count = old_analyses.count()
    for analysis in old_analyses:
        analysis.delete()
    messages.success(request, f'Deleted {count} analyses older than 1 hour.')


@admin.action(description='Delete ALL wall analyses')
def cleanup_all_analyses(modeladmin, request, queryset):
    count = WallAnalysis.objects.count()
    for analysis in WallAnalysis.objects.all():
        analysis.delete()
    messages.success(request, f'Deleted all {count} wall analyses.')


@admin.register(WallAnalysis)
class WallAnalysisAdmin(admin.ModelAdmin):
    list_display = ['id', 'status_badge', 'confidence_display', 'wall_height_feet', 'created_at']
    list_filter = ['status', 'created_at']
    readonly_fields = ['id', 'created_at', 'completed_at', 'original_width', 'original_height']
    search_fields = ['id', 'session_key']
    ordering = ['-created_at']
    actions = [cleanup_old_analyses_1h, cleanup_old_analyses_24h, cleanup_all_analyses]

    def status_badge(self, obj):
        colors = {
            'pending': '#f59e0b',
            'processing': '#3b82f6',
            'completed': '#10b981',
            'manual': '#8b5cf6',
            'failed': '#ef4444',
        }
        color = colors.get(obj.status, '#6b7280')
        return format_html(
            '<span style="background-color: {}; color: white; padding: 3px 8px; '
            'border-radius: 4px; font-size: 11px;">{}</span>',
            color, obj.status.upper()
        )
    status_badge.short_description = 'Status'

    def confidence_display(self, obj):
        if obj.confidence is None:
            return '-'
        pct = obj.confidence * 100
        color = '#10b981' if pct >= 50 else '#f59e0b' if pct >= 30 else '#ef4444'
        return format_html(
            '<span style="color: {};">{:.0f}%</span>',
            color, pct
        )
    confidence_display.short_description = 'Confidence'


@admin.register(SavedMockup)
class SavedMockupAdmin(admin.ModelAdmin):
    list_display = ['id', 'wall_analysis', 'created_at', 'view_mockup']
    list_filter = ['created_at']
    readonly_fields = ['id', 'created_at']
    search_fields = ['id']
    ordering = ['-created_at']

    def view_mockup(self, obj):
        if obj.mockup_image:
            return format_html(
                '<a href="{}" target="_blank">View</a>',
                obj.mockup_image.url
            )
        return '-'
    view_mockup.short_description = 'Mockup'


================================================
FILE: backend/apps/mockup/tasks.py
================================================
import logging
import os
import tempfile
from datetime import timedelta

from celery import shared_task
from django.utils import timezone

logger = logging.getLogger(__name__)


@shared_task
def cleanup_old_wall_analyses(hours: int = 24):
    """
    Delete WallAnalysis records older than specified hours.

    Deletes SavedMockup records individually first to ensure their S3 files
    are cleaned up (cascade SQL DELETE skips Django's file deletion).

    Args:
        hours: Delete records older than this many hours (default 24)

    Returns:
        Number of records deleted
    """
    from .models import WallAnalysis, SavedMockup

    cutoff = timezone.now() - timedelta(hours=hours)
    # Exclude analyses that have saved mockups (shared links should persist)
    old_analyses = WallAnalysis.objects.filter(
        created_at__lt=cutoff,
        saved_mockups__isnull=True,
    )

    count = old_analyses.count()
    if count > 0:
        # Delete SavedMockups individually first so their S3 files are cleaned up
        # (cascade SQL DELETE doesn't trigger Django storage file deletion)
        mockups = SavedMockup.objects.filter(wall_analysis__in=old_analyses)
        for mockup in mockups:
            try:
                mockup.mockup_image.delete(save=False)
                mockup.delete()
            except Exception as e:
                logger.error(f'Failed to delete SavedMockup {mockup.id}: {e}')

        # Delete WallAnalysis records one by one to clean up their S3 files
        for analysis in old_analyses:
            try:
                analysis.delete()
            except Exception as e:
                logger.error(f'Failed to delete WallAnalysis {analysis.id}: {e}')

        logger.info(f'Cleaned up {count} old WallAnalysis records')

    return count


@shared_task(bind=True, soft_time_limit=30, time_limit=45)
def analyze_wall_image(self, analysis_id: str):
    """
    Celery task to analyze a wall image using ML.

    Steps:
    1. Load the image
    2. Run MiDaS depth estimation
    3. Detect wall plane using RANSAC
    4. Save results to database
    """
    from .models import WallAnalysis

    logger.info(f'Starting wall analysis for {analysis_id}')

    try:
        analysis = WallAnalysis.objects.get(id=analysis_id)
    except WallAnalysis.DoesNotExist:
        logger.error(f'Analysis {analysis_id} not found')
        return {'error': 'Analysis not found'}

    # Update status to processing
    analysis.status = 'processing'
    analysis.save(update_fields=['status'])

    # Track temp file for cleanup
    temp_image_path = None

    try:
        # Import ML modules
        from .ml.depth import run_depth_estimation
        from .ml.wall import detect_wall_plane

        # Download image from S3 to temp file (required for S3 storage)
        # .path doesn't work with S3, so we use .open() and write to temp file
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
            with analysis.original_image.open('rb') as img_file:
                tmp.write(img_file.read())
            temp_image_path = tmp.name

        logger.info(f'Image downloaded to temp file')
        image_path = temp_image_path

        # Run depth estimation
        depth_map = run_depth_estimation(image_path)

        if depth_map is None:
            raise Exception('Depth estimation failed')

        # Detect wall plane
        wall_data = detect_wall_plane(
            depth_map,
            image_width=analysis.original_width,
            image_height=analysis.original_height
        )

        if wall_data['confidence'] >= 0.3:
            # Successful detection
            analysis.status = 'completed'
            analysis.wall_bounds = wall_data['bounds']
            analysis.confidence = wall_data['confidence']

            # Save depth map image if available
            if 'depth_image_path' in wall_data:
                from django.core.files import File
                with open(wall_data['depth_image_path'], 'rb') as f:
                    analysis.depth_map.save(
                        f'depth_{analysis_id}.png',
                        File(f),
                        save=False
                    )
        else:
            # Low confidence - fall back to manual
            analysis.status = 'manual'
            analysis.confidence = wall_data['confidence']
            analysis.error_message = 'Could not detect wall with high confidence. Please select manually.'
            # Set default bounds (full image)
            analysis.wall_bounds = {
                'top': 0,
                'bottom': analysis.original_height,
                'left': 0,
                'right': analysis.original_width,
            }

        analysis.completed_at = timezone.now()
        analysis.save()

        logger.info(f'Wall analysis completed: status={analysis.status}, confidence={analysis.confidence}')

        return {
            'status': analysis.status,
            'confidence': analysis.confidence,
        }

    except Exception as e:
        logger.error(f'ML processing failed for {analysis_id}: {str(e)}')
        # ML processing failed
        analysis.status = 'manual'
        analysis.error_message = f'ML processing failed: {str(e)}. Please select wall manually.'
        # Set default bounds (full image)
        if analysis.original_width and analysis.original_height:
            analysis.wall_bounds = {
                'top': 0,
                'bottom': analysis.original_height,
                'left': 0,
                'right': analysis.original_width,
            }
        analysis.completed_at = timezone.now()
        analysis.save()

        return {
            'status': 'manual',
            'error': str(e),
        }

    finally:
        # Clean up temp file
        if temp_image_path and os.path.exists(temp_image_path):
            try:
                os.unlink(temp_image_path)
            except Exception:
                pass


### FRONTEND ###
================================================
FILE: frontend/package.json
================================================
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "fabric": "^7.1.0",
    "next": "16.1.1",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-markdown": "^10.1.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.1.1",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


================================================
FILE: frontend/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactCompiler: true,
  images: {
    // Disable private IP blocking for local Docker development
    unoptimized: process.env.NODE_ENV === 'development',
    // Enable optimization - serves WebP/AVIF at appropriate sizes
    // Original quality preserved, just smarter delivery
    formats: ['image/avif', 'image/webp'],
    // High quality for photography - visually lossless
    // quality is set per-image via the Image component, default is 75
    // We'll use 90 on individual images for photography
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'matthewraynor-store.s3.amazonaws.com',
      },
      {
        protocol: 'https',
        hostname: 'matthewraynor-store.s3.us-east-2.amazonaws.com',
      },
      {
        protocol: 'http',
        hostname: 'localhost',
        port: '7974',
      },
      {
        protocol: 'http',
        hostname: 'backend',
        port: '7974',
      },
    ],
  },
};

export default nextConfig;


================================================
FILE: frontend/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}


================================================
FILE: frontend/netlify.toml
================================================
[build]
  command = "npm run build"
  publish = ".next"

[build.environment]
  NEXT_PUBLIC_API_URL = "https://store-api.matthewraynor.com/api"
  INTERNAL_API_URL = "https://store-api.matthewraynor.com/api"

[[plugins]]
  package = "@netlify/plugin-nextjs"


================================================
FILE: frontend/src/lib/api.ts
================================================
// Server-side uses internal Docker network, client-side uses browser-accessible URL
const getApiUrl = () => {
  if (typeof window === 'undefined') {
    // Server-side: use Docker service name
    return process.env.INTERNAL_API_URL || 'http://backend:7974/api';
  }
  // Client-side: use browser-accessible URL
  return process.env.NEXT_PUBLIC_API_URL || 'http://localhost:7974/api';
};

async function fetchApi<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${getApiUrl()}${endpoint}`;
  const isServer = typeof window === 'undefined';

  const res = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
    // Only include credentials on client-side requests
    ...(isServer ? { cache: 'no-store' } : { credentials: 'include' }),
  });

  if (!res.ok) {
    const error = await res.json().catch(() => ({ error: 'Request failed' }));
    throw new Error(error.error || `HTTP ${res.status}`);
  }

  return res.json();
}

// Collections
export async function getCollections() {
  return fetchApi<{ results: import('@/types').Collection[] }>('/collections/');
}

export async function getCollection(slug: string) {
  return fetchApi<import('@/types').Collection & { photos: import('@/types').Photo[] }>(
    `/collections/${slug}/`
  );
}

// Photos
export async function getPhotos(params?: Record<string, string>) {
  const query = params ? `?${new URLSearchParams(params)}` : '';
  return fetchApi<{ results: import('@/types').Photo[] }>(`/photos/${query}`);
}

export async function getFeaturedPhotos() {
  return fetchApi<import('@/types').Photo[]>('/photos/featured/');
}

export async function getPhoto(slug: string) {
  return fetchApi<import('@/types').Photo>(`/photos/${slug}/`);
}

// Products
export async function getProducts(params?: Record<string, string>) {
  const query = params ? `?${new URLSearchParams(params)}` : '';
  return fetchApi<{ results: import('@/types').Product[] }>(`/products/${query}`);
}

export async function getProduct(slug: string) {
  return fetchApi<import('@/types').Product>(`/products/${slug}/`);
}

// Cart
export async function getCart() {
  return fetchApi<import('@/types').Cart>('/cart/');
}

export async function addToCart(variantId: number, quantity: number = 1) {
  return fetchApi<import('@/types').CartItem>('/cart/items/', {
    method: 'POST',
    body: JSON.stringify({ variant_id: variantId, quantity }),
  });
}

export async function addProductToCart(productId: number, quantity: number = 1) {
  return fetchApi<import('@/types').CartItem>('/cart/items/', {
    method: 'POST',
    body: JSON.stringify({ product_id: productId, quantity }),
  });
}

export async function updateCartItem(itemId: number, quantity: number) {
  return fetchApi<import('@/types').CartItem>(`/cart/items/${itemId}/`, {
    method: 'PUT',
    body: JSON.stringify({ quantity }),
  });
}

export async function removeCartItem(itemId: number) {
  return fetchApi<void>(`/cart/items/${itemId}/`, {
    method: 'DELETE',
  });
}

export async function clearCart() {
  return fetchApi<void>('/cart/', {
    method: 'DELETE',
  });
}

// Checkout
export async function createCheckoutSession(giftCardCode?: string) {
  return fetchApi<{ checkout_url: string; session_id: string }>('/checkout/', {
    method: 'POST',
    body: JSON.stringify({ gift_card_code: giftCardCode }),
  });
}

export async function getOrderBySession(sessionId: string) {
  return fetchApi<import('@/types').Order>(`/order/?session_id=${sessionId}`);
}

// Newsletter
export async function subscribeNewsletter(email: string, name?: string) {
  return fetchApi<{ success: boolean; message: string }>('/newsletter/subscribe/', {
    method: 'POST',
    body: JSON.stringify({ email, name }),
  });
}

// Gift Cards
export async function purchaseGiftCard(data: {
  amount: number;
  recipient_email: string;
  recipient_name?: string;
  purchaser_email: string;
  purchaser_name?: string;
  message?: string;
}) {
  return fetchApi<{ checkout_url: string; session_id: string }>('/gift-cards/purchase/', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

export async function checkGiftCard(code: string) {
  return fetchApi<import('@/types').GiftCardCheck>('/gift-cards/check/', {
    method: 'POST',
    body: JSON.stringify({ code }),
  });
}

// Contact
export async function submitContactForm(data: {
  name: string;
  email: string;
  subject?: string;
  message: string;
}) {
  return fetchApi<{ success: boolean }>('/contact/', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

// Order Tracking
export async function trackOrder(email: string, orderNumber: string) {
  return fetchApi<{
    order_number: string;
    status: string;
    tracking_number?: string;
    tracking_carrier?: string;
    tracking_url?: string;
  }>('/orders/track/', {
    method: 'POST',
    body: JSON.stringify({ email, order_number: orderNumber }),
  });
}

// Wall Mockup
export async function uploadWallImage(file: File): Promise<import('@/types').WallAnalysis> {
  const formData = new FormData();
  formData.append('image', file);

  const url = `${getApiUrl()}/mockup/analyze/`;
  const res = await fetch(url, {
    method: 'POST',
    body: formData,
    credentials: 'include',
  });

  if (!res.ok) {
    const error = await res.json().catch(() => ({ error: 'Upload failed' }));
    throw new Error(error.error || `HTTP ${res.status}`);
  }

  return res.json();
}

export async function getWallAnalysis(analysisId: string) {
  return fetchApi<import('@/types').WallAnalysis>(`/mockup/analyze/${analysisId}/`);
}

export async function updateWallAnalysis(
  analysisId: string,
  data: {
    wall_bounds?: { top: number; bottom: number; left: number; right: number };
    wall_height_feet?: number;
  }
) {
  return fetchApi<import('@/types').WallAnalysis>(`/mockup/analyze/${analysisId}/`, {
    method: 'PATCH',
    body: JSON.stringify(data),
  });
}

export async function saveMockup(data: {
  analysis_id: string;
  mockup_image: string;
  config: import('@/types').MockupConfig;
}) {
  return fetchApi<import('@/types').SavedMockup>('/mockup/save/', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

export async function getMockup(mockupId: string) {
  return fetchApi<import('@/types').SavedMockup>(`/mockup/${mockupId}/`);
}

export async function pollWallAnalysis(
  analysisId: string,
  onProgress?: (status: string) => void,
  maxAttempts = 30,
  intervalMs = 1000
): Promise<import('@/types').WallAnalysis> {
  for (let i = 0; i < maxAttempts; i++) {
    const analysis = await getWallAnalysis(analysisId);
    if (onProgress) onProgress(analysis.status);

    if (['completed', 'failed', 'manual'].includes(analysis.status)) {
      return analysis;
    }

    await new Promise((resolve) => setTimeout(resolve, intervalMs));
  }

  throw new Error('Analysis timed out');
}

// Chat API
export interface ChatMessage {
  id?: number;
  role: 'user' | 'assistant' | 'tool';
  content: string;
  image_url?: string;
  tool_calls?: Array<{ id: string; name: string; args: Record<string, unknown> }>;
}

export interface ChatChunk {
  type: 'conversation_id' | 'text' | 'tool_use' | 'tool_result' | 'error' | 'done';
  id?: string;
  content?: string;
  tool?: string;
  args?: Record<string, unknown>;
  result?: unknown;
  message?: string;
}

export async function* streamChat(
  message: string,
  conversationId?: string,
  imageUrl?: string,
  cartId?: string
): AsyncGenerator<ChatChunk> {
  const url = `${getApiUrl()}/chat/`;

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      message,
      conversation_id: conversationId,
      image_url: imageUrl,
      cart_id: cartId,
    }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Chat request failed' }));
    yield { type: 'error', message: error.error || `HTTP ${response.status}` };
    return;
  }

  const reader = response.body?.getReader();
  if (!reader) {
    yield { type: 'error', message: 'No response body' };
    return;
  }

  const decoder = new TextDecoder();
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      // Process any remaining data in buffer
      if (buffer.trim()) {
        const lines = buffer.split('\n');
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              yield data as ChatChunk;
            } catch {
              // Skip malformed JSON
            }
          }
        }
      }
      break;
    }

    buffer += decoder.decode(value, { stream: true });

    // Process complete SSE messages
    const lines = buffer.split('\n');
    buffer = lines.pop() || ''; // Keep incomplete line in buffer

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        try {
          const data = JSON.parse(line.slice(6));
          yield data as ChatChunk;
        } catch {
          // Skip malformed JSON
        }
      }
    }
  }
}

export async function getChatHistory(conversationId: string) {
  return fetchApi<{
    conversation_id: string;
    messages: ChatMessage[];
    created_at: string;
  }>(`/chat/history/${conversationId}/`);
}

export async function uploadChatImage(file: File): Promise<{ url: string }> {
  const formData = new FormData();
  formData.append('image', file);

  const url = `${getApiUrl()}/chat/upload-image/`;
  const res = await fetch(url, {
    method: 'POST',
    body: formData,
    credentials: 'include',
  });

  if (!res.ok) {
    const error = await res.json().catch(() => ({ error: 'Upload failed' }));
    throw new Error(error.error || `HTTP ${res.status}`);
  }

  return res.json();
}


================================================
FILE: frontend/src/types/index.ts
================================================
export interface Collection {
  id: number;
  name: string;
  slug: string;
  description: string;
  cover_image: string | null;
  is_limited_edition: boolean;
  photo_count: number;
}

export interface Photo {
  id: number;
  title: string;
  slug: string;
  collection_name: string;
  collection_slug: string;
  image: string;
  thumbnail: string | null;
  description: string;
  location: string;
  location_tag: string;
  orientation: string;
  orientation_display: string;
  is_featured: boolean;
  price_range: { min: number; max: number } | null;
  variants?: ProductVariant[];
  created_at: string;
  aspect_ratio?: number;
}

export interface ProductVariant {
  id: number;
  size: string;
  material: 'paper' | 'aluminum';
  price: string;
  width_inches: number;
  height_inches: number;
  is_available: boolean;
  display_name: string;
}

export interface CartItem {
  id: number;
  item_type: 'variant' | 'product';
  variant?: ProductVariant & {
    photo: {
      id: number;
      title: string;
      slug: string;
      thumbnail: string | null;
    };
  };
  product?: {
    id: number;
    title: string;
    slug: string;
    image: string;
    product_type: string;
  };
  quantity: number;
  unit_price: string;
  total_price: string;
  title: string;
  description: string;
  image: string | null;
}

export interface Cart {
  id: string;
  items: CartItem[];
  total_items: number;
  subtotal: string;
  created_at: string;
  updated_at: string;
}

export interface Order {
  order_number: string;
  customer_email: string;
  total: string;
  status: string;
}

export interface GiftCardCheck {
  valid: boolean;
  balance?: string;
  expires_at?: string;
  error?: string;
}

export interface Product {
  id: number;
  title: string;
  slug: string;
  product_type: 'book' | 'merch';
  product_type_display: string;
  description: string;
  long_description?: string;
  image: string;
  additional_images?: string[];
  price: string;
  compare_at_price?: string;
  is_in_stock: boolean;
  is_on_sale: boolean;
  is_featured: boolean;
  author?: string;
  publisher?: string;
  publication_year?: number;
  pages?: number;
  dimensions?: string;
  isbn?: string;
  stock_quantity?: number;
}

export interface ApiResponse<T> {
  count?: number;
  next?: string | null;
  previous?: string | null;
  results?: T[];
}

// Wall Mockup Types
export interface WallAnalysis {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed' | 'manual';
  original_image: string;
  original_width: number | null;
  original_height: number | null;
  depth_map: string | null;
  wall_mask: string | null;
  wall_bounds: {
    top: number;
    bottom: number;
    left: number;
    right: number;
  } | null;
  confidence: number | null;
  pixels_per_inch: number | null;
  wall_height_feet: number;
  error_message: string;
  created_at: string;
  completed_at: string | null;
}

export interface SavedMockup {
  id: string;
  wall_analysis: string;
  mockup_image: string;
  config: MockupConfig;
  share_url: string;
  created_at: string;
}

export interface MockupConfig {
  prints: Array<{
    photo_id: number;
    variant_id: number;
    position: { x: number; y: number };
    scale?: number;
  }>;
  wall_height_feet: number;
}

export interface MockupPrint {
  id: string;
  photo: Photo;
  variant: ProductVariant;
  position: { x: number; y: number };
}


================================================
FILE: frontend/src/app/layout.tsx
================================================
import type { Metadata, Viewport } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Header from "@/components/Header";
import Footer from "@/components/Footer";
import { ChatWidget } from "@/components/chat";
import { CartProvider } from "@/contexts/CartContext";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
});

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  viewportFit: "cover",
};

export const metadata: Metadata = {
  title: "Matthew Raynor Photography | Fine Art Prints of the Hamptons",
  description: "Museum-quality fine art photography prints of the Hamptons. Limited edition aluminum and archival paper prints.",
  keywords: ["Hamptons photography", "fine art prints", "beach photography", "landscape photography", "Matthew Raynor"],
  openGraph: {
    title: "Matthew Raynor Photography",
    description: "Museum-quality fine art photography prints of the Hamptons. Limited edition aluminum and archival paper prints.",
    url: "https://store.matthewraynor.com",
    siteName: "Matthew Raynor Photography",
    type: "website",
    locale: "en_US",
  },
  twitter: {
    card: "summary_large_image",
    title: "Matthew Raynor Photography",
    description: "Museum-quality fine art photography prints of the Hamptons.",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${inter.variable} font-sans antialiased bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100`}>
        <CartProvider>
          <Header />
          <main className="min-h-screen">
            {children}
          </main>
          <Footer />
          <ChatWidget />
        </CartProvider>
      </body>
    </html>
  );
}


================================================
FILE: frontend/src/app/page.tsx
================================================
import Link from 'next/link';
import Image from 'next/image';
import { getFeaturedPhotos, getCollections } from '@/lib/api';
import PhotoCard from '@/components/PhotoCard';
import type { Photo, Collection } from '@/types';

export default async function HomePage() {
  let featuredPhotos: Photo[] = [];
  let collections: Collection[] = [];

  try {
    [featuredPhotos, { results: collections }] = await Promise.all([
      getFeaturedPhotos(),
      getCollections(),
    ]);
  } catch (error) {
    console.error('Failed to fetch data:', error);
  }

  return (
    <div>
      {/* Hero Section */}
      <section className="relative h-[80vh] flex items-center justify-center bg-gray-900">
        <div className="absolute inset-0 bg-gradient-to-b from-transparent to-gray-900/50" />
        <div className="relative z-10 text-center text-white px-4">
          <h1 className="text-4xl md:text-6xl font-light tracking-wide mb-4">
            Matthew Raynor Photography
          </h1>
          <p className="text-lg md:text-xl text-gray-300 mb-8 max-w-2xl mx-auto">
            Fine art prints of the Hamptons. Museum-quality archival paper and aluminum prints.
          </p>
          <Link
            href="/collections"
            className="inline-block px-8 py-3 bg-white text-gray-900 text-sm font-medium rounded hover:bg-gray-100 transition"
          >
            Explore Collections
          </Link>
        </div>
      </section>

      {/* Featured Photos */}
      {featuredPhotos.length > 0 && (
        <section className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-20">
          <div className="text-center mb-12">
            <h2 className="text-2xl font-light tracking-wide mb-2 text-gray-900 dark:text-gray-100">Featured Works</h2>
            <p className="text-gray-600 dark:text-gray-400">Curated selections from the collection</p>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
            {featuredPhotos.slice(0, 6).map((photo) => (
              <PhotoCard key={photo.id} photo={photo} />
            ))}
          </div>
          <div className="text-center mt-12">
            <Link
              href="/photos"
              className="inline-block px-8 py-3 border border-gray-900 dark:border-gray-100 text-gray-900 dark:text-gray-100 text-sm font-medium rounded hover:bg-gray-900 hover:text-white dark:hover:bg-gray-100 dark:hover:text-gray-900 transition"
            >
              View All Prints
            </Link>
          </div>
        </section>
      )}

      {/* Collections */}
      {collections.length > 0 && (
        <section className="bg-gray-50 dark:bg-gray-800 py-20">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center mb-12">
              <h2 className="text-2xl font-light tracking-wide mb-2 text-gray-900 dark:text-gray-100">Collections</h2>
              <p className="text-gray-600 dark:text-gray-400">Explore themed series of photographs</p>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
              {collections.map((collection) => (
                <Link
                  key={collection.id}
                  href={`/collections/${collection.slug}`}
                  className="group block"
                >
                  <div className="relative aspect-[3/2] overflow-hidden bg-gray-200 dark:bg-gray-700 rounded-sm">
                    {collection.cover_image ? (
                      <Image
                        src={collection.cover_image}
                        alt={collection.name}
                        fill
                        className="object-cover transition-transform duration-500 group-hover:scale-105"
                        sizes="(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw"
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center text-gray-400">
                        {collection.name}
                      </div>
                    )}
                    <div className="absolute inset-0 bg-black/30 group-hover:bg-black/40 transition" />
                    <div className="absolute inset-0 flex flex-col items-center justify-center text-white">
                      <h3 className="text-xl font-medium">{collection.name}</h3>
                      <p className="text-sm text-gray-200 mt-1">{collection.photo_count} prints</p>
                    </div>
                  </div>
                </Link>
              ))}
            </div>
          </div>
        </section>
      )}

      {/* About Teaser */}
      <section className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-20 text-center">
        <h2 className="text-2xl font-light tracking-wide mb-6 text-gray-900 dark:text-gray-100">About the Artist</h2>
        <p className="text-gray-600 dark:text-gray-400 leading-relaxed mb-8">
          Matthew Raynor captures the timeless beauty of the Hamptons through fine art photography.
          Each print is produced using museum-quality materials, from archival pigment inks to
          hand-finished aluminum panels, ensuring your piece will be treasured for generations.
        </p>
        <Link
          href="/about"
          className="text-blue-600 hover:text-blue-700 text-sm font-medium"
        >
          Learn More
        </Link>
      </section>

      {/* Gift Cards CTA */}
      <section className="bg-blue-600 text-white py-16">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
          <h2 className="text-2xl font-light tracking-wide mb-4">Give the Gift of Art</h2>
          <p className="text-blue-100 mb-8">
            Share the beauty of the Hamptons with a gift card for any occasion.
          </p>
          <Link
            href="/gift-cards"
            className="inline-block px-8 py-3 bg-white text-blue-600 text-sm font-medium rounded hover:bg-gray-100 transition"
          >
            Purchase Gift Card
          </Link>
        </div>
      </section>
    </div>
  );
}


================================================
FILE: frontend/src/app/collections/page.tsx
================================================
import Link from 'next/link';
import Image from 'next/image';
import { getCollections } from '@/lib/api';
import type { Collection } from '@/types';

export const dynamic = 'force-dynamic';

export const metadata = {
  title: 'Collections | Matthew Raynor Photography',
  description: 'Explore our curated collections of fine art Hamptons photography.',
};

export default async function CollectionsPage() {
  let collections: Collection[] = [];

  try {
    const data = await getCollections();
    collections = data.results || [];
  } catch (error) {
    console.error('Failed to fetch collections:', error);
  }

  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4 text-gray-900 dark:text-gray-100">Collections</h1>
        <p className="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto">
          Explore themed series of photographs capturing the essence of the Hamptons.
        </p>
      </div>

      {collections.length === 0 ? (
        <p className="text-center text-gray-500 dark:text-gray-400">No collections available yet.</p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {collections.map((collection) => (
            <Link
              key={collection.id}
              href={`/collections/${collection.slug}`}
              className="group block"
            >
              <div className="relative aspect-[16/9] overflow-hidden bg-gray-200 dark:bg-gray-700 rounded">
                {collection.cover_image ? (
                  <Image
                    src={collection.cover_image}
                    alt={collection.name}
                    fill
                    className="object-cover transition-transform duration-500 group-hover:scale-105"
                    sizes="(max-width: 768px) 100vw, 50vw"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center text-gray-400">
                    {collection.name}
                  </div>
                )}
                <div className="absolute inset-0 bg-black/20 group-hover:bg-black/30 transition" />
                <div className="absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/70 to-transparent">
                  <h2 className="text-xl font-medium text-white mb-1">{collection.name}</h2>
                  <p className="text-sm text-gray-200">{collection.photo_count} prints</p>
                  {collection.is_limited_edition && (
                    <span className="inline-block mt-2 px-2 py-1 bg-white/20 text-white text-xs rounded">
                      Limited Edition
                    </span>
                  )}
                </div>
              </div>
              {collection.description && (
                <p className="mt-3 text-sm text-gray-600 dark:text-gray-400 line-clamp-2">{collection.description}</p>
              )}
            </Link>
          ))}
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/src/app/collections/[slug]/page.tsx
================================================
import { notFound } from 'next/navigation';
import { getCollection } from '@/lib/api';
import PhotoCard from '@/components/PhotoCard';

interface Props {
  params: Promise<{ slug: string }>;
}

export async function generateMetadata({ params }: Props) {
  const { slug } = await params;
  try {
    const collection = await getCollection(slug);
    const description = collection.description || `Explore the ${collection.name} collection.`;
    return {
      title: `${collection.name} | Matthew Raynor Photography`,
      description,
      openGraph: {
        title: `${collection.name} â€” Matthew Raynor Photography`,
        description,
        images: collection.cover_image ? [{ url: collection.cover_image, alt: collection.name }] : [],
        type: 'website',
      },
      twitter: {
        card: 'summary_large_image',
        title: `${collection.name} â€” Matthew Raynor Photography`,
        description,
        images: collection.cover_image ? [collection.cover_image] : [],
      },
    };
  } catch {
    return {
      title: 'Collection Not Found',
    };
  }
}

export default async function CollectionPage({ params }: Props) {
  const { slug } = await params;

  let collection;
  try {
    collection = await getCollection(slug);
  } catch {
    notFound();
  }

  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4">{collection.name}</h1>
        {collection.description && (
          <p className="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto">{collection.description}</p>
        )}
        {collection.is_limited_edition && (
          <span className="inline-block mt-4 px-3 py-1 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 text-sm rounded">
            Limited Edition
          </span>
        )}
      </div>

      {collection.photos?.length === 0 ? (
        <p className="text-center text-gray-500 dark:text-gray-400">No photos in this collection yet.</p>
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
          {collection.photos?.map((photo) => (
            <PhotoCard key={photo.id} photo={photo} />
          ))}
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/src/app/photos/page.tsx
================================================
'use client';

import { useState, useEffect } from 'react';
import { getPhotos } from '@/lib/api';
import PhotoCard from '@/components/PhotoCard';
import type { Photo } from '@/types';

export default function PhotosPage() {
  const [photos, setPhotos] = useState<Photo[]>([]);
  const [loading, setLoading] = useState(true);
  const [filters, setFilters] = useState({
    orientation: '',
    material: '',
    ordering: '-created_at',
  });

  useEffect(() => {
    const fetchPhotos = async () => {
      setLoading(true);
      try {
        const params: Record<string, string> = {};
        if (filters.orientation) params.orientation = filters.orientation;
        if (filters.material) params.material = filters.material;
        if (filters.ordering) params.ordering = filters.ordering;

        const data = await getPhotos(params);
        setPhotos(data.results || []);
      } catch (error) {
        console.error('Failed to fetch photos:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchPhotos();
  }, [filters]);

  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4">Shop All Prints</h1>
        <p className="text-gray-600 dark:text-gray-400">
          Browse our complete collection of fine art photography prints.
        </p>
      </div>

      {/* Filters */}
      <div className="flex flex-wrap gap-4 justify-center mb-12">
        <select
          value={filters.orientation}
          onChange={(e) => setFilters({ ...filters, orientation: e.target.value })}
          className="px-4 py-2 border border-gray-200 dark:border-gray-700 rounded text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">All Orientations</option>
          <option value="horizontal">Horizontal</option>
          <option value="vertical">Vertical</option>
          <option value="square">Square</option>
        </select>

        <select
          value={filters.material}
          onChange={(e) => setFilters({ ...filters, material: e.target.value })}
          className="px-4 py-2 border border-gray-200 dark:border-gray-700 rounded text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="">All Materials</option>
          <option value="paper">Archival Paper</option>
          <option value="aluminum">Aluminum</option>
        </select>

        <select
          value={filters.ordering}
          onChange={(e) => setFilters({ ...filters, ordering: e.target.value })}
          className="px-4 py-2 border border-gray-200 dark:border-gray-700 rounded text-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="-created_at">Newest First</option>
          <option value="created_at">Oldest First</option>
          <option value="min_price">Price: Low to High</option>
          <option value="-min_price">Price: High to Low</option>
          <option value="title">Title A-Z</option>
        </select>
      </div>

      {loading ? (
        <div className="text-center py-12">
          <div className="inline-block w-8 h-8 border-2 border-gray-300 border-t-gray-900 dark:border-gray-600 dark:border-t-gray-100 rounded-full animate-spin" />
        </div>
      ) : photos.length === 0 ? (
        <p className="text-center text-gray-500 dark:text-gray-400">No photos found.</p>
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
          {photos.map((photo) => (
            <PhotoCard key={photo.id} photo={photo} />
          ))}
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/src/app/photos/[slug]/page.tsx
================================================
import { notFound } from 'next/navigation';
import { getPhoto } from '@/lib/api';
import PhotoDetailClient from './PhotoDetailClient';

interface Props {
  params: Promise<{ slug: string }>;
}

export async function generateMetadata({ params }: Props) {
  const { slug } = await params;
  try {
    const photo = await getPhoto(slug);
    const priceRange = photo.price_range
      ? `From $${photo.price_range.min}`
      : '';
    const description = photo.description
      || `${photo.title} â€” fine art photography print by Matthew Raynor. ${photo.location}. ${priceRange}`.trim();

    return {
      title: `${photo.title} | Matthew Raynor Photography`,
      description,
      openGraph: {
        title: `${photo.title} â€” Fine Art Print`,
        description,
        images: photo.image ? [{ url: photo.image, alt: photo.title }] : [],
        type: 'website',
      },
      twitter: {
        card: 'summary_large_image',
        title: `${photo.title} â€” Fine Art Print`,
        description,
        images: photo.image ? [photo.image] : [],
      },
    };
  } catch {
    return {
      title: 'Photo Not Found | Matthew Raynor Photography',
    };
  }
}

export default async function PhotoDetailPage({ params }: Props) {
  const { slug } = await params;

  let photo;
  try {
    photo = await getPhoto(slug);
  } catch {
    notFound();
  }

  return <PhotoDetailClient photo={photo} />;
}


================================================
FILE: frontend/src/app/cart/page.tsx
================================================
'use client';

import { useState } from 'react';
import Image from 'next/image';
import Link from 'next/link';
import { updateCartItem, removeCartItem, createCheckoutSession, checkGiftCard } from '@/lib/api';
import { useCart } from '@/contexts/CartContext';

export default function CartPage() {
  const { cart, loading, refreshCart } = useCart();
  const [updating, setUpdating] = useState<number | null>(null);
  const [checkingOut, setCheckingOut] = useState(false);

  // Gift card state
  const [giftCardCode, setGiftCardCode] = useState('');
  const [appliedGiftCard, setAppliedGiftCard] = useState<{ code: string; balance: number } | null>(null);
  const [giftCardError, setGiftCardError] = useState('');
  const [applyingGiftCard, setApplyingGiftCard] = useState(false);

  const handleUpdateQuantity = async (itemId: number, quantity: number) => {
    if (quantity < 1) return;
    setUpdating(itemId);
    try {
      await updateCartItem(itemId, quantity);
      await refreshCart();
    } catch (error) {
      console.error('Failed to update quantity:', error);
    } finally {
      setUpdating(null);
    }
  };

  const handleRemove = async (itemId: number) => {
    setUpdating(itemId);
    try {
      await removeCartItem(itemId);
      await refreshCart();
    } catch (error) {
      console.error('Failed to remove item:', error);
    } finally {
      setUpdating(null);
    }
  };

  const handleCheckout = async () => {
    setCheckingOut(true);
    try {
      const { checkout_url } = await createCheckoutSession(appliedGiftCard?.code);
      window.location.href = checkout_url;
    } catch (error) {
      console.error('Failed to create checkout session:', error);
      setCheckingOut(false);
    }
  };

  const handleApplyGiftCard = async () => {
    if (!giftCardCode.trim()) return;

    setApplyingGiftCard(true);
    setGiftCardError('');

    try {
      const result = await checkGiftCard(giftCardCode.trim());
      if (result.valid && result.balance) {
        setAppliedGiftCard({
          code: giftCardCode.trim().toUpperCase(),
          balance: parseFloat(result.balance),
        });
        setGiftCardCode('');
      } else {
        setGiftCardError(result.error || 'Invalid gift card');
      }
    } catch (error) {
      setGiftCardError('Gift card not found');
    } finally {
      setApplyingGiftCard(false);
    }
  };

  const handleRemoveGiftCard = () => {
    setAppliedGiftCard(null);
    setGiftCardError('');
  };

  // Calculate totals with gift card
  const subtotal = cart ? parseFloat(cart.subtotal) : 0;
  const giftCardDiscount = appliedGiftCard ? Math.min(appliedGiftCard.balance, subtotal) : 0;
  const estimatedTotal = subtotal - giftCardDiscount;

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-gray-300 border-t-gray-900 rounded-full animate-spin" />
      </div>
    );
  }

  if (!cart || cart.items.length === 0) {
    return (
      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16 text-center">
        <h1 className="text-3xl font-light tracking-wide mb-4">Your Cart</h1>
        <p className="text-gray-500 mb-8">Your cart is empty.</p>
        <Link
          href="/photos"
          className="inline-block px-8 py-3 bg-gray-900 text-white text-sm font-medium rounded hover:bg-gray-800 transition"
        >
          Continue Shopping
        </Link>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <h1 className="text-3xl font-light tracking-wide mb-8">Your Cart</h1>

      <div className="space-y-6">
        {cart.items.map((item) => {
          const itemLink = item.item_type === 'variant' && item.variant?.photo?.slug
            ? `/photos/${item.variant.photo.slug}`
            : item.product?.slug
              ? `/book/${item.product.slug}`
              : '#';

          return (
            <div
              key={item.id}
              className="flex gap-6 p-4 bg-gray-50 dark:bg-gray-800 rounded"
            >
              {/* Image */}
              <div className="relative w-24 h-24 bg-gray-200 dark:bg-gray-700 rounded overflow-hidden flex-shrink-0">
                {item.image ? (
                  <Image
                    src={item.image}
                    alt={item.title}
                    fill
                    className="object-cover"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center text-gray-400 text-xs">
                    No image
                  </div>
                )}
              </div>

              {/* Details */}
              <div className="flex-1 min-w-0">
                <Link
                  href={itemLink}
                  className="font-medium text-gray-900 dark:text-gray-100 hover:text-blue-600 dark:hover:text-blue-400 transition"
                >
                  {item.title}
                </Link>
                <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">{item.description}</p>

                <div className="flex items-center gap-4 mt-3">
                  <div className="flex items-center border border-gray-200 dark:border-gray-600 rounded">
                    <button
                      onClick={() => handleUpdateQuantity(item.id, item.quantity - 1)}
                      disabled={updating === item.id || item.quantity <= 1}
                      className="px-3 py-1 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50"
                      aria-label="Decrease quantity"
                    >
                      -
                    </button>
                    <span className="px-3 py-1 min-w-[40px] text-center text-gray-900 dark:text-gray-100">{item.quantity}</span>
                    <button
                      onClick={() => handleUpdateQuantity(item.id, item.quantity + 1)}
                      disabled={updating === item.id}
                      className="px-3 py-1 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 disabled:opacity-50"
                      aria-label="Increase quantity"
                    >
                      +
                    </button>
                  </div>

                  <button
                    onClick={() => handleRemove(item.id)}
                    disabled={updating === item.id}
                    className="text-sm text-red-600 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300 disabled:opacity-50"
                  >
                    Remove
                  </button>
                </div>
              </div>

              {/* Price - self-center to vertically center with the row */}
              <div className="text-right flex-shrink-0 self-center">
                <p className="font-medium text-gray-900 dark:text-gray-100">${item.total_price}</p>
                {item.quantity > 1 && (
                  <p className="text-sm text-gray-500 dark:text-gray-400">${item.unit_price} each</p>
                )}
              </div>
            </div>
          );
        })}
      </div>

      {/* Summary */}
      <div className="mt-8 pt-8 border-t border-gray-200 dark:border-gray-700">
        {/* Gift Card Section */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Gift Card
          </label>
          {appliedGiftCard ? (
            <div className="flex items-center justify-between p-3 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded">
              <div>
                <span className="font-medium text-green-800 dark:text-green-300">{appliedGiftCard.code}</span>
                <span className="text-sm text-green-600 dark:text-green-400 ml-2">
                  (${appliedGiftCard.balance.toFixed(2)} available)
                </span>
              </div>
              <button
                onClick={handleRemoveGiftCard}
                className="text-sm text-red-600 dark:text-red-400 hover:text-red-700"
              >
                Remove
              </button>
            </div>
          ) : (
            <div className="flex gap-2">
              <input
                type="text"
                value={giftCardCode}
                onChange={(e) => setGiftCardCode(e.target.value.toUpperCase())}
                placeholder="Enter gift card code"
                className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-400"
              />
              <button
                onClick={handleApplyGiftCard}
                disabled={applyingGiftCard || !giftCardCode.trim()}
                className="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition disabled:opacity-50"
              >
                {applyingGiftCard ? '...' : 'Apply'}
              </button>
            </div>
          )}
          {giftCardError && (
            <p className="mt-2 text-sm text-red-600 dark:text-red-400">{giftCardError}</p>
          )}
        </div>

        {/* Totals */}
        <div className="space-y-2 mb-6">
          <div className="flex justify-between items-center">
            <span className="text-gray-600 dark:text-gray-400">Subtotal</span>
            <span className="text-gray-900 dark:text-gray-100">${subtotal.toFixed(2)}</span>
          </div>
          {appliedGiftCard && giftCardDiscount > 0 && (
            <div className="flex justify-between items-center text-green-600 dark:text-green-400">
              <span>Gift Card ({appliedGiftCard.code})</span>
              <span>-${giftCardDiscount.toFixed(2)}</span>
            </div>
          )}
          <div className="flex justify-between items-center pt-2 border-t border-gray-200 dark:border-gray-700">
            <span className="text-lg font-medium text-gray-900 dark:text-gray-100">Estimated Total</span>
            <span className="text-2xl font-medium text-gray-900 dark:text-gray-100">${estimatedTotal.toFixed(2)}</span>
          </div>
        </div>

        <p className="text-sm text-gray-500 dark:text-gray-400 mb-6">
          Shipping and taxes calculated at checkout.
        </p>

        <button
          onClick={handleCheckout}
          disabled={checkingOut}
          className="w-full py-4 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 font-medium rounded hover:bg-gray-800 dark:hover:bg-gray-200 transition disabled:opacity-50"
        >
          {checkingOut ? 'Redirecting to Checkout...' : 'Proceed to Checkout'}
        </button>

        <Link
          href="/photos"
          className="block text-center mt-4 text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200"
        >
          Continue Shopping
        </Link>
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/app/book/page.tsx
================================================
'use client';

import { useState, useEffect } from 'react';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { getProducts, addProductToCart } from '@/lib/api';
import { useCart } from '@/contexts/CartContext';
import type { Product } from '@/types';

export default function BookPage() {
  const router = useRouter();
  const { refreshCart } = useCart();
  const [book, setBook] = useState<Product | null>(null);
  const [loading, setLoading] = useState(true);
  const [adding, setAdding] = useState(false);
  const [message, setMessage] = useState('');
  const [quantity, setQuantity] = useState(1);

  useEffect(() => {
    const fetchBook = async () => {
      try {
        const data = await getProducts({ product_type: 'book' });
        // Get the first (and likely only) book
        if (data.results && data.results.length > 0) {
          setBook(data.results[0]);
        }
      } catch (error) {
        console.error('Failed to fetch book:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchBook();
  }, []);

  const handleAddToCart = async () => {
    if (!book) return;

    setAdding(true);
    setMessage('');
    try {
      await addProductToCart(book.id, quantity);
      await refreshCart();
      setMessage('Added to cart!');
      setTimeout(() => {
        router.push('/cart');
      }, 1000);
    } catch (error) {
      setMessage('Failed to add to cart. Please try again.');
    } finally {
      setAdding(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-gray-300 border-t-gray-900 dark:border-gray-600 dark:border-t-gray-100 rounded-full animate-spin" />
      </div>
    );
  }

  if (!book) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center">
        <p className="text-gray-500 dark:text-gray-400 mb-4">Book not found</p>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-12">
        {/* Book Image */}
        <div className="relative aspect-[3/4] bg-gray-100 dark:bg-gray-800 rounded overflow-hidden">
          {book.image ? (
            <Image
              src={book.image}
              alt={book.title}
              fill
              className="object-contain"
              sizes="(max-width: 1024px) 100vw, 50vw"
              priority
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center text-gray-400">
              No image available
            </div>
          )}
        </div>

        {/* Book Details */}
        <div>
          <p className="text-sm text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2">
            {book.product_type_display}
          </p>
          <h1 className="text-3xl font-light tracking-wide mb-2">{book.title}</h1>
          {book.author && (
            <p className="text-lg text-gray-600 dark:text-gray-400 mb-4">by {book.author}</p>
          )}

          {book.description && (
            <p className="text-gray-600 dark:text-gray-400 mb-6 leading-relaxed">{book.description}</p>
          )}

          {book.long_description && (
            <div className="mb-8 prose prose-gray max-w-none">
              <p className="text-gray-600 dark:text-gray-400 leading-relaxed whitespace-pre-line">
                {book.long_description}
              </p>
            </div>
          )}

          {/* Price */}
          <div className="mb-6">
            <div className="flex items-baseline gap-3">
              <span className="text-3xl font-medium">${book.price}</span>
              {book.is_on_sale && book.compare_at_price && (
                <span className="text-lg text-gray-400 dark:text-gray-500 line-through">
                  ${book.compare_at_price}
                </span>
              )}
            </div>
            {!book.is_in_stock && (
              <p className="text-red-600 text-sm mt-1">Out of stock</p>
            )}
          </div>

          {/* Quantity Selector */}
          {book.is_in_stock && (
            <div className="mb-6">
              <label className="text-sm font-medium mb-2 block">Quantity</label>
              <div className="flex items-center border border-gray-200 dark:border-gray-700 rounded w-fit">
                <button
                  onClick={() => setQuantity(Math.max(1, quantity - 1))}
                  className="px-4 py-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                  aria-label="Decrease quantity"
                >
                  -
                </button>
                <span className="px-4 py-2 min-w-[50px] text-center">{quantity}</span>
                <button
                  onClick={() => setQuantity(quantity + 1)}
                  className="px-4 py-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                  aria-label="Increase quantity"
                >
                  +
                </button>
              </div>
            </div>
          )}

          {/* Add to Cart */}
          <button
            onClick={handleAddToCart}
            disabled={!book.is_in_stock || adding}
            className="w-full py-3 bg-gray-900 text-white font-medium rounded hover:bg-gray-800 transition disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {adding ? 'Adding...' : book.is_in_stock ? 'Add to Cart' : 'Out of Stock'}
          </button>

          {message && (
            <p className={`mt-3 text-sm text-center ${message.includes('Failed') ? 'text-red-600' : 'text-green-600'}`}>
              {message}
            </p>
          )}

          {/* Book Details */}
          <div className="mt-8 pt-8 border-t border-gray-200 dark:border-gray-700 space-y-3 text-sm">
            <h4 className="font-medium text-gray-900 dark:text-gray-100">Details</h4>
            <dl className="grid grid-cols-2 gap-2 text-gray-600 dark:text-gray-400">
              {book.publisher && (
                <>
                  <dt className="font-medium">Publisher</dt>
                  <dd>{book.publisher}</dd>
                </>
              )}
              {book.publication_year && (
                <>
                  <dt className="font-medium">Year</dt>
                  <dd>{book.publication_year}</dd>
                </>
              )}
              {book.pages && (
                <>
                  <dt className="font-medium">Pages</dt>
                  <dd>{book.pages}</dd>
                </>
              )}
              {book.dimensions && (
                <>
                  <dt className="font-medium">Dimensions</dt>
                  <dd>{book.dimensions}</dd>
                </>
              )}
              {book.isbn && (
                <>
                  <dt className="font-medium">ISBN</dt>
                  <dd>{book.isbn}</dd>
                </>
              )}
            </dl>
          </div>

          {/* Shipping Info */}
          <div className="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400">
            <h4 className="font-medium text-gray-900 dark:text-gray-100 mb-2">Shipping</h4>
            <p>Free shipping on orders over $500. Most orders ship within 3-5 business days.</p>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/app/gift-cards/page.tsx
================================================
'use client';

import { useState } from 'react';
import { purchaseGiftCard } from '@/lib/api';

const AMOUNTS = [100, 250, 500, 1000, 2500];

export default function GiftCardsPage() {
  const [selectedAmount, setSelectedAmount] = useState(250);
  const [recipientEmail, setRecipientEmail] = useState('');
  const [recipientName, setRecipientName] = useState('');
  const [purchaserEmail, setPurchaserEmail] = useState('');
  const [purchaserName, setPurchaserName] = useState('');
  const [message, setMessage] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      const { checkout_url } = await purchaseGiftCard({
        amount: selectedAmount,
        recipient_email: recipientEmail,
        recipient_name: recipientName,
        purchaser_email: purchaserEmail,
        purchaser_name: purchaserName,
        message,
      });
      window.location.href = checkout_url;
    } catch (err) {
      setError('Failed to process gift card. Please try again.');
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4">Gift Cards</h1>
        <p className="text-gray-600 dark:text-gray-400">
          Give the gift of fine art photography. Perfect for any occasion.
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-8">
        {/* Amount Selection */}
        <div>
          <label className="block text-sm font-medium mb-3">Select Amount</label>
          <div className="grid grid-cols-5 gap-2">
            {AMOUNTS.map((amount) => (
              <button
                key={amount}
                type="button"
                onClick={() => setSelectedAmount(amount)}
                className={`py-3 rounded border text-sm font-medium transition ${
                  selectedAmount === amount
                    ? 'border-blue-600 bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400'
                    : 'border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600'
                }`}
              >
                ${amount}
              </button>
            ))}
          </div>
        </div>

        {/* Recipient Info */}
        <div className="space-y-4">
          <h3 className="text-sm font-medium">Recipient Information</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm text-gray-600 dark:text-gray-400 mb-1">Email *</label>
              <input
                type="email"
                value={recipientEmail}
                onChange={(e) => setRecipientEmail(e.target.value)}
                required
                className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="recipient@email.com"
              />
            </div>
            <div>
              <label className="block text-sm text-gray-600 dark:text-gray-400 mb-1">Name</label>
              <input
                type="text"
                value={recipientName}
                onChange={(e) => setRecipientName(e.target.value)}
                className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Recipient's name"
              />
            </div>
          </div>
        </div>

        {/* Your Info */}
        <div className="space-y-4">
          <h3 className="text-sm font-medium">Your Information</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm text-gray-600 dark:text-gray-400 mb-1">Email *</label>
              <input
                type="email"
                value={purchaserEmail}
                onChange={(e) => setPurchaserEmail(e.target.value)}
                required
                className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="your@email.com"
              />
            </div>
            <div>
              <label className="block text-sm text-gray-600 dark:text-gray-400 mb-1">Name</label>
              <input
                type="text"
                value={purchaserName}
                onChange={(e) => setPurchaserName(e.target.value)}
                className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                placeholder="Your name"
              />
            </div>
          </div>
        </div>

        {/* Personal Message */}
        <div>
          <label className="block text-sm font-medium mb-1">Personal Message (Optional)</label>
          <textarea
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            rows={3}
            maxLength={500}
            className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Add a personal message to include with the gift card..."
          />
          <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{message.length}/500 characters</p>
        </div>

        {error && (
          <p className="text-red-600 text-sm">{error}</p>
        )}

        <button
          type="submit"
          disabled={loading || !recipientEmail || !purchaserEmail}
          className="w-full py-4 bg-blue-600 text-white font-medium rounded hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {loading ? 'Processing...' : `Purchase $${selectedAmount} Gift Card`}
        </button>

        <p className="text-sm text-gray-500 dark:text-gray-400 text-center">
          The recipient will receive their gift card via email immediately after purchase.
          Gift cards are valid for one year from the date of purchase.
        </p>
      </form>
    </div>
  );
}


================================================
FILE: frontend/src/app/contact/page.tsx
================================================
'use client';

import { useState } from 'react';
import { submitContactForm } from '@/lib/api';

export default function ContactPage() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [subject, setSubject] = useState('');
  const [message, setMessage] = useState('');
  const [honeypot, setHoneypot] = useState(''); // Honeypot field - should remain empty
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState<'idle' | 'success' | 'error'>('idle');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // If honeypot is filled, silently "succeed" but don't actually submit
    if (honeypot) {
      setStatus('success');
      return;
    }

    setLoading(true);
    setStatus('idle');

    try {
      await submitContactForm({ name, email, subject, message });
      setStatus('success');
      setName('');
      setEmail('');
      setSubject('');
      setMessage('');
    } catch {
      setStatus('error');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4 text-gray-900 dark:text-gray-100">Contact</h1>
        <p className="text-gray-600 dark:text-gray-400">
          Have a question about a print, custom sizing, or anything else? Get in touch.
        </p>
      </div>

      {status === 'success' ? (
        <div className="text-center py-12 bg-green-50 dark:bg-green-900/20 rounded-lg">
          <div className="w-16 h-16 bg-green-100 dark:bg-green-900/40 rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-8 h-8 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
          </div>
          <h2 className="text-xl font-medium mb-2 text-gray-900 dark:text-gray-100">Message Sent!</h2>
          <p className="text-gray-600 dark:text-gray-400">Thank you for reaching out. I&apos;ll get back to you soon.</p>
        </div>
      ) : (
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Honeypot field - hidden from users, bots will fill it */}
          <div className="absolute left-[-9999px]" aria-hidden="true">
            <label htmlFor="website">Website</label>
            <input
              type="text"
              id="website"
              name="website"
              value={honeypot}
              onChange={(e) => setHoneypot(e.target.value)}
              tabIndex={-1}
              autoComplete="off"
            />
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-gray-100">Name *</label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required
                className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-gray-100">Email *</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-gray-100">Subject</label>
            <input
              type="text"
              value={subject}
              onChange={(e) => setSubject(e.target.value)}
              className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="General Inquiry"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1 text-gray-900 dark:text-gray-100">Message *</label>
            <textarea
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              required
              rows={6}
              className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {status === 'error' && (
            <p className="text-red-600 dark:text-red-400 text-sm">Failed to send message. Please try again.</p>
          )}

          <button
            type="submit"
            disabled={loading}
            className="w-full py-3 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 font-medium rounded hover:bg-gray-800 dark:hover:bg-gray-200 transition disabled:opacity-50"
          >
            {loading ? 'Sending...' : 'Send Message'}
          </button>
        </form>
      )}

      <div className="mt-12 pt-12 border-t border-gray-200 dark:border-gray-700 text-center text-sm text-gray-600 dark:text-gray-400">
        <p className="mb-2">You can also reach me directly at:</p>
        <a href="mailto:hello@matthewraynor.com" className="text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300">
          hello@matthewraynor.com
        </a>
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/app/about/page.tsx
================================================
import Link from 'next/link';

export const metadata = {
  title: 'About | Matthew Raynor Photography',
  description: 'Learn about Matthew Raynor and the fine art photography of the Hamptons.',
};

export default function AboutPage() {
  return (
    <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4 text-gray-900 dark:text-gray-100">About</h1>
      </div>

      <div className="prose prose-lg max-w-none text-gray-600 dark:text-gray-400">
        <p className="lead text-xl text-gray-700 dark:text-gray-300 mb-8">
          Matthew Raynor is a fine art photographer based in the Hamptons, capturing the
          timeless beauty of Long Island&apos;s East End through his lens.
        </p>

        <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mt-12 mb-4">The Work</h2>
        <p>
          Each photograph in this collection represents a moment of quiet beauty found
          in the landscapes, seascapes, and hidden corners of the Hamptons. From the
          golden light of summer sunsets over Montauk to the moody winter skies above
          Southampton, these images capture the essence of a place cherished by many.
        </p>

        <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mt-12 mb-4">The Prints</h2>
        <p>
          Every print is produced using museum-quality materials and techniques to ensure
          your artwork will be treasured for generations. We offer two premium options:
        </p>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-8 my-8">
          <div className="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
            <h3 className="font-medium text-gray-900 dark:text-gray-100 mb-2">Archival Paper</h3>
            <p className="text-sm">
              GiclÃ©e prints on HahnemÃ¼hle Photo Rag, a 100% cotton, acid-free fine art paper.
              Printed with archival pigment inks rated for 100+ years of color stability.
            </p>
          </div>
          <div className="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
            <h3 className="font-medium text-gray-900 dark:text-gray-100 mb-2">Aluminum</h3>
            <p className="text-sm">
              HD metal prints with exceptional color vibrancy and depth. Images are infused
              directly into specially coated aluminum for a stunning, ready-to-hang display.
            </p>
          </div>
        </div>

        <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mt-12 mb-4">Shipping & Handling</h2>
        <p>
          All prints are carefully packaged and shipped with insurance. Paper prints
          ship in rigid tubes, while aluminum prints ship in custom protective crates.
          Most orders ship within 5-7 business days.
        </p>

        <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mt-12 mb-4">Custom Orders</h2>
        <p>
          Looking for a specific size or framing option? Need a print for a commercial
          project or special occasion? I&apos;m happy to work with you on custom orders.
        </p>
      </div>

      <div className="mt-12 text-center">
        <Link
          href="/contact"
          className="inline-block px-8 py-3 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 text-sm font-medium rounded hover:bg-gray-800 dark:hover:bg-gray-200 transition"
        >
          Get in Touch
        </Link>
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/app/track-order/page.tsx
================================================
'use client';

import { useState } from 'react';
import { trackOrder } from '@/lib/api';

interface TrackingResult {
  order_number: string;
  status: string;
  tracking_number?: string;
  tracking_carrier?: string;
  tracking_url?: string;
}

export default function TrackOrderPage() {
  const [email, setEmail] = useState('');
  const [orderNumber, setOrderNumber] = useState('');
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<TrackingResult | null>(null);
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setResult(null);

    try {
      const data = await trackOrder(email, orderNumber);
      setResult(data);
    } catch {
      setError('Order not found. Please check your email and order number.');
    } finally {
      setLoading(false);
    }
  };

  const getStatusDisplay = (status: string) => {
    const statuses: Record<string, { label: string; color: string }> = {
      pending: { label: 'Pending', color: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300' },
      paid: { label: 'Paid', color: 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300' },
      processing: { label: 'Processing', color: 'bg-purple-100 text-purple-800 dark:bg-purple-900/30 dark:text-purple-300' },
      shipped: { label: 'Shipped', color: 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300' },
      delivered: { label: 'Delivered', color: 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300' },
      cancelled: { label: 'Cancelled', color: 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300' },
    };
    return statuses[status] || { label: status, color: 'bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300' };
  };

  return (
    <div className="max-w-lg mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <div className="text-center mb-12">
        <h1 className="text-3xl font-light tracking-wide mb-4">Track Your Order</h1>
        <p className="text-gray-600 dark:text-gray-400">
          Enter your email and order number to check the status of your order.
        </p>
      </div>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Email</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="The email used for your order"
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">Order Number</label>
          <input
            type="text"
            value={orderNumber}
            onChange={(e) => setOrderNumber(e.target.value)}
            required
            className="w-full px-4 py-2 border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="e.g., MR-240115-001"
          />
        </div>

        {error && (
          <p className="text-red-600 text-sm">{error}</p>
        )}

        <button
          type="submit"
          disabled={loading}
          className="w-full py-3 bg-gray-900 text-white font-medium rounded hover:bg-gray-800 transition disabled:opacity-50"
        >
          {loading ? 'Looking up...' : 'Track Order'}
        </button>
      </form>

      {result && (
        <div className="mt-8 p-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
          <div className="flex items-center justify-between mb-4">
            <h2 className="font-medium">Order {result.order_number}</h2>
            <span className={`px-3 py-1 rounded-full text-sm ${getStatusDisplay(result.status).color}`}>
              {getStatusDisplay(result.status).label}
            </span>
          </div>

          {result.tracking_number ? (
            <div className="space-y-2 text-sm">
              <p>
                <span className="text-gray-500 dark:text-gray-400">Carrier:</span>{' '}
                {result.tracking_carrier || 'Standard Shipping'}
              </p>
              <p>
                <span className="text-gray-500 dark:text-gray-400">Tracking Number:</span>{' '}
                {result.tracking_url ? (
                  <a
                    href={result.tracking_url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-600 hover:text-blue-700"
                  >
                    {result.tracking_number}
                  </a>
                ) : (
                  result.tracking_number
                )}
              </p>
            </div>
          ) : (
            <p className="text-sm text-gray-600 dark:text-gray-400">
              {result.status === 'shipped' || result.status === 'delivered'
                ? 'Tracking information will be updated shortly.'
                : 'Tracking information will be available once your order ships.'}
            </p>
          )}
        </div>
      )}
    </div>
  );
}


================================================
FILE: frontend/src/app/shipping/page.tsx
================================================
export const metadata = {
  title: 'Shipping & Returns | Matthew Raynor Photography',
  description: 'Shipping information and return policy for fine art photography prints.',
};

export default function ShippingPage() {
  return (
    <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
      <h1 className="text-3xl font-light tracking-wide mb-8 text-gray-900 dark:text-gray-100">
        Shipping & Returns
      </h1>

      <div className="prose prose-gray dark:prose-invert max-w-none space-y-8">
        <section>
          <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mb-4">Shipping</h2>
          <div className="space-y-4 text-gray-600 dark:text-gray-400">
            <p>
              All prints are made to order and carefully packaged to ensure they arrive in perfect condition.
            </p>
            <ul className="list-disc pl-5 space-y-2">
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Processing Time:</strong> Most orders ship within 5-7 business days.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Free Shipping:</strong> Orders over $500 qualify for free shipping within the continental United States.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Standard Shipping:</strong> $15 flat rate for orders under $500.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">International Shipping:</strong> Available upon request. Please contact us for a quote.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mb-4">Packaging</h2>
          <div className="space-y-4 text-gray-600 dark:text-gray-400">
            <p>
              Each print is carefully packaged to protect it during transit:
            </p>
            <ul className="list-disc pl-5 space-y-2">
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Paper Prints:</strong> Shipped flat between rigid cardboard with protective tissue paper.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Aluminum Prints:</strong> Shipped in custom-fit boxes with foam corner protectors.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mb-4">Returns & Exchanges</h2>
          <div className="space-y-4 text-gray-600 dark:text-gray-400">
            <p>
              Your satisfaction is our priority. If you&apos;re not completely happy with your purchase:
            </p>
            <ul className="list-disc pl-5 space-y-2">
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Return Window:</strong> Returns accepted within 30 days of delivery.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Condition:</strong> Items must be in original, undamaged condition.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Refunds:</strong> Full refund to original payment method, minus shipping costs.
              </li>
              <li>
                <strong className="text-gray-900 dark:text-gray-100">Damaged Items:</strong> If your print arrives damaged, please contact us within 48 hours with photos of the damage for a full replacement.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100 mb-4">Contact Us</h2>
          <p className="text-gray-600 dark:text-gray-400">
            Questions about shipping or returns? Email us at{' '}
            <a href="mailto:hello@matthewraynor.com" className="text-blue-600 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300">
              hello@matthewraynor.com
            </a>
          </p>
        </section>
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/components/Header.tsx
================================================
'use client';

import Link from 'next/link';
import { useState } from 'react';
import { useCart } from '@/contexts/CartContext';

export default function Header() {
  const { itemCount } = useCart();
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  return (
    <header className="sticky top-0 z-50 bg-white/95 dark:bg-gray-900/95 backdrop-blur border-b border-gray-100 dark:border-gray-800">
      <nav className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          {/* Logo */}
          <Link href="/" className="text-xl font-light tracking-wide text-gray-900 dark:text-gray-100">
            Matthew Raynor
          </Link>

          {/* Desktop Navigation */}
          <div className="hidden md:flex items-center space-x-8">
            <Link href="/collections" className="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition">
              Collections
            </Link>
            <Link href="/photos" className="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition">
              Shop All
            </Link>
            <Link href="/book" className="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition">
              Book
            </Link>
            <Link href="/about" className="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition">
              About
            </Link>
            <Link href="/contact" className="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition">
              Contact
            </Link>
            <Link href="/cart" className="relative text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition">
              Cart
              {itemCount > 0 && (
                <span className="absolute -top-2 -right-4 bg-blue-600 text-white text-xs w-5 h-5 rounded-full flex items-center justify-center">
                  {itemCount}
                </span>
              )}
            </Link>
          </div>

          {/* Mobile menu button */}
          <button
            onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
            className="md:hidden p-2 text-gray-900 dark:text-gray-100"
            aria-label={mobileMenuOpen ? 'Close menu' : 'Open menu'}
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              {mobileMenuOpen ? (
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M6 18L18 6M6 6l12 12" />
              ) : (
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 6h16M4 12h16M4 18h16" />
              )}
            </svg>
          </button>
        </div>

        {/* Mobile Navigation */}
        {mobileMenuOpen && (
          <div className="md:hidden py-4 border-t border-gray-100 dark:border-gray-800">
            <div className="flex flex-col space-y-4">
              <Link href="/collections" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100" onClick={() => setMobileMenuOpen(false)}>
                Collections
              </Link>
              <Link href="/photos" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100" onClick={() => setMobileMenuOpen(false)}>
                Shop All
              </Link>
              <Link href="/book" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100" onClick={() => setMobileMenuOpen(false)}>
                Book
              </Link>
              <Link href="/about" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100" onClick={() => setMobileMenuOpen(false)}>
                About
              </Link>
              <Link href="/contact" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100" onClick={() => setMobileMenuOpen(false)}>
                Contact
              </Link>
              <Link href="/cart" className="text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100" onClick={() => setMobileMenuOpen(false)}>
                Cart {itemCount > 0 && `(${itemCount})`}
              </Link>
            </div>
          </div>
        )}
      </nav>
    </header>
  );
}


================================================
FILE: frontend/src/components/Footer.tsx
================================================
'use client';

import Link from 'next/link';
import { useState } from 'react';
import { subscribeNewsletter } from '@/lib/api';

export default function Footer() {
  const [email, setEmail] = useState('');
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState('');

  const handleSubscribe = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!email) return;

    setStatus('loading');
    try {
      const res = await subscribeNewsletter(email);
      setStatus('success');
      setMessage(res.message);
      setEmail('');
    } catch {
      setStatus('error');
      setMessage('Something went wrong. Please try again.');
    }
  };

  return (
    <footer className="bg-gray-50 dark:bg-gray-900 border-t border-gray-100 dark:border-gray-800">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-12">
          {/* Brand */}
          <div className="md:col-span-2">
            <h3 className="text-lg font-light tracking-wide mb-4 text-gray-900 dark:text-gray-100">Matthew Raynor Photography</h3>
            <p className="text-sm text-gray-600 dark:text-gray-400 mb-6 max-w-md">
              Fine art photography prints of the Hamptons. Museum-quality archival paper and aluminum prints for collectors and art enthusiasts.
            </p>

            {/* Newsletter */}
            <form onSubmit={handleSubscribe} className="flex gap-2 max-w-sm">
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                className="flex-1 px-4 py-2 text-sm border border-gray-200 dark:border-gray-700 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <button
                type="submit"
                disabled={status === 'loading'}
                className="px-4 py-2 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 text-sm rounded hover:bg-gray-800 dark:hover:bg-gray-200 transition disabled:opacity-50"
              >
                {status === 'loading' ? '...' : 'Subscribe'}
              </button>
            </form>
            {message && (
              <p className={`mt-2 text-sm ${status === 'success' ? 'text-green-600' : 'text-red-600'}`}>
                {message}
              </p>
            )}
          </div>

          {/* Links */}
          <div>
            <h4 className="text-sm font-medium mb-4 text-gray-900 dark:text-gray-100">Shop</h4>
            <ul className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
              <li><Link href="/collections" className="hover:text-gray-900 dark:hover:text-gray-200">Collections</Link></li>
              <li><Link href="/photos" className="hover:text-gray-900 dark:hover:text-gray-200">All Prints</Link></li>
              <li><Link href="/gift-cards" className="hover:text-gray-900 dark:hover:text-gray-200">Gift Cards</Link></li>
            </ul>
          </div>

          <div>
            <h4 className="text-sm font-medium mb-4 text-gray-900 dark:text-gray-100">Info</h4>
            <ul className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
              <li><Link href="/about" className="hover:text-gray-900 dark:hover:text-gray-200">About</Link></li>
              <li><Link href="/contact" className="hover:text-gray-900 dark:hover:text-gray-200">Contact</Link></li>
              <li><Link href="/track-order" className="hover:text-gray-900 dark:hover:text-gray-200">Track Order</Link></li>
              <li><Link href="/shipping" className="hover:text-gray-900 dark:hover:text-gray-200">Shipping & Returns</Link></li>
            </ul>
          </div>
        </div>

        <div className="mt-12 pt-8 border-t border-gray-200 dark:border-gray-700 text-center text-sm text-gray-500 dark:text-gray-400">
          <p>&copy; {new Date().getFullYear()} Matthew Raynor Photography. All rights reserved.</p>
        </div>
      </div>
    </footer>
  );
}


================================================
FILE: frontend/src/components/PhotoCard.tsx
================================================
import Image from 'next/image';
import Link from 'next/link';
import type { Photo } from '@/types';

interface PhotoCardProps {
  photo: Photo;
}

export default function PhotoCard({ photo }: PhotoCardProps) {
  const imageUrl = photo.thumbnail || photo.image;

  // Adjust aspect ratio based on photo orientation
  const aspectClass = photo.orientation === 'vertical'
    ? 'aspect-[3/4]'
    : photo.orientation === 'square'
      ? 'aspect-square'
      : 'aspect-[4/3]';

  return (
    <Link href={`/photos/${photo.slug}`} className="group block">
      <div className={`relative ${aspectClass} overflow-hidden bg-gray-100 rounded-sm`}>
        {imageUrl ? (
          <Image
            src={imageUrl}
            alt={photo.title}
            fill
            quality={90}
            className="object-cover transition-transform duration-500 group-hover:scale-105"
            sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-gray-400">
            No image
          </div>
        )}
      </div>
      <div className="mt-3">
        <h3 className="text-sm font-medium text-gray-900 dark:text-gray-100 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition">
          {photo.title}
        </h3>
        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">{photo.location}</p>
        {photo.price_range && (
          <p className="text-sm text-gray-700 dark:text-gray-300 mt-1">From ${photo.price_range.min}</p>
        )}
      </div>
    </Link>
  );
}


================================================
FILE: frontend/src/components/CropOverlay.tsx
================================================
'use client';

interface CropOverlayProps {
  widthInches: number;
  heightInches: number;
  sourceRatio?: number; // defaults to 3:2 (1.5)
}

/**
 * Displays a semi-transparent overlay showing what areas will be cropped
 * when printing at the selected size.
 *
 * Darkens the areas that will be cut off, leaving the printable area clear.
 * When ratios match (no crop needed), shows a subtle border to indicate selection.
 */
export default function CropOverlay({
  widthInches,
  heightInches,
  sourceRatio = 1.5 // 3:2 default
}: CropOverlayProps) {
  // For vertical images (sourceRatio < 1), flip the print dimensions
  // so that a "30x20" print becomes "20x30" for vertical orientation
  const isVertical = sourceRatio < 1;
  const printRatio = isVertical
    ? heightInches / widthInches
    : widthInches / heightInches;

  // If ratios match (within tolerance), no crop needed - show full frame border
  const tolerance = 0.02;
  if (Math.abs(printRatio - sourceRatio) < tolerance) {
    return (
      <div className="absolute inset-0 pointer-events-none">
        <div className="absolute inset-2 border-2 border-white/70 rounded" />
      </div>
    );
  }

  // Calculate crop percentages
  // If print is wider than source: crop top/bottom
  // If print is narrower than source: crop left/right

  let cropX = 0; // percentage to crop from each side (left and right)
  let cropY = 0; // percentage to crop from each side (top and bottom)

  if (printRatio > sourceRatio) {
    // Print is wider - crop top and bottom
    // Calculate what percentage of height to keep
    const keepHeight = sourceRatio / printRatio;
    cropY = ((1 - keepHeight) / 2) * 100;
  } else {
    // Print is narrower - crop left and right
    // Calculate what percentage of width to keep
    const keepWidth = printRatio / sourceRatio;
    cropX = ((1 - keepWidth) / 2) * 100;
  }

  return (
    <div className="absolute inset-0 pointer-events-none">
      {/* Top crop overlay */}
      {cropY > 0 && (
        <div
          className="absolute left-0 right-0 top-0 bg-black/50"
          style={{ height: `${cropY}%` }}
        />
      )}

      {/* Bottom crop overlay */}
      {cropY > 0 && (
        <div
          className="absolute left-0 right-0 bottom-0 bg-black/50"
          style={{ height: `${cropY}%` }}
        />
      )}

      {/* Left crop overlay */}
      {cropX > 0 && (
        <div
          className="absolute left-0 top-0 bottom-0 bg-black/50"
          style={{
            width: `${cropX}%`,
            top: cropY > 0 ? `${cropY}%` : 0,
            bottom: cropY > 0 ? `${cropY}%` : 0
          }}
        />
      )}

      {/* Right crop overlay */}
      {cropX > 0 && (
        <div
          className="absolute right-0 top-0 bottom-0 bg-black/50"
          style={{
            width: `${cropX}%`,
            top: cropY > 0 ? `${cropY}%` : 0,
            bottom: cropY > 0 ? `${cropY}%` : 0
          }}
        />
      )}

      {/* Border around the crop area */}
      {(cropX > 0 || cropY > 0) && (
        <div
          className="absolute border-2 border-white/70"
          style={{
            left: `${cropX}%`,
            right: `${cropX}%`,
            top: `${cropY}%`,
            bottom: `${cropY}%`
          }}
        />
      )}
    </div>
  );
}


================================================
FILE: frontend/src/components/chat/ChatWidget.tsx
================================================
'use client';

import { useState, useEffect } from 'react';
import ChatWindow from './ChatWindow';

export default function ChatWidget() {
  const [isOpen, setIsOpen] = useState(false);
  const [hasUnread, setHasUnread] = useState(false);
  const [conversationId, setConversationId] = useState<string | null>(null);
  const [showTooltip, setShowTooltip] = useState(false);

  // Load conversation ID from localStorage on mount
  useEffect(() => {
    const savedId = localStorage.getItem('chat_conversation_id');
    if (savedId) {
      setConversationId(savedId);
    }
  }, []);

  // Save conversation ID to localStorage when it changes
  useEffect(() => {
    if (conversationId) {
      localStorage.setItem('chat_conversation_id', conversationId);
    }
  }, [conversationId]);

  // Show tooltip on first visit (after a short delay)
  useEffect(() => {
    const hasSeenTooltip = localStorage.getItem('chat_tooltip_seen');
    if (!hasSeenTooltip && !isOpen) {
      const timer = setTimeout(() => {
        setShowTooltip(true);
        // Auto-hide after 8 seconds
        setTimeout(() => {
          setShowTooltip(false);
          localStorage.setItem('chat_tooltip_seen', 'true');
        }, 8000);
      }, 3000); // Show after 3 seconds on page
      return () => clearTimeout(timer);
    }
  }, [isOpen]);

  // Hide tooltip and mark as seen when chat opens
  useEffect(() => {
    if (isOpen) {
      setHasUnread(false);
      setShowTooltip(false);
      localStorage.setItem('chat_tooltip_seen', 'true');
    }
  }, [isOpen]);

  return (
    <>
      {/* Chat Window */}
      {isOpen && (
        <ChatWindow
          conversationId={conversationId}
          onConversationIdChange={setConversationId}
          onClose={() => setIsOpen(false)}
          onNewMessage={() => {
            if (!isOpen) setHasUnread(true);
          }}
        />
      )}

      {/* Tooltip bubble */}
      {showTooltip && !isOpen && (
        <div className="fixed bottom-24 right-6 z-50 animate-fade-in">
          <div className="relative bg-white dark:bg-gray-800 rounded-lg shadow-xl px-4 py-3 max-w-[220px]">
            <p className="text-sm text-gray-700 dark:text-gray-200">
              Need help finding the perfect print? Chat with me!
            </p>
            {/* Triangle pointer */}
            <div className="absolute -bottom-2 right-6 w-4 h-4 bg-white dark:bg-gray-800 rotate-45 shadow-xl" />
            {/* Close button */}
            <button
              onClick={(e) => {
                e.stopPropagation();
                setShowTooltip(false);
                localStorage.setItem('chat_tooltip_seen', 'true');
              }}
              className="absolute -top-2 -right-2 w-6 h-6 bg-gray-200 dark:bg-gray-600 rounded-full flex items-center justify-center text-gray-500 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500 transition-colors"
              aria-label="Dismiss"
            >
              <svg className="w-3 h-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      )}

      {/* Floating Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={`
          fixed bottom-6 right-6 z-50
          w-14 h-14 rounded-full
          bg-gray-900 dark:bg-gray-100
          text-white dark:text-gray-900
          shadow-lg hover:shadow-xl
          transition-all duration-200
          flex items-center justify-center
          ${isOpen ? 'scale-0 opacity-0' : 'scale-100 opacity-100'}
        `}
        aria-label={isOpen ? 'Close chat' : 'Open chat'}
      >
        {/* Pulse ring animation */}
        <span className="absolute inset-0 rounded-full bg-gray-900 dark:bg-gray-100 animate-ping opacity-20" />

        {/* Chat icon */}
        <svg
          className="w-6 h-6 relative z-10"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"
          />
        </svg>

        {/* Unread indicator */}
        {hasUnread && (
          <span className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full z-20" />
        )}
      </button>
    </>
  );
}


================================================
FILE: frontend/src/components/chat/ChatWindow.tsx
================================================
'use client';

import { useState, useRef, useEffect, useCallback } from 'react';
import { streamChat, uploadChatImage, getChatHistory, type ChatChunk } from '@/lib/api';
import ChatMessage from './ChatMessage';
import ChatInput from './ChatInput';

interface MockupData {
  type: 'mockup';
  analysis: {
    id: string;
    wall_image_url: string;
    wall_bounds: { top: number; bottom: number; left: number; right: number };
    pixels_per_inch: number;
    confidence: number;
  };
  photo: {
    slug: string;
    title: string;
    image_url: string;
    thumbnail_url: string;
  };
  variant: {
    id: number;
    size: string;
    material: 'paper' | 'aluminum';
    width_inches: number;
    height_inches: number;
    price: number;
  };
  message: string;
}

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  imageUrl?: string;
  photos?: Array<{
    slug: string;
    title: string;
    image_url?: string;
    thumbnail_url?: string;
    url?: string;
    price_range?: { min: number; max: number };
  }>;
  mockup?: MockupData;
  isStreaming?: boolean;
}

interface ChatWindowProps {
  conversationId: string | null;
  onConversationIdChange: (id: string) => void;
  onClose: () => void;
  onNewMessage: () => void;
}

const welcomeMessage: Message = {
  id: 'welcome',
  role: 'assistant',
  content:
    "Hi! I'm here to help you find the perfect print for your space. You can tell me what you're looking for, upload a photo of your room to see how prints would look, or just browse and ask questions. What can I help you with today?",
};

export default function ChatWindow({
  conversationId,
  onConversationIdChange,
  onClose,
  onNewMessage,
}: ChatWindowProps) {
  const [messages, setMessages] = useState<Message[]>([welcomeMessage]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [historyLoaded, setHistoryLoaded] = useState(false);

  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Load chat history when conversation ID exists
  // But DON'T load if we're currently loading (streaming a response)
  useEffect(() => {
    if (conversationId && !historyLoaded && !isLoading) {
      setHistoryLoaded(true);
      getChatHistory(conversationId)
        .then((data) => {
          if (data.messages && data.messages.length > 0) {
            const loadedMessages: Message[] = [];
            const allMessages = data.messages;

            for (let i = 0; i < allMessages.length; i++) {
              const msg = allMessages[i];

              if (msg.role === 'user') {
                loadedMessages.push({
                  id: `history-${msg.id}`,
                  role: 'user',
                  content: msg.content,
                  imageUrl: msg.image_url || undefined,
                });
              } else if (msg.role === 'assistant') {
                // Look for tool results in the following messages to extract photos
                const photos: Message['photos'] = [];
                if (msg.tool_calls && msg.tool_calls.length > 0) {
                  // Find corresponding tool result messages
                  for (let j = i + 1; j < allMessages.length && allMessages[j].role === 'tool'; j++) {
                    try {
                      const toolResult = JSON.parse(allMessages[j].content);
                      if (Array.isArray(toolResult)) {
                        for (const item of toolResult) {
                          if (item.slug && item.title && (item.thumbnail_url || item.image_url)) {
                            photos.push({
                              slug: item.slug,
                              title: item.title,
                              image_url: item.image_url,
                              thumbnail_url: item.thumbnail_url,
                              url: item.url,
                              price_range: item.price_range,
                            });
                          }
                        }
                      }
                    } catch {
                      // Skip malformed JSON
                    }
                  }
                }

                loadedMessages.push({
                  id: `history-${msg.id}`,
                  role: 'assistant',
                  content: msg.content,
                  photos: photos.length > 0 ? photos : undefined,
                });
              }
              // Skip 'tool' role messages - they're processed above
            }

            // Prepend welcome message and add loaded messages
            setMessages([welcomeMessage, ...loadedMessages]);
          }
        })
        .catch((err) => {
          console.error('Failed to load chat history:', err);
          // If loading history fails, start fresh
        });
    }
  }, [conversationId, historyLoaded, isLoading]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSendMessage = useCallback(
    async (content: string, imageFile?: File) => {
      if (!content.trim() && !imageFile) return;

      setError(null);
      setIsLoading(true);

      // Upload image first if provided
      let imageUrl: string | undefined;
      if (imageFile) {
        try {
          const result = await uploadChatImage(imageFile);
          imageUrl = result.url;
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to upload image');
          setIsLoading(false);
          return;
        }
      }

      // Add user message
      const userMessageId = `user-${Date.now()}`;
      setMessages((prev) => [
        ...prev,
        {
          id: userMessageId,
          role: 'user',
          content,
          imageUrl,
        },
      ]);

      // Add placeholder for assistant response
      const assistantMessageId = `assistant-${Date.now()}`;
      setMessages((prev) => [
        ...prev,
        {
          id: assistantMessageId,
          role: 'assistant',
          content: '',
          isStreaming: true,
        },
      ]);

      try {
        // Get cart ID from cookie/localStorage if available
        const cartId = localStorage.getItem('cart_id') || undefined;

        // Stream the response
        let currentConversationId = conversationId;
        let accumulatedContent = '';
        const photos: Message['photos'] = [];
        let mockup: MockupData | undefined;

        for await (const chunk of streamChat(
          content,
          currentConversationId || undefined,
          imageUrl,
          cartId
        )) {
          // Process streaming chunks
          switch (chunk.type) {
            case 'conversation_id':
              if (chunk.id && !currentConversationId) {
                currentConversationId = chunk.id;
                onConversationIdChange(chunk.id);
              }
              break;

            case 'text':
              if (chunk.content) {
                accumulatedContent += chunk.content;
                setMessages((prev) =>
                  prev.map((m) =>
                    m.id === assistantMessageId
                      ? { ...m, content: accumulatedContent }
                      : m
                  )
                );
              }
              break;

            case 'tool_result':
              // Extract photos from tool results
              if (chunk.result && Array.isArray(chunk.result)) {
                for (const item of chunk.result) {
                  if (item.slug && item.title && (item.thumbnail_url || item.image_url)) {
                    photos.push({
                      slug: item.slug,
                      title: item.title,
                      image_url: item.image_url,
                      thumbnail_url: item.thumbnail_url,
                      url: item.url,
                      price_range: item.price_range,
                    });
                  }
                }
              } else if (chunk.result && typeof chunk.result === 'object') {
                const result = chunk.result as Record<string, unknown>;

                // Handle mockup results
                if (result.type === 'mockup' && result.success) {
                  mockup = result as unknown as MockupData;
                }
                // Handle photo results
                else if (result.slug && result.title && (result.thumbnail_url || result.image_url)) {
                  photos.push({
                    slug: result.slug as string,
                    title: result.title as string,
                    image_url: result.image_url as string,
                    thumbnail_url: result.thumbnail_url as string,
                    url: result.url as string,
                    price_range: result.price_range as { min: number; max: number },
                  });
                }
                // Handle cart updates - save cart_id and trigger refresh
                if (result.cart_id && result.success) {
                  localStorage.setItem('cart_id', result.cart_id as string);
                  // Dispatch event to refresh cart in other components
                  window.dispatchEvent(new CustomEvent('cart-updated'));
                }
              }
              break;

            case 'error':
              setError(chunk.message || 'An error occurred');
              break;

            case 'done':
              // Finalize the message
              setMessages((prev) =>
                prev.map((m) =>
                  m.id === assistantMessageId
                    ? {
                        ...m,
                        isStreaming: false,
                        photos: photos.length > 0 ? photos : undefined,
                        mockup: mockup,
                      }
                    : m
                )
              );
              onNewMessage();
              break;
          }
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to send message');
        // Remove the streaming message on error
        setMessages((prev) => prev.filter((m) => m.id !== assistantMessageId));
      } finally {
        setIsLoading(false);
      }
    },
    [conversationId, onConversationIdChange, onNewMessage]
  );

  const handleNewConversation = useCallback(() => {
    setMessages([welcomeMessage]);
    setHistoryLoaded(false);
    onConversationIdChange('');
    localStorage.removeItem('chat_conversation_id');
  }, [onConversationIdChange]);

  return (
    <div className="fixed bottom-6 right-6 z-50 w-[400px] max-w-[calc(100vw-48px)] h-[600px] max-h-[calc(100vh-100px)] bg-white dark:bg-gray-900 rounded-lg shadow-2xl flex flex-col overflow-hidden border border-gray-200 dark:border-gray-700">
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
        <div className="flex items-center gap-2">
          <div className="w-2 h-2 bg-green-500 rounded-full" />
          <h3 className="font-medium text-gray-900 dark:text-gray-100">
            Shopping Assistant
          </h3>
        </div>
        <div className="flex items-center gap-1">
          <button
            onClick={handleNewConversation}
            className="p-1.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition"
            title="New conversation"
            aria-label="Start new conversation"
          >
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
          </button>
          <button
            onClick={onClose}
            className="p-1.5 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition"
            title="Close"
            aria-label="Close chat"
          >
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message) => (
          <ChatMessage key={message.id} message={message} />
        ))}

        {error && (
          <div className="p-3 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded text-sm">
            {error}
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <ChatInput onSend={handleSendMessage} isLoading={isLoading} />
    </div>
  );
}


================================================
FILE: frontend/src/components/chat/ChatMessage.tsx
================================================
'use client';

import Image from 'next/image';
import Link from 'next/link';
import ReactMarkdown from 'react-markdown';

interface Photo {
  slug: string;
  title: string;
  image_url?: string;
  thumbnail_url?: string;
  url?: string;
  price_range?: { min: number; max: number };
}

interface MockupData {
  type: 'mockup';
  analysis: {
    id: string;
    wall_image_url: string;
    wall_bounds: { top: number; bottom: number; left: number; right: number };
    pixels_per_inch: number;
    confidence: number;
  };
  photo: {
    slug: string;
    title: string;
    image_url: string;
    thumbnail_url: string;
  };
  variant: {
    id: number;
    size: string;
    material: 'paper' | 'aluminum';
    width_inches: number;
    height_inches: number;
    price: number;
  };
  message: string;
}

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  imageUrl?: string;
  photos?: Photo[];
  mockup?: MockupData;
  isStreaming?: boolean;
}

interface ChatMessageProps {
  message: Message;
}

// Mockup preview component with proper print positioning
function MockupPreview({ mockup }: { mockup: MockupData }) {
  const { analysis, photo, variant } = mockup;
  const bounds = analysis.wall_bounds;

  // Calculate print size relative to the wall
  // Use pixels_per_inch to determine how big the print should appear
  const ppi = analysis.pixels_per_inch || 50; // fallback
  const printWidthPx = variant.width_inches * ppi;
  const printHeightPx = variant.height_inches * ppi;

  // Wall dimensions in pixels (from bounds)
  const wallWidth = bounds.right - bounds.left;
  const wallHeight = bounds.bottom - bounds.top;

  // Calculate print size as percentage of container
  // Assume image fills the container width, scale accordingly
  const printWidthPercent = Math.min((printWidthPx / wallWidth) * 100, 80);

  // Calculate mat border for paper prints
  // Paper mat sizes: 11x14 in 16x20 mat, 13x19 in 18x24 mat
  // Mat border is approximately 2.5" on each side
  const matBorderInches = variant.material === 'paper' ? 2.5 : 0;
  const matBorderPx = matBorderInches * ppi;
  // Scale mat border relative to wall width (same as print scaling)
  const matBorderPercent = (matBorderPx / wallWidth) * 100;

  // Center the print horizontally within wall bounds, vertically centered
  const wallCenterX = (bounds.left + bounds.right) / 2;
  const wallCenterY = (bounds.top + bounds.bottom) / 2;

  // These are approximate - would need image dimensions for perfect positioning
  // For now, center in the detected wall area
  const leftPercent = 50; // Center horizontally
  const topPercent = 35; // Slightly above center (typical hanging height)

  // For paper prints, the outer container is the mat (print + border)
  // For aluminum, it's just the print
  const totalWidthPercent = variant.material === 'paper'
    ? Math.min(printWidthPercent + (matBorderPercent * 2), 85)
    : printWidthPercent;

  return (
    <div className="mt-3 bg-white dark:bg-gray-700 rounded overflow-hidden">
      <div className="relative aspect-[3/4] bg-gray-100 dark:bg-gray-800 overflow-hidden">
        {/* Wall/room image */}
        <Image
          src={analysis.wall_image_url}
          alt="Your room"
          fill
          className="object-cover"
          unoptimized
        />
        {/* Print overlay - paper prints get white mat border (visual mat effect), aluminum has no border */}
        {/* Only add white background/padding for paper material - aluminum is edge-to-edge */}
        <div
          className={`absolute z-10 shadow-2xl ${variant.material === 'paper' ? 'bg-white' : ''}`}
          style={{
            top: `${topPercent}%`,
            left: `${leftPercent}%`,
            transform: 'translate(-50%, -50%)',
            width: `${totalWidthPercent}%`,
            maxWidth: '70%',
            // For paper prints, add padding proportional to the mat border
            padding: variant.material === 'paper' ? `${matBorderPercent}%` : 0,
          }}
        >
          <Image
            src={photo.image_url}
            alt={photo.title}
            width={400}
            height={300}
            className="w-full h-auto"
            unoptimized
          />
        </div>
      </div>
      <div className="p-3">
        <p className="font-medium text-sm text-gray-900 dark:text-gray-100">
          {photo.title}
        </p>
        <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
          {variant.size} - ${variant.price.toLocaleString()}
        </p>
        <Link
          href={`/photos/${photo.slug}`}
          className="mt-2 inline-block text-xs text-blue-600 dark:text-blue-400 hover:underline"
        >
          View print details â†’
        </Link>
      </div>
    </div>
  );
}

// Parse JSON block from message content to extract photos
function parsePhotosFromContent(content: string): { cleanContent: string; photos: Photo[] } {
  const jsonMatch = content.match(/```json\s*(\{[\s\S]*?"photos"[\s\S]*?\})\s*```/);
  if (jsonMatch) {
    try {
      const data = JSON.parse(jsonMatch[1]);
      if (data.photos && Array.isArray(data.photos)) {
        return {
          cleanContent: content.replace(jsonMatch[0], '').trim(),
          photos: data.photos,
        };
      }
    } catch {
      // Invalid JSON, ignore
    }
  }
  return { cleanContent: content, photos: [] };
}

export default function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.role === 'user';

  // Parse photos from content JSON block if present
  const { cleanContent, photos: parsedPhotos } = parsePhotosFromContent(message.content);

  // Deduplicate photos by slug - prefer tool result photos (they have more data)
  const photoMap = new Map<string, Photo>();
  for (const photo of (message.photos || [])) {
    photoMap.set(photo.slug, photo);
  }
  for (const photo of parsedPhotos) {
    if (!photoMap.has(photo.slug)) {
      photoMap.set(photo.slug, photo);
    }
  }
  const allPhotos = Array.from(photoMap.values());

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      <div
        className={`
          max-w-[85%] rounded-lg px-4 py-2
          ${
            isUser
              ? 'bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900'
              : 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100'
          }
        `}
      >
        {/* User's attached image */}
        {message.imageUrl && (
          <div className="mb-2 -mx-2 -mt-1">
            <Image
              src={message.imageUrl}
              alt="Attached image"
              width={200}
              height={150}
              className="rounded object-cover"
            />
          </div>
        )}

        {/* Message content */}
        <div className="text-sm prose prose-sm dark:prose-invert max-w-none prose-p:my-1 prose-headings:my-2 prose-ul:my-1 prose-li:my-0">
          {isUser ? (
            <p className="whitespace-pre-wrap m-0">{cleanContent}</p>
          ) : (
            <ReactMarkdown
              components={{
                // Compact styling for chat
                h2: ({ children }) => <h2 className="text-base font-semibold mt-3 mb-1">{children}</h2>,
                h3: ({ children }) => <h3 className="text-sm font-semibold mt-2 mb-1">{children}</h3>,
                p: ({ children }) => <p className="my-1">{children}</p>,
                ul: ({ children }) => <ul className="my-1 ml-4 list-disc">{children}</ul>,
                li: ({ children }) => <li className="my-0.5">{children}</li>,
                strong: ({ children }) => <strong className="font-semibold">{children}</strong>,
              }}
            >
              {cleanContent}
            </ReactMarkdown>
          )}
          {message.isStreaming && (
            <span className="inline-block w-2 h-4 ml-1 bg-current animate-pulse" />
          )}
        </div>

        {/* Photo cards from search results */}
        {allPhotos.length > 0 && (
          <div className="mt-3 space-y-2">
            {allPhotos.slice(0, 6).map((photo, index) => {
              const imageUrl = photo.thumbnail_url || photo.image_url;
              const photoUrl = photo.url || `/photos/${photo.slug}`;
              if (!imageUrl) return null;

              return (
                <Link
                  key={`${photo.slug}-${index}`}
                  href={photoUrl}
                  className="block bg-white dark:bg-gray-700 rounded overflow-hidden hover:shadow-md transition"
                >
                  <div className="flex gap-3 p-2">
                    <div className="w-16 h-16 flex-shrink-0 relative">
                      <Image
                        src={imageUrl}
                        alt={photo.title}
                        fill
                        className="object-cover rounded"
                        sizes="64px"
                        unoptimized
                      />
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-sm truncate text-gray-900 dark:text-gray-100">
                        {photo.title}
                      </p>
                      {photo.price_range && (
                        <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                          ${photo.price_range.min.toLocaleString()} - $
                          {photo.price_range.max.toLocaleString()}
                        </p>
                      )}
                    </div>
                    <svg
                      className="w-4 h-4 text-gray-400 flex-shrink-0 self-center"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M9 5l7 7-7 7"
                      />
                    </svg>
                  </div>
                </Link>
              );
            })}
            {allPhotos.length > 6 && (
              <p className="text-xs text-gray-500 dark:text-gray-400 text-center">
                +{allPhotos.length - 6} more
              </p>
            )}
          </div>
        )}

        {/* Mockup preview */}
        {message.mockup && (
          <MockupPreview mockup={message.mockup} />
        )}
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/components/chat/ChatInput.tsx
================================================
'use client';

import { useState, useRef } from 'react';

interface ChatInputProps {
  onSend: (message: string, imageFile?: File) => void;
  isLoading: boolean;
}

export default function ChatInput({ onSend, isLoading }: ChatInputProps) {
  const [message, setMessage] = useState('');
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [imageFile, setImageFile] = useState<File | null>(null);

  const fileInputRef = useRef<HTMLInputElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if ((!message.trim() && !imageFile) || isLoading) return;

    onSend(message.trim(), imageFile || undefined);
    setMessage('');
    setImagePreview(null);
    setImageFile(null);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit(e);
    }
  };

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file type
    if (!file.type.startsWith('image/')) {
      return;
    }

    // Validate file size (max 10MB)
    if (file.size > 10 * 1024 * 1024) {
      return;
    }

    setImageFile(file);

    // Create preview
    const reader = new FileReader();
    reader.onloadend = () => {
      setImagePreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  };

  const removeImage = () => {
    setImagePreview(null);
    setImageFile(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="border-t border-gray-200 dark:border-gray-700 p-3"
    >
      {/* Image preview */}
      {imagePreview && (
        <div className="mb-2 relative inline-block">
          <img
            src={imagePreview}
            alt="Upload preview"
            className="h-20 rounded object-cover"
          />
          <button
            type="button"
            onClick={removeImage}
            className="absolute -top-2 -right-2 w-5 h-5 bg-red-500 text-white rounded-full flex items-center justify-center text-xs hover:bg-red-600"
            aria-label="Remove image"
          >
            &times;
          </button>
        </div>
      )}

      <div className="flex items-end gap-2">
        {/* Image upload button */}
        <button
          type="button"
          onClick={() => fileInputRef.current?.click()}
          disabled={isLoading}
          className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition disabled:opacity-50"
          title="Upload room photo"
          aria-label="Upload image"
        >
          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
            />
          </svg>
        </button>

        <input
          ref={fileInputRef}
          type="file"
          accept="image/*"
          onChange={handleImageSelect}
          className="hidden"
        />

        {/* Text input */}
        <textarea
          ref={textareaRef}
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Ask about prints, sizes, or upload a room photo..."
          aria-label="Type your message"
          disabled={isLoading}
          rows={1}
          className="
            flex-1 resize-none rounded-lg border border-gray-300 dark:border-gray-600
            bg-white dark:bg-gray-800
            px-3 py-2 text-sm
            focus:outline-none focus:ring-2 focus:ring-gray-900 dark:focus:ring-gray-100
            disabled:opacity-50
          "
          style={{ minHeight: '40px', maxHeight: '120px' }}
        />

        {/* Send button */}
        <button
          type="submit"
          disabled={(!message.trim() && !imageFile) || isLoading}
          aria-label="Send message"
          className="
            p-2 rounded-lg
            bg-gray-900 dark:bg-gray-100
            text-white dark:text-gray-900
            hover:bg-gray-800 dark:hover:bg-gray-200
            disabled:opacity-50 disabled:cursor-not-allowed
            transition
          "
        >
          {isLoading ? (
            <svg className="w-5 h-5 animate-spin" fill="none" viewBox="0 0 24 24">
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
          ) : (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"
              />
            </svg>
          )}
        </button>
      </div>
    </form>
  );
}


================================================
FILE: frontend/src/components/mockup/MockupTool.tsx
================================================
'use client';

import { useState, useRef, useCallback, useEffect } from 'react';
import type { Photo, ProductVariant, WallAnalysis } from '@/types';
import {
  uploadWallImage,
  pollWallAnalysis,
  updateWallAnalysis,
  saveMockup,
  getPhotos,
  getPhoto,
} from '@/lib/api';
import WallUploader from './WallUploader';
import WallCanvas from './WallCanvas';
import CeilingSlider from './CeilingSlider';
import PrintSelector from './PrintSelector';

// Processing stage messages
const PROCESSING_STAGES = [
  { time: 0, message: 'Uploading your image...' },
  { time: 10, message: 'Detecting walls and surfaces...' },
  { time: 25, message: 'Analyzing room dimensions...' },
  { time: 40, message: 'Calculating optimal placement...' },
  { time: 55, message: 'Almost there...' },
];

interface MockupPrint {
  id: string;
  photo: Photo;
  variant: ProductVariant;
  position: { x: number; y: number };
}

interface MockupToolProps {
  initialPhoto?: Photo;
  initialVariant?: ProductVariant;
  onClose: () => void;
}

type Step = 'upload' | 'processing' | 'editor';

export default function MockupTool({ initialPhoto, initialVariant, onClose }: MockupToolProps) {
  // State
  const [step, setStep] = useState<Step>('upload');
  const [isUploading, setIsUploading] = useState(false);
  const [analysis, setAnalysis] = useState<WallAnalysis | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [processingStartTime, setProcessingStartTime] = useState<number | null>(null);
  const [processingMessage, setProcessingMessage] = useState(PROCESSING_STAGES[0].message);

  // Editor state
  const [ceilingHeight, setCeilingHeight] = useState(8);
  const [prints, setPrints] = useState<MockupPrint[]>([]);
  const [availablePhotos, setAvailablePhotos] = useState<Photo[]>([]);
  const [selectedPhoto, setSelectedPhoto] = useState<Photo | null>(initialPhoto || null);
  const [selectedVariant, setSelectedVariant] = useState<ProductVariant | null>(initialVariant || null);
  const [isLoadingPhoto, setIsLoadingPhoto] = useState(false);

  // Saving state
  const [isSaving, setIsSaving] = useState(false);
  const [shareUrl, setShareUrl] = useState<string | null>(null);

  // Canvas ref for export
  const canvasRef = useRef<{ toDataURL: () => string } | null>(null);

  // Load available photos
  useEffect(() => {
    getPhotos()
      .then((data) => {
        setAvailablePhotos(data.results || []);
        // If we have an initial photo, make sure it has variants
        if (initialPhoto && initialPhoto.variants) {
          setSelectedPhoto(initialPhoto);
        }
      })
      .catch(console.error);
  }, [initialPhoto]);

  // Update processing message based on elapsed time
  useEffect(() => {
    if (step !== 'processing' || !processingStartTime) return;

    const interval = setInterval(() => {
      const elapsed = (Date.now() - processingStartTime) / 1000;

      // Find the appropriate message for current elapsed time
      for (let i = PROCESSING_STAGES.length - 1; i >= 0; i--) {
        if (elapsed >= PROCESSING_STAGES[i].time) {
          setProcessingMessage(PROCESSING_STAGES[i].message);
          break;
        }
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [step, processingStartTime]);

  // Handle wall image upload
  const handleUpload = useCallback(async (file: File) => {
    setIsUploading(true);
    setError(null);
    setProcessingStartTime(Date.now());
    setProcessingMessage(PROCESSING_STAGES[0].message);

    try {
      const result = await uploadWallImage(file);
      setAnalysis(result);

      if (result.status === 'pending' || result.status === 'processing') {
        setStep('processing');
        // Poll for completion
        const completed = await pollWallAnalysis(result.id, (status) => {
          setAnalysis((prev) => (prev ? { ...prev, status: status as WallAnalysis['status'] } : null));
        });
        setAnalysis(completed);
        setStep('editor');
      } else {
        // Already completed or manual
        setStep('editor');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setIsUploading(false);
      setProcessingStartTime(null);
    }
  }, []);

  // Handle sample wall selection - use directly without S3 upload
  const handleSampleWallSelect = useCallback(async (wallUrl: string) => {
    setIsUploading(true);
    setError(null);

    try {
      // Load image to get dimensions
      const img = new Image();
      img.crossOrigin = 'anonymous';

      await new Promise<void>((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = () => reject(new Error('Failed to load sample wall image'));
        img.src = wallUrl;
      });

      // Create a mock analysis for sample walls (no S3 upload needed)
      // Use the local URL directly - no CORS issues with same-origin images
      const mockAnalysis: WallAnalysis = {
        id: `sample-${Date.now()}`,
        status: 'manual',
        original_image: wallUrl, // Use local URL directly
        original_width: img.width,
        original_height: img.height,
        wall_bounds: {
          top: Math.round(img.height * 0.1),
          bottom: Math.round(img.height * 0.9),
          left: Math.round(img.width * 0.1),
          right: Math.round(img.width * 0.9),
        },
        confidence: 0.8,
        pixels_per_inch: null,
        wall_height_feet: 8,
        error_message: '',
        created_at: new Date().toISOString(),
        completed_at: new Date().toISOString(),
        depth_map: null,
        wall_mask: null,
      };

      setAnalysis(mockAnalysis);
      setStep('editor');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load sample wall');
    } finally {
      setIsUploading(false);
    }
  }, []);

  // Handle ceiling height change
  const handleCeilingHeightChange = useCallback(
    async (height: number) => {
      setCeilingHeight(height);

      if (analysis) {
        // For sample walls (local mock), just update state
        if (analysis.id.startsWith('sample-')) {
          setAnalysis({ ...analysis, wall_height_feet: height });
          return;
        }

        // For uploaded walls, update via API
        try {
          const updated = await updateWallAnalysis(analysis.id, {
            wall_height_feet: height,
          });
          setAnalysis(updated);
        } catch (err) {
          console.error('Failed to update analysis:', err);
        }
      }
    },
    [analysis]
  );

  // Add print to wall
  const handleAddPrint = useCallback(() => {
    if (!selectedPhoto || !selectedVariant) return;

    const newPrint: MockupPrint = {
      id: `print-${Date.now()}`,
      photo: selectedPhoto,
      variant: selectedVariant,
      position: { x: 0, y: 0 }, // Will be centered by canvas
    };

    setPrints((prev) => [...prev, newPrint]);
  }, [selectedPhoto, selectedVariant]);

  // Update print position
  const handlePrintMove = useCallback((printId: string, position: { x: number; y: number }) => {
    setPrints((prev) =>
      prev.map((p) => (p.id === printId ? { ...p, position } : p))
    );
  }, []);

  // Remove print
  const handlePrintRemove = useCallback((printId: string) => {
    setPrints((prev) => prev.filter((p) => p.id !== printId));
  }, []);

  // Download mockup
  const handleDownload = useCallback(() => {
    if (!canvasRef.current) return;

    const dataUrl = canvasRef.current.toDataURL();
    const link = document.createElement('a');
    link.download = 'wall-mockup.jpg';
    link.href = dataUrl;
    link.click();
  }, []);

  // Save and get share link
  const handleSave = useCallback(async () => {
    if (!canvasRef.current || !analysis) return;

    // For sample walls, sharing is not supported (just use download)
    if (analysis.id.startsWith('sample-')) {
      setError('Sharing is not available for sample walls. Use Download instead.');
      return;
    }

    setIsSaving(true);
    try {
      const mockupImage = canvasRef.current.toDataURL();
      const result = await saveMockup({
        analysis_id: analysis.id,
        mockup_image: mockupImage,
        config: {
          prints: prints.map((p) => ({
            photo_id: p.photo.id,
            variant_id: p.variant.id,
            position: p.position,
          })),
          wall_height_feet: ceilingHeight,
        },
      });
      setShareUrl(result.share_url);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save');
    } finally {
      setIsSaving(false);
    }
  }, [analysis, prints, ceilingHeight]);

  // Copy share link
  const handleCopyLink = useCallback(() => {
    if (shareUrl) {
      navigator.clipboard.writeText(shareUrl);
    }
  }, [shareUrl]);

  // Calculate pixels per inch
  const pixelsPerInch = analysis?.pixels_per_inch || (analysis?.wall_bounds
    ? (analysis.wall_bounds.bottom - analysis.wall_bounds.top) / (ceilingHeight * 12)
    : 10);

  return (
    <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
      <div className="bg-white dark:bg-gray-900 rounded-lg max-w-6xl w-full max-h-[90vh] overflow-hidden flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-3">
            {step === 'editor' && (
              <button
                onClick={() => {
                  setStep('upload');
                  setAnalysis(null);
                  setPrints([]);
                  setShareUrl(null);
                  setError(null);
                }}
                className="p-1.5 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition"
                aria-label="Back to upload"
              >
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
              </button>
            )}
            <h2 className="text-xl font-medium text-gray-900 dark:text-gray-100">
              {step === 'editor' ? 'Edit Mockup' : 'See In Your Room'}
            </h2>
          </div>
          <button
            onClick={onClose}
            className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition"
            aria-label="Close mockup tool"
          >
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-4">
          {error && (
            <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded">
              {error}
            </div>
          )}

          {/* Upload Step */}
          {step === 'upload' && (
            <div className="max-w-lg mx-auto">
              <WallUploader
                onUpload={handleUpload}
                onSelectSampleWall={handleSampleWallSelect}
                isUploading={isUploading}
              />
            </div>
          )}

          {/* Processing Step */}
          {step === 'processing' && (
            <div className="text-center py-12">
              <div className="w-14 h-14 border-2 border-gray-200 dark:border-gray-700 border-t-blue-500 rounded-full animate-spin mx-auto mb-6" />
              <p className="text-lg text-gray-700 dark:text-gray-300 mb-2">
                {processingMessage}
              </p>
              <p className="text-sm text-gray-400 dark:text-gray-500">
                This typically takes about a minute
              </p>
            </div>
          )}

          {/* Editor Step */}
          {step === 'editor' && analysis && (
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              {/* Canvas */}
              <div className="lg:col-span-2">
                <WallCanvas
                  wallImage={analysis.original_image}
                  wallBounds={analysis.wall_bounds}
                  pixelsPerInch={pixelsPerInch}
                  prints={prints}
                  onPrintMove={handlePrintMove}
                  onPrintRemove={handlePrintRemove}
                  canvasRef={canvasRef}
                />

                {/* Confidence indicator */}
                {analysis.confidence !== null && (
                  <div className="mt-2 text-sm">
                    <span className="text-gray-500 dark:text-gray-400">Wall detection: </span>
                    <span
                      className={`font-medium ${
                        analysis.confidence >= 0.5
                          ? 'text-green-600 dark:text-green-400'
                          : analysis.confidence >= 0.3
                          ? 'text-yellow-600 dark:text-yellow-400'
                          : 'text-red-600 dark:text-red-400'
                      }`}
                    >
                      {Math.round(analysis.confidence * 100)}%
                    </span>
                    {analysis.status === 'manual' && (
                      <span className="text-gray-400 dark:text-gray-500 ml-2">
                        (manual selection)
                      </span>
                    )}
                  </div>
                )}
              </div>

              {/* Controls */}
              <div className="space-y-6">
                {/* Ceiling Height */}
                <CeilingSlider
                  value={ceilingHeight}
                  onChange={handleCeilingHeightChange}
                />

                {/* Print Selector */}
                <PrintSelector
                  photos={availablePhotos}
                  selectedPhoto={selectedPhoto}
                  selectedVariant={selectedVariant}
                  onSelectPhoto={async (photo) => {
                    setSelectedVariant(null);
                    setIsLoadingPhoto(true);
                    try {
                      // Fetch full photo data with variants
                      const fullPhoto = await getPhoto(photo.slug);
                      setSelectedPhoto(fullPhoto);
                    } catch (err) {
                      console.error('Failed to load photo details:', err);
                      setSelectedPhoto(photo);
                    } finally {
                      setIsLoadingPhoto(false);
                    }
                  }}
                  onSelectVariant={setSelectedVariant}
                  onAddPrint={handleAddPrint}
                  disabled={isLoadingPhoto}
                />

                {/* Actions */}
                <div className="space-y-2 pt-4 border-t border-gray-200 dark:border-gray-700">
                  <button
                    onClick={handleDownload}
                    disabled={prints.length === 0}
                    className="w-full py-2 bg-gray-900 dark:bg-gray-100 text-white dark:text-gray-900 rounded hover:bg-gray-800 dark:hover:bg-gray-200 transition disabled:opacity-50"
                  >
                    Download Image
                  </button>

                  {/* Hide share button for sample walls */}
                  {!analysis?.id.startsWith('sample-') && (
                    <button
                      onClick={handleSave}
                      disabled={prints.length === 0 || isSaving}
                      className="w-full py-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-gray-50 dark:hover:bg-gray-800 transition disabled:opacity-50"
                    >
                      {isSaving ? 'Saving...' : 'Get Shareable Link'}
                    </button>
                  )}

                  {shareUrl && (
                    <div className="p-3 bg-green-50 dark:bg-green-900/20 rounded">
                      <p className="text-sm text-green-700 dark:text-green-300 mb-2">
                        Mockup saved!
                      </p>
                      <div className="flex gap-2">
                        <input
                          type="text"
                          value={shareUrl}
                          readOnly
                          className="flex-1 px-2 py-1 text-sm bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded"
                        />
                        <button
                          onClick={handleCopyLink}
                          className="px-3 py-1 text-sm bg-green-600 text-white rounded hover:bg-green-700"
                        >
                          Copy
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}


================================================
FILE: frontend/src/components/mockup/WallCanvas.tsx
================================================
'use client';

import { useEffect, useRef, useCallback, useState } from 'react';
import type { Photo, ProductVariant, WallAnalysis } from '@/types';

interface MockupPrintData {
  id: string;
  photo: Photo;
  variant: ProductVariant;
  position: { x: number; y: number };
}

interface WallCanvasProps {
  wallImage: string;
  wallBounds: WallAnalysis['wall_bounds'];
  pixelsPerInch: number;
  prints: MockupPrintData[];
  onPrintMove?: (printId: string, position: { x: number; y: number }) => void;
  onPrintRemove?: (printId: string) => void;
  canvasRef?: React.RefObject<{ toDataURL: () => string } | null>;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type FabricType = any;

export default function WallCanvas({
  wallImage,
  wallBounds,
  pixelsPerInch,
  prints,
  onPrintMove,
  onPrintRemove,
  canvasRef,
}: WallCanvasProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasElementRef = useRef<HTMLCanvasElement>(null);
  const fabricRef = useRef<FabricType>(null);
  const fabricModuleRef = useRef<FabricType>(null);
  const printObjectsRef = useRef<Map<string, FabricType>>(new Map());
  const [fabricLoaded, setFabricLoaded] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });
  const [scale, setScale] = useState(1);
  const imageDimensionsRef = useRef({ width: 0, height: 0 });

  // Load Fabric.js dynamically
  useEffect(() => {
    import('fabric').then((mod) => {
      fabricModuleRef.current = mod;
      setFabricLoaded(true);
    });
  }, []);

  // Load wall image dimensions first
  useEffect(() => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      imageDimensionsRef.current = { width: img.width, height: img.height };
      setImageLoaded(true);
    };
    img.onerror = (err) => {
      console.error('Failed to load wall image for dimensions:', err);
    };
    img.src = wallImage;
  }, [wallImage]);

  // Calculate canvas size based on container and image
  useEffect(() => {
    if (!containerRef.current || !imageLoaded) return;

    const updateSize = () => {
      const container = containerRef.current;
      if (!container) return;

      const { width: imgWidth, height: imgHeight } = imageDimensionsRef.current;
      if (!imgWidth || !imgHeight) return;

      const containerWidth = container.clientWidth;
      const maxHeight = window.innerHeight * 0.6;
      const imageAspect = imgWidth / imgHeight;

      let width: number;
      let height: number;

      // For portrait images (taller than wide), fit to height first
      if (imageAspect < 1) {
        height = Math.min(maxHeight, 500);
        width = height * imageAspect;
        // Ensure width doesn't exceed container
        if (width > containerWidth) {
          width = containerWidth;
          height = width / imageAspect;
        }
      } else {
        // Landscape images - fit to width first
        width = Math.min(containerWidth, 600);
        height = width / imageAspect;
        if (height > maxHeight) {
          height = maxHeight;
          width = height * imageAspect;
        }
      }

      setCanvasSize({ width: Math.round(width), height: Math.round(height) });
      setScale(width / imgWidth);
    };

    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, [wallImage, imageLoaded]);

  // Initialize Fabric.js canvas
  useEffect(() => {
    if (!fabricLoaded || !canvasElementRef.current || !fabricModuleRef.current || !canvasSize.width || !canvasSize.height) return;

    const fabric = fabricModuleRef.current;

    // Dispose existing canvas
    if (fabricRef.current) {
      fabricRef.current.dispose();
    }

    // Create new canvas
    const canvas = new fabric.Canvas(canvasElementRef.current, {
      selection: true,
      preserveObjectStacking: true,
      width: canvasSize.width,
      height: canvasSize.height,
    });
    fabricRef.current = canvas;

    // Load wall image as background
    fabric.FabricImage.fromURL(wallImage, { crossOrigin: 'anonymous' }).then((img: FabricType) => {
      // Scale image to fit canvas
      const scaleX = canvasSize.width / img.width;
      const scaleY = canvasSize.height / img.height;
      img.set({
        scaleX: scaleX,
        scaleY: scaleY,
        originX: 'left',
        originY: 'top',
        left: 0,
        top: 0,
      });
      canvas.backgroundImage = img;
      canvas.renderAll();
    }).catch((err: Error) => {
      console.error('Failed to load wall image:', err);
    });

    // Handle object movement
    canvas.on('object:modified', () => {
      const activeObj = canvas.getActiveObject();
      if (activeObj && activeObj.printId && onPrintMove) {
        onPrintMove(activeObj.printId, {
          x: activeObj.left / scale,
          y: activeObj.top / scale,
        });
      }
    });

    return () => {
      canvas.dispose();
    };
  }, [fabricLoaded, canvasSize, wallImage, scale, onPrintMove]);

  // Add/update prints on canvas
  useEffect(() => {
    if (!fabricRef.current || !fabricLoaded || !fabricModuleRef.current) return;

    const fabric = fabricModuleRef.current;
    const canvas = fabricRef.current;

    // Track which prints we've seen
    const currentPrintIds = new Set(prints.map((p) => p.id));

    // Remove prints that are no longer in the list
    printObjectsRef.current.forEach((obj, printId) => {
      if (!currentPrintIds.has(printId)) {
        canvas.remove(obj);
        printObjectsRef.current.delete(printId);
      }
    });

    // Add new prints
    prints.forEach((print) => {
      if (printObjectsRef.current.has(print.id)) return;

      // Calculate print size in canvas pixels
      const printWidthInches = print.variant.width_inches;
      const printHeightInches = print.variant.height_inches;
      const printWidthPx = printWidthInches * pixelsPerInch * scale;
      const printHeightPx = printHeightInches * pixelsPerInch * scale;

      // Default position: center of wall bounds
      let defaultX = canvasSize.width / 2 - printWidthPx / 2;
      let defaultY = canvasSize.height / 2 - printHeightPx / 2;

      if (wallBounds) {
        const scaledBounds = {
          left: wallBounds.left * scale,
          right: wallBounds.right * scale,
          top: wallBounds.top * scale,
          bottom: wallBounds.bottom * scale,
        };
        defaultX = (scaledBounds.left + scaledBounds.right) / 2 - printWidthPx / 2;
        defaultY = (scaledBounds.top + scaledBounds.bottom) / 2 - printHeightPx / 2;
      }

      const posX = print.position.x ? print.position.x * scale : defaultX;
      const posY = print.position.y ? print.position.y * scale : defaultY;

      fabric.FabricImage.fromURL(print.photo.image, { crossOrigin: 'anonymous' }).then((img: FabricType) => {
        const scaleToFit = printWidthPx / img.width;
        img.scaleX = scaleToFit;
        img.scaleY = scaleToFit * (printHeightPx / (img.height * scaleToFit));
        img.set({
          left: posX,
          top: posY,
          hasControls: true,
          hasBorders: true,
          lockRotation: true,
          lockUniScaling: true,
          cornerColor: '#3b82f6',
          cornerStyle: 'circle',
          borderColor: '#3b82f6',
          shadow: new fabric.Shadow({
            color: 'rgba(0,0,0,0.4)',
            blur: 20,
            offsetX: 8,
            offsetY: 8,
          }),
        });

        // Store custom data on the object
        img.printId = print.id;

        canvas.add(img);
        canvas.setActiveObject(img);
        canvas.renderAll();
        printObjectsRef.current.set(print.id, img);
      });
    });
  }, [prints, fabricLoaded, pixelsPerInch, scale, canvasSize, wallBounds]);

  // Expose toDataURL method
  const getDataURL = useCallback(() => {
    if (!fabricRef.current) return '';
    return fabricRef.current.toDataURL({
      format: 'jpeg',
      quality: 0.9,
      multiplier: 2,
    });
  }, []);

  // Set ref for parent access
  useEffect(() => {
    if (canvasRef && 'current' in canvasRef) {
      (canvasRef as { current: { toDataURL: () => string } | null }).current = {
        toDataURL: getDataURL,
      };
    }
  }, [canvasRef, getDataURL]);

  // Remove selected print
  const handleRemoveSelected = useCallback(() => {
    if (!fabricRef.current) return;
    const activeObj = fabricRef.current.getActiveObject();
    if (activeObj && activeObj.printId) {
      onPrintRemove?.(activeObj.printId);
    }
  }, [onPrintRemove]);

  return (
    <div ref={containerRef} className="relative w-full flex justify-center">
      {canvasSize.width > 0 && canvasSize.height > 0 ? (
        <canvas ref={canvasElementRef} className="border border-gray-200 dark:border-gray-700 rounded" />
      ) : (
        <div className="w-full h-64 flex items-center justify-center bg-gray-100 dark:bg-gray-800 rounded">
          <span className="text-gray-500">Loading wall image...</span>
        </div>
      )}

      {/* Remove button - only show when there are prints */}
      {prints.length > 0 && (
        <button
          onClick={handleRemoveSelected}
          className="absolute top-2 right-2 p-2 bg-red-500 text-white rounded-full hover:bg-red-600 transition shadow-lg flex items-center gap-1"
          title="Remove selected print"
          aria-label="Remove selected print"
        >
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      )}

      {/* Instructions */}
      {canvasSize.width > 0 && (
        <p className="absolute bottom-2 left-2 right-2 text-xs text-gray-600 dark:text-gray-300 text-center bg-black/50 dark:bg-black/70 rounded px-2 py-1">
          Drag prints to reposition. Use corners to resize.{prints.length > 0 && ' Tap print then âœ• to remove.'}
        </p>
      )}
    </div>
  );
}


### ROOT CONFIG ###
================================================
FILE: CLAUDE.md
================================================
# Matthew Raynor Photography Store - Project Context

## Overview
E-commerce website for fine art photography prints targeting the Hamptons luxury art market. Sells photo prints (paper and aluminum), a photography book, and gift cards.

**Live Site:** https://store.matthewraynor.com

**Active Code Review:** See [CODE_REVIEW.md](CODE_REVIEW.md) for tracked findings and implementation status.

---

## Tech Stack

| Layer | Technology |
|-------|------------|
| Frontend | Next.js 15+ (App Router), TypeScript, Tailwind CSS |
| Backend | Django 5, Django REST Framework |
| Database | PostgreSQL 16 with pgvector |
| Payments | Stripe Checkout |
| Email | Resend SMTP |
| Newsletter | MailerLite |
| Media Storage | AWS S3 |
| Frontend Hosting | Netlify (with `@netlify/plugin-nextjs`) |
| Backend Hosting | Railway (web + Celery worker + Redis) |
| AI | Claude (chat agent), OpenAI (embeddings) |

---

## Project Structure

```
store/
â”œâ”€â”€ backend/                 # Django API
â”‚   â”œâ”€â”€ apps/
â”‚   â”‚   â”œâ”€â”€ catalog/         # Collections, Photos, ProductVariants, Products
â”‚   â”‚   â”œâ”€â”€ orders/          # Cart, CartItem, Order, OrderItem
â”‚   â”‚   â”œâ”€â”€ core/            # Contact form, Newsletter, Gift Cards
â”‚   â”‚   â”œâ”€â”€ payments/        # Stripe webhooks, checkout, gift card redemption
â”‚   â”‚   â”œâ”€â”€ chat/            # AI shopping agent (LangChain + Claude)
â”‚   â”‚   â””â”€â”€ mockup/          # "See in room" ML wall detection
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ settings/
â”‚   â”‚       â”œâ”€â”€ base.py      # Shared settings
â”‚   â”‚       â”œâ”€â”€ development.py
â”‚   â”‚       â””â”€â”€ production.py
â”‚   â”œâ”€â”€ start.sh             # Production startup script
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ Procfile
â”œâ”€â”€ frontend/                # Next.js App
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/             # App Router pages
â”‚   â”‚   â”œâ”€â”€ components/      # Shared React components
â”‚   â”‚   â””â”€â”€ lib/
â”‚   â”‚       â””â”€â”€ api.ts       # API client functions
â”‚   â”œâ”€â”€ netlify.toml
â”‚   â””â”€â”€ Dockerfile
â””â”€â”€ docker-compose.yml
```

---

## Collections

| Collection | Description |
|------------|-------------|
| Shots from the Sea | Commercial fishing era photography |
| Travel Photography | Global destinations |
| Aerial Photography | Drone perspectives of the East End |

---

## Pricing

### Paper Prints (Matted, Open Edition)
*Printed in-house on archival paper with acid-free matting*

| Size | Mat Size | Price |
|------|----------|-------|
| 11x14 | 16x20 | $175 |
| 13x19 | 18x24 | $250 |

Ships within 5-7 business days.

### Aluminum Prints (Open Edition)
*Dye-sublimated on premium aluminum. Scratch-resistant, UV-resistant, ready to hang.*

| Size | Price |
|------|-------|
| 16x24 | $675 |
| 20x30 | $995 |
| 24x36 | $1,350 |
| 30x40 | $1,850 |
| 30x45 | $2,150 |
| 40x60 | $3,400 |

Ships within 14-21 business days (lab fulfilled).

**Pricing Formula:** Retail = (Wholesale + Tax + Shipping) Ã— 3.5

---

## Database Models

### Catalog App
- **Collection** - Photo series/collections
- **Photo** - Photographs with title, description, location, orientation, dimensions, embedding (pgvector)
- **ProductVariant** - Purchasable options: size + material (paper/aluminum) + price
- **Product** - Standalone products like books

### Orders App
- **Cart** - Session-based cart (UUID primary key)
- **CartItem** - Links to either ProductVariant or Product
- **Order** - Completed orders with status tracking
- **OrderItem** - Order line items

### Core App
- **Subscriber** - Newsletter subscribers
- **GiftCard** - Gift card codes, balances, expiration
- **GiftCardRedemption** - Audit trail for gift card usage

### Chat App
- **Conversation** - Chat sessions with the AI agent
- **Message** - Individual messages in conversations

---

## Gift Cards & Promotion Codes

### Gift Cards
- **Purchase**: Fixed amounts ($100, $250, $500, $1000, $2500)
- **Check Balance**: `POST /api/gift-cards/check/`
- **Redemption**: Applied at checkout as a Stripe coupon
- Gift card balance is deducted after successful payment
- Partial redemption supported (remaining balance stays on card)

### Stripe Promotion Codes
- Enabled at checkout when no gift card is applied
- Promo codes created in Stripe Dashboard â†’ Products â†’ Coupons
- **Note**: Stripe doesn't allow both gift card (coupon) and promo codes in the same session

### Product Discounts
- `Product.compare_at_price` - For showing "was $X, now $Y" (display only)

---

## Environment Variables

### Backend
```
# Django
SECRET_KEY=               # Django secret key
DEBUG=False               # Must be False in production
DJANGO_SETTINGS_MODULE=config.settings.production

# Database (Railway provides DATABASE_URL automatically)
DATABASE_URL=             # postgres://user:pass@host:port/dbname

# AWS S3
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_STORAGE_BUCKET_NAME=
AWS_S3_REGION_NAME=       # Default: us-east-1

# Stripe
STRIPE_SECRET_KEY=
STRIPE_PUBLISHABLE_KEY=
STRIPE_WEBHOOK_SECRET=

# Email (Resend SMTP)
EMAIL_HOST=               # Default: smtp.resend.com
EMAIL_PORT=               # Default: 587
EMAIL_HOST_USER=          # Default: resend
EMAIL_HOST_PASSWORD=      # Resend API key
DEFAULT_FROM_EMAIL=
ADMIN_EMAIL=

# Newsletter
MAILERLITE_API_KEY=

# CORS/Security
ALLOWED_HOSTS=            # Comma-separated: your-app.railway.app,store-api.matthewraynor.com
CORS_ALLOWED_ORIGINS=     # Comma-separated frontend URLs
FRONTEND_URL=             # For Stripe redirects

# Redis (for Celery)
REDIS_URL=                # Railway Redis addon provides this

# AI APIs
ANTHROPIC_API_KEY=        # For Claude chat agent
OPENAI_API_KEY=           # For embeddings (text-embedding-ada-002)
```

### Frontend (Netlify)
```
NEXT_PUBLIC_API_URL=      # Public API URL (browser requests)
INTERNAL_API_URL=         # Internal URL (server-side, Docker: http://backend:7974/api)
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=
```

---

## Docker Development Setup

**Ports:**
- Frontend: `3000`
- Backend: `7974`
- PostgreSQL: `7975`

**Start development:**
```bash
docker compose up
```

**Services:**
1. **db** - PostgreSQL 16 Alpine with pgvector
2. **backend** - Runs migrations on startup, then `runserver`
3. **frontend** - Runs `npm run dev` with hot reload
4. **redis** - For Celery task queue (optional locally)

---

## Important Technical Details

### Cross-Origin Cookies (Cart Persistence)
- Backend sets `SameSite=None; Secure` cookies
- Frontend must include `credentials: 'include'` on all API calls
- CORS must allow the frontend origin with credentials

### Next.js Image Optimization
```js
// next.config.js
images: {
  remotePatterns: [
    { protocol: 'https', hostname: '*.s3.*.amazonaws.com' },
  ],
}
```

### Dark Mode
Uses Tailwind's `dark:` variants with `prefers-color-scheme` media query (no toggle).

### Server vs Client Data Fetching
- **Server Components**: Use `INTERNAL_API_URL` (service-to-service)
- **Client Components**: Use `NEXT_PUBLIC_API_URL` (browser requests)

### Honeypot Spam Protection
Contact form has hidden honeypot field. If filled by bots, form silently "succeeds" without sending.

### Semantic Photo Search (pgvector)
- Photos have embeddings generated via OpenAI `text-embedding-ada-002`
- Chat agent uses cosine similarity to find photos matching user descriptions
- Embeddings auto-generated on deploy via `start.sh`

---

## API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/collections/` | GET | List all collections |
| `/api/collections/{slug}/` | GET | Collection detail |
| `/api/photos/` | GET | List photos (supports filtering) |
| `/api/photos/{slug}/` | GET | Photo detail with variants |
| `/api/products/` | GET | List products (books, etc.) |
| `/api/cart/` | GET | Get current cart |
| `/api/cart/add/` | POST | Add item to cart |
| `/api/cart/update/` | POST | Update item quantity |
| `/api/cart/remove/` | POST | Remove item |
| `/api/checkout/create-session/` | POST | Create Stripe checkout (accepts `gift_card_code`) |
| `/api/contact/` | POST | Submit contact form |
| `/api/newsletter/subscribe/` | POST | Subscribe to newsletter |
| `/api/gift-cards/purchase/` | POST | Purchase gift card |
| `/api/gift-cards/check/` | POST | Check gift card balance |
| `/api/chat/` | POST | AI chat agent (SSE streaming) |
| `/api/mockup/analyze/` | POST | Upload wall image for ML analysis |
| `/api/health/` | GET | Health check |

---

## Common Issues & Fixes

| Issue | Solution |
|-------|----------|
| Cart not persisting | Check CORS config, ensure `credentials: 'include'`, verify `SameSite=None` cookie |
| S3 images 403 | Check bucket policy, CORS config on bucket, IAM permissions |
| Next.js images broken | Add S3 domain to `remotePatterns` in `next.config.js` |
| Dark mode text invisible | Add `dark:text-gray-100` (or similar) Tailwind classes |
| Stripe webhook fails | Verify `STRIPE_WEBHOOK_SECRET`, check Railway logs |
| CORS errors | Update `CORS_ALLOWED_ORIGINS` in backend settings |
| Embeddings not generating | Check `OPENAI_API_KEY` is set |

---

## Django Admin Actions

### Photo Admin Actions
- **Create paper/aluminum/all variants** - Bulk create variants with default pricing
- **Remove paper/aluminum/all variants** - Bulk delete variants
- **Refresh image dimensions** - Re-save photos to update aspect ratio
- **Delete photos and variants** - Bulk delete photos with their variants

### Default Variant Pricing
Defined in `ProductVariant.DEFAULT_PRICING` - used by bulk create actions.

---

## Feature Status

### Completed
- Stripe checkout integration
- Gift card purchase and redemption at checkout
- Stripe promotion codes (when no gift card applied)
- Newsletter subscription (MailerLite)
- Contact form with honeypot spam protection
- Dark mode support
- Image aspect ratio handling for crop previews
- All collections and product pages
- Cart functionality
- Order confirmation emails
- AI chat shopping agent
- "See in room" wall mockup tool (ML-powered)
- Semantic photo search (pgvector)

### Pre-Launch TODO
- [ ] Configure sales tax (TaxJar/Avalara or manual NY collection)
- [ ] Switch Stripe to live mode
- [ ] Final content review

### Future Enhancements
- Customer reviews/testimonials
- Filter by location/orientation

---

## Git Workflow
User prefers to run git commands manually. Provide commit commands but don't execute push automatically.


================================================
FILE: docker-compose.yml
================================================
# ===========================================
# PORTS: Backend 7974, Frontend 3000, DB 7975
# ===========================================

services:
  db:
    image: pgvector/pgvector:pg16
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: photography_store
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "7975:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    command: >
      sh -c "python manage.py migrate &&
             python manage.py runserver 0.0.0.0:7974"
    volumes:
      - ./backend:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "7974:7974"
    environment:
      - DEBUG=True
      - DJANGO_SETTINGS_MODULE=config.settings.development
      - DATABASE_URL=postgres://postgres:postgres@db:5432/photography_store
      - SECRET_KEY=dev-secret-key-change-in-production
      - STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY:-}
      - STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY:-}
      - STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET:-}
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-}
      - AWS_STORAGE_BUCKET_NAME=${AWS_STORAGE_BUCKET_NAME:-}
      - AWS_S3_REGION_NAME=${AWS_S3_REGION_NAME:-us-east-1}
      - MAILERLITE_API_KEY=${MAILERLITE_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - FRONTEND_URL=http://localhost:3000
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

  frontend:
    build: ./frontend
    command: npm run dev
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.next
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:7974/api
      - INTERNAL_API_URL=http://backend:7974/api
      - NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY:-}
    depends_on:
      - backend

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5

  celery:
    build: ./backend
    command: celery -A config worker -l info --concurrency=1
    volumes:
      - ./backend:/app
      - media_volume:/app/media
    environment:
      - DEBUG=True
      - DJANGO_SETTINGS_MODULE=config.settings.development
      - DATABASE_URL=postgres://postgres:postgres@db:5432/photography_store
      - SECRET_KEY=dev-secret-key-change-in-production
      - REDIS_URL=redis://redis:6379/0
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-}
      - AWS_STORAGE_BUCKET_NAME=${AWS_STORAGE_BUCKET_NAME:-}
      - AWS_S3_REGION_NAME=${AWS_S3_REGION_NAME:-us-east-1}
    depends_on:
      redis:
        condition: service_healthy
      db:
        condition: service_healthy

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:


